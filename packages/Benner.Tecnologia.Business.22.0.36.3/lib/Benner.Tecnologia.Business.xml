<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Benner.Tecnologia.Business</name>
    </assembly>
    <members>
        <member name="P:Benner.Tecnologia.Metadata.Entities.ICompanyEntity.EmpresaMestreInstance">
            <summary>
            Empresa Mestre
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Metadata.Entities.CompanyEntity">
            <summary>
            Classe Obsoleta. Representa as configurações de metadados da tabela de empresas. 
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Metadata.Entities.CompanyEntity.EmpresaMestre">
            <summary>
            Empresa Mestre
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Metadata.Entities.CompanyEntity.companys">
            <summary>
            Cache do retorno do GetAll()
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Metadata.Entities.CompanyEntity.GetAll">
            <summary>
            Retorna todas as empresas com sua empresa mestre
            </summary>
            <returns></returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.AsyncProcessContext">
            <summary>
            Gerenciamento dos processos assíncronos disparados pela regra de negócio. Classe interna da Tecnologia.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.AsyncProcessContext.Add(Benner.Tecnologia.Common.AsyncProcessDetails)">
            <summary>
            Adiciona um processo assíncro no contexto. Os processos adicionados serão exibidos pela ferramenta.
            </summary>
            <param name="details">Instância de AsyncProcessDetails, descritor do processo assíncrono.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.AsyncProcessContext.#ctor(Benner.Tecnologia.Common.TransitoryData)">
            <summary>
            Inicia um novo contexto de execução de processos assíncronos na regra de negócio
            </summary>
            <param name="transitoryData">TransitoryData onde serão adicionados os processos assíncronos</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.AsyncProcessContext.Finalize">
            <summary>
            Finalizador da classe
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.AsyncProcessContext.Dispose(System.Boolean)">
            <summary>
            Finaliza corretamente o AsyncProcessContext
            </summary>
            <param name="disposing">Se foi chamado diretamente</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.AsyncProcessContext.Dispose">
            <summary>
            Finaliza corretamente o AsyncProcessContext
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.AuditEngine">
            <summary>
            Registro de auditoria de entidades
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.AuditEngine.#ctor(Benner.Tecnologia.Common.Services.ISecurityService,Benner.Tecnologia.Business.InternalServices.IAuditService,System.String)">
            <summary>
            Construtor interno da classe, pode ser utilizado em testes passando mocks dos serviços utilizados 
            </summary>
            <param name="securityService">Serviço de segurança</param>
            <param name="auditService">Serviço de auditoria. Pode ser nulo, neste caso não efetiva a gravação da auditoria.</param>
            <param name="entityDefinitionName">Nome da entidade que será auditada</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.AuditEngine.IsAuditedField(Benner.Tecnologia.Common.FieldDefinition)">
            <summary>
            O campo é passível de auditoria?
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.AuditEngine.Active">
            <summary>
            Habilia ou não a gravação de log e/ou auditoria pelo objeto
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.AuditEngine.SetAuditData(Benner.Tecnologia.Common.EntityBase)">
            <summary>
            Informa ao objeto de registro de aditoria qual a operação de auditoria que deverá ser utilizada e também os dados. Ambas informações são obtidas automaticamente da entidade passada.
            </summary>
            <param name="entity">Entidade que deverá ter registro de auditoria</param>
            <returns>Instancia de Audit</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.AuditEngine.SetAuditData(Benner.Tecnologia.Business.AuditOperation,System.Collections.Generic.List{Benner.Tecnologia.Business.AuditFieldValue})">
            <summary>
            Informa ao objeto de registro de aditoria tudo o que é necessário para gravar auditoria
            </summary>
            <param name="operation">Operação de auditoria da entidade (Inclusão, exclusão, alteração)</param>
            <param name="oldValues">Valores antigos que foram alterados ou excluídos e devem ser registrados. Só vai registrar caso a entidade esteja configurada para tal.</param>
            <returns>Instancia de Audit</returns>
        </member>
        <member name="P:Benner.Tecnologia.Business.AuditEngine.AuditEntityInfo">
            <summary>
            Informações de configuração de auditoria para a entidade (necessário executar em BUSINESSLAYER)
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.AuditEngine.CanWrite">
            <summary>
            Retorna true caso a auditoria vai ser gravada, ou seja, 
            retorna true se estiver Active=true, se o SetAuditData foi chamado, 
            se o serviço de auditoria está OK e se a tabela possui log ou auditoria ligado
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.AuditEngine.Write(Benner.Tecnologia.Common.Handle)">
            <summary>
            Registra a auditoria conforme inicializações efetuadas pelo método SetRequiredOption e SetAuditData.<br/>
            A auditoria só será gravada caso a entidade possua a configuração de auditoria informada no método SetRequiredOption.
            </summary>
            <param name="entityHandle">Handle da entidade (registro)</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.AuditFieldValue">
            <summary>
            Valores dos campos que serão registrados na auditoria
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.AuditFieldValue.FieldName">
            <summary>
            Nome do campo
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.AuditFieldValue.DbValue">
            <summary>
            Valor Db do campo
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.AuditOption">
            <summary>
            Tipo de log/auditoria da entidade
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.AuditOption.None">
            <summary>
            Sem log ou auditoria
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.AuditOption.LogUser">
            <summary>
            Log de entidades manipuladas diretamente via interfaces do sistema (telas do WES, WebServices, integrações em geral)
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.AuditOption.LogAuditUser">
            <summary>
            Log e auditoria de entidades manipuladas diretamente via interfaces do sistema (telas do WES, WebServices, integrações em geral)
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.AuditOption.LogAuditBusiness">
            <summary>
            Log e auditoria de entidades manipuladas diretamente via interfaces do sistema (telas do WES, WebServices, integrações em geral) 
            e de entidades manipuladas via regra de negócio
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.AuditOperation">
            <summary>
            Operção de auditoria (Inclusão, Alteração, exclusão)
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.AuditOperation.Insert">
            <summary>
            Inclusão de entidade
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.AuditOperation.Edit">
            <summary>
            Alteração de entidade
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.AuditOperation.Delete">
            <summary>
            Exclusão de entidades
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.AuditOperation.Anonymize">
            <summary>
            Anonimizaçaõ de registros (LGPD)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.AuditEntityInfo">
            <summary>
            Informações de auditoria da entidade no Cache
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.AuditEntityInfo.#ctor">
            <summary>
            Instancia um AuditEntityInfo com as seguintes opções: TableName = "", TableHandle = 1, Option = AuditOption.None
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.AuditEntityInfo.LoadFromDb(System.String)">
            <summary>
            Carrega as informações de auditoria de uma tabela de Z_TABELASCOMAUDITORIA
            </summary>
            <param name="tableName">Nome da tabela</param>
        </member>
        <member name="P:Benner.Tecnologia.Business.AuditEntityInfo.TableName">
            <summary>
            Nome da tabela
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.AuditEntityInfo.TableHandle">
            <summary>
            Handle da tabela
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.AuditEntityInfo.Option">
            <summary>
            Opção de auditoria
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessAuditEngine">
            <summary>
            Registro de auditoria de entidades manipuladas exclusivamente via regra de negócio
            onde apenas será gravado o log e a auditoria quando a opção for AuditOption.LogAuditBusiness
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.RawAuditWriter">
            <summary>
            Registro de auditoria para RawEntityCommand
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.RawAuditWriter.RegisterInsert(System.String,Benner.Tecnologia.Common.Handle)">
            <summary>
            Registra auditoria para comando INSERT INTO
            </summary>
            <param name="entityDefinitionName">Nome da entidade</param>
            <param name="handle">Handle inserido</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.RawAuditWriter.RegisterUpdate(Benner.Tecnologia.Common.EntityBase)">
            <summary>
            Registra auditoria para comando UPDATE
            </summary>
            <param name="oldValuesEntity">Entidade contendo os valores antes do UPDATE. Todos os campos da entidade serão incluídos na auditoria.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.RawAuditWriter.RegisterUpdate(Benner.Tecnologia.Common.EntityBase,System.String[])">
            <summary>
            Registra auditoria para comando UPDATE
            </summary>
            <param name="oldValuesEntity">Entidade contendo os valores antes do UPDATE</param>
            <param name="fieldsToAudit">Lista de campos que devem ser incluídos na auditoria</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.RawAuditWriter.RegisterUpdate(System.String,Benner.Tecnologia.Common.Handle,Benner.Tecnologia.Common.EntityBase)">
            <summary>
            Registra auditoria para comando UPDATE
            </summary>
            <param name="entityDefinitionName">Nome da entidade</param>
            <param name="handle">Handle da entidade que será atualizada</param>
            <param name="oldValuesEntity">Entidade contendo os valores antes do UPDATE. Todos os campos da entidade serão incluídos na auditoria.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.RawAuditWriter.RegisterUpdate(System.String,Benner.Tecnologia.Common.Handle,Benner.Tecnologia.Common.EntityBase,System.String[])">
            <summary>
            Registra auditoria para comando UPDATE
            </summary>
            <param name="entityDefinitionName">Nome da entidade</param>
            <param name="handle">Handle da entidade que será atualizada</param>
            <param name="oldValuesEntity">Entidade contendo os valores antes do UPDATE</param>
            <param name="fieldsToAudit">Lista de campos que devem ser incluídos na auditoria</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.RawAuditWriter.RegisterDelete(Benner.Tecnologia.Common.EntityBase)">
            <summary>
            Registra auditoria para comando DELETE
            </summary>
            <param name="oldValuesEntity">Entidade contendo os valores antes do DELETE. Todos os campos da entidade serão incluídos na auditoria.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.RawAuditWriter.RegisterDelete(Benner.Tecnologia.Common.EntityBase,System.String[])">
            <summary>
            Registra auditoria para comando DELETE
            </summary>
            <param name="oldValuesEntity">Entidade contendo os valores antes do DELETE.</param>
            <param name="fieldsToAudit">Lista de campos que devem ser incluídos na auditoria</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.RawAuditWriter.RegisterDelete(System.String,Benner.Tecnologia.Common.Handle,Benner.Tecnologia.Common.EntityBase)">
            <summary>
            Registra auditoria para comando DELETE
            </summary>
            <param name="entityDefinitionName">Nome da entidade</param>
            <param name="handle">Handle da entidade que será excluída</param>
            <param name="oldValuesEntity">Entidade contendo os valores antes do DELETE. Todos os campos da entidade serão incluídos na auditoria.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.RawAuditWriter.RegisterDelete(System.String,Benner.Tecnologia.Common.Handle,Benner.Tecnologia.Common.EntityBase,System.String[])">
            <summary>
            Registra auditoria para comando DELETE
            </summary>
            <param name="entityDefinitionName">Nome da entidade</param>
            <param name="handle">Handle da entidade que será excluída</param>
            <param name="oldValuesEntity">Entidade contendo os valores antes do DELETE</param>
            <param name="fieldsToAudit">Lista de campos que devem ser incluídos na auditoria</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.RawAuditWriter.IsAuditedField(Benner.Tecnologia.Common.FieldDefinition)">
            <summary>
            O campo é passível de auditoria?
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponentObjectRegisterer.Register``1(Ninject.IKernel)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponentObjectRegisterer.Register(Ninject.IKernel,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponentObjectRegisterer.Register``2(Ninject.IKernel)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponentObjectRegisterer.Register(Ninject.IKernel,System.Type,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponentProxyRegisterer.RegisterProxy``1(Ninject.IKernel)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponentProxyRegisterer.RegisterProxy(Ninject.IKernel,System.Type)">
            <inheritdoc />
        </member>
        <member name="T:Benner.Tecnologia.Business.Counter.BusinessCounterImplementation">
            <summary>
            Objeto representa um contador de Z_CONTADORES.
            Na criação do objeto não é gerado nenhum exceção, somente ao utilizar os métodos para consumir os serviços disponibilizados.
            </summary>
            <example>
            <para>
            Exemplo de utilização de contador universal.
            </para>
            <code>
            IBusinessCounter contador = BusinessCounterService.GetExisting("JacobusContadorTeste");
            int x = contador.Next();
            </code>
            <para>
            Para utilização de contador não universal identificado por um valor de chave
            </para>
            <code>
            IBusinessCounter contador = BusinessCounterService.GetExisting("JacobusContadorTeste2", 10);
            int x = contador.Next();
            </code>   
            <para>
            Nos exemplos acima é adicionado 1 ao valor atual do contador. Para somar valores diferentes utlizar os seguinte método<code>int x = contador.Netx(10)</code>, isto irá incrementar o contador em 10 e retornará o seu numero atual.
            Os contadores "JacobusContadorTeste" e "JacobusContadotrTeste2" nos exemplos acima os contadores devem existir previamente cadastrados na base.
            </para>
            <para>
            Ao tulizar o método <code>BusinessCounter.Get("JacobusContador")</code> se o contador não existir na base, o mesmo será cadastrado. Conforme exemplo
            <code>
            IBusinessCounter contador = BusinessCounter.Get("JacobusContador");
            contador.Max = 10; // Opcional, informa o valor máximo que o contador deve atingir.
            int x = contador.Next();
            </code>
            </para>
            </example>    
        </member>
        <member name="P:Benner.Tecnologia.Business.Counter.BusinessCounterImplementation.CounterName">
            <summary>
            Nome do contador atual
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Counter.BusinessCounterImplementation.Universal">
            <summary>
            Se é um contador Universal (sem chave)
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Counter.BusinessCounterImplementation.Key">
            <summary>
            Chave para o item do contador não universal.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Counter.BusinessCounterImplementation.CounterType">
            <summary>
            Tipo do contador atual.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Counter.BusinessCounterImplementation.Max">
            <summary>
            Valor Máximo na utilização do contador.
            Ao atingir este número o contador é zerado.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounterImplementation.GetExisting(System.String)">
            <summary>
            Retorna um objeto que representa um contador universal de Z_CONTADORES
            </summary>
            <param name="counterName">Identificação do contador</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounterImplementation.GetExisting(System.String,System.Int32)">
            <summary>
            Retorna um objeto que representa um contador não universal
            </summary>
            <param name="counterName">Identificação do contador</param>
            <param name="key">Identificãção da chave o item</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounterImplementation.GetLocked(System.String)">
            <summary>
            Retorna um objeto que representa um contador universal para utilização em transação.
            </summary>
            <param name="counterName">Identificação do contador</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounterImplementation.GetLocked(System.String,System.Int32)">
            <summary>
            Retorna um objeto que representa um contador não universal para utilização em transação.
            </summary>
            <param name="counterName">Identificação do contador</param>
            <param name="key">Identificãção da chave o item</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounterImplementation.Get(System.String)">
            <summary>
            Retorna um objeto que representa um contador universal. Ao utilizar o método Next(), caso não existir será criado com a identificação informada.
            </summary>
            <param name="counterName">Identificação do contador</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounterImplementation.Get(System.String,System.Int32)">
            <summary>
            Retorna um objeto que representa um contador não universal. Ao utilizar o método Next(), caso não existir será criado com a identificação informada.
            </summary>
            <param name="counterName">Identificação do contador</param>
            /// <param name="key">Identificãção da chave o item</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounterImplementation.Next">
            <summary>
            Retorna o valor atual do contador. E incrementa o valor atual do contador em 1 unidade
            </summary>
            <returns>Valor atual do contador</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounterImplementation.Next(System.Int32)">
            <summary>
             Retorna o valor atual do contador e incrementa o valor por <paramref name="count"/> unidades
            </summary>
            <param name="count">Número que deve ser incrementado ao valor atual do contador</param>
            <returns>Valor atual do contador</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounterImplementation.NextSuggest(System.Int32)">
            <summary>
            Retorna o maior valor entre a sugestão e o valor atual do contador em Z_CONTADORES
            </summary>
            <param name="suggest">Valor que será comparado com o retorno do contador, o maior valor será retornado</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounterImplementation.NextSuggest(System.Int32,System.Int32)">
            <summary>
            Retorna o maior valor entre a sugestão e o valor atual do contador em Z_CONTADORES, incrementado por <paramref name="count"/>
            </summary>
            <param name="count">Numero a ser adicionado ao valor atual do contador</param>
            <param name="suggest">Valor que será comparado com o retorno do contador, o maior valor será retornado</param>
            <returns></returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Counter.BusinessCounterFactory">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounterFactory.GetExisting(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounterFactory.GetExisting(System.String,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounterFactory.GetLocked(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounterFactory.GetLocked(System.String,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounterFactory.Get(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounterFactory.Get(System.String,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Benner.Tecnologia.Business.Counter.BusinessCounterType">
            <summary>
            Identifica o tipo de contador
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.Counter.BusinessCounterType.ExistedCounter">
            <summary>
            Representa um tipo de Contador que já existe previamente na base. 
            Para cria-ló utilize os métodos<code>BusinessCounter.GetExisting()</code>
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.Counter.BusinessCounterType.LockedCounter">
            <summary>
            Define um contador de uso transacional. Equivalente ao uso de NewCounterLocekd do BSistema
            Para cria-ló utilize os métodos<code>BusinessCounter.GetLocked()</code>
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.Counter.BusinessCounterType.AutoCreatedCounter">
            <summary>
            Define um contador que pode ou não existir na base. Caso não existir, será criado pela API. Semelhante ao uso de NewCounter4 do BSistema.        
            Para cria-ló utilize os métodos<code>BusinessCounter.Get()</code>
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Counter.BusinessCounter">
            <summary>
            Objeto que executa a lógica para um contador, cadastrados em Z_CONTADORES.
            Na criação do objeto não é gerado nenhum exceção, somente ao utilizar os métodos para consumir os serviços disponibilizados.
            
            Para uma programação desacoplada utilize a interface IBusinessCounterFactory para obter as instâncias de contadores.
            </summary>
            <example>
            <para>
            Exemplo de utilização de contador universal.
            </para>
            <code>
            BusinessCounter contador = BusinessCounter.GetExisting("JacobusContadorTeste");
            int x = contador.Next();
            </code>
            <para>
            Para utilização de contador não universal identificado por um valor de chave
            </para>
            <code>
            BusinessCounter contador = BusinessCounter.GetExisting("JacobusContadorTeste2", 10);
            int x = contador.Next();
            </code>   
            <para>
            Nos exemplos acima é adicionado 1 ao valor atual do contador. Para somar valores diferentes utlizar os seguinte método<code>int x = contador.Netx(10)</code>, isto irá incrementar o contador em 10 e retornará o seu numero atual.
            Os contadores "JacobusContadorTeste" e "JacobusContadotrTeste2" nos exemplos acima os contadores devem existir previamente cadastrados na base.
            </para>
            <para>
            Ao tulizar o método <code>BusinessCounter.Get("JacobusContador")</code> se o contador não existir na base, o mesmo será cadastrado. Conforme exemplo
            <code>
            BusinessCounter contador = BusinessCounter.Get("JacobusContador");
            contador.Max = 10; // Opcional, informa o valor máximo que o contador deve atingir.
            int x = contador.Next();
            </code>
            </para>
            </example>    
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounter.GetExisting(System.String)">
            <summary>
            Recupera um objeto de contador universal existente em Z_CONTADORES.
            Este método não gera nenhum exceção
            </summary>
            <overloads>
            Recupera um objeto de contador. Já deve existir na base em Z_CONTADORES.
            Não suporta NextSuggest(int suggest).
            </overloads>
            <param name="counterName">Nome do contador</param>
            <returns>Objeto que representa um contador</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounter.GetExisting(System.String,System.Int32)">
            <summary>
            Recupera um objeto de contador não universal existente em Z_CONTADORES.
            Este método não gera nenhum exceção
            </summary>
            
            <param name="counterName">Nome do contador</param>
            <param name="key">Identificador da chave para o item do contador não universal</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounter.GetLocked(System.String)">
            <summary>
            Recupera um objeto de contador universal existente em Z_CONTADORES. 
            Este método não gera nenhum exceção
            O objeto de retorno utilizará os métodos NewCounterLocked e NewCounterLocked2 para obter o contador. Sendo possível sua utilização em transação.
            </summary>
            <overloads>
            Recupera um objeto de contador que já deve existir na base em Z_CONTADORES. 
            Ao utilizar o contador, deve estar em contexto transacional. Semelhante ao NewConterLocked
            </overloads>
            <param name="counterName">Nome do contador</param>
            <returns>Objeto que representa um contador</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounter.GetLocked(System.String,System.Int32)">
            <summary>
            Recupera um objeto de contador não universal existente em Z_CONTADORES. 
            Este método não gera nenhum exceção
            O objeto de retorno utilizará os métodos NewCounterLocked e NewCounterLocked2 para obter o contador. Sendo possível sua utilização em transação.
            </summary>
            <param name="counterName">Nome do contador</param>
            <param name="key">Identificador da chave para o item do contador não universal</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounter.Get(System.String)">
            <summary>
            Recupera um objeto de contador universal existente em Z_CONTADORES. 
            Caso não existir, será criado o contador
            Este método não gera nenhum exceção
            O objeto de retorno utilizará os métodos NewCounter4 para obter o contador. 
            </summary>
            <overloads>
            Recupera um objeto de contador. Na utilização, caso o contador não existir, o mesmo será cadastrado.
            </overloads>
            <param name="counterName">Nome do contador</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.BusinessCounter.Get(System.String,System.Int32)">
            <summary>
            Recupera um objeto de contador universal existente em Z_CONTADORES. 
            Caso não existir, será criado o contador
            O objeto de retorno utilizará os métodos NewCounter4 para obter o contador. 
            </summary>
            <param name="counterName">Nome do contador</param>
            <param name="key">Identificador da chave para o item do contador não universal</param>
            <returns></returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Counter.IBusinessCounter">
            <summary>
            Interface para utilização de Counter
            </summary>   
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.IBusinessCounter.Next">
            <summary>
            Retorna o valor atual do contador. E incrementa o valor atual do contador em 1 unidade
            </summary>
            <returns>Valor atual do contador</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.IBusinessCounter.Next(System.Int32)">
            <summary>
             Retorna o valor atual do contador e incrementa o valor por <paramref name="count"/> unidades
            </summary>
            <param name="count">Número que deve ser incrementado ao valor atual do contador</param>
            <returns>Valor atual do contador</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.IBusinessCounter.NextSuggest(System.Int32)">
            <summary>
            Retorna o maior valor entre a sugestão e o valor atual do contador em Z_CONTADORES
            </summary>
            <param name="suggest">Valor que será comparado com o retorno do contador, o maior valor será retornado</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Counter.IBusinessCounter.NextSuggest(System.Int32,System.Int32)">
            <summary>
            Retorna o maior valor entre a sugestão e o valor atual do contador em Z_CONTADORES, incrementado por <paramref name="count"/>
            </summary>
            <param name="count">Numero a ser adicionado ao valor atual do contador</param>
            <param name="suggest">Valor que será comparado com o retorno do contador, o maior valor será retornado</param>
            <returns></returns>
        </member>
        <member name="P:Benner.Tecnologia.Business.Counter.IBusinessCounter.Universal">
            <summary>
            Se é universal (sem chave).
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Counter.IBusinessCounter.Key">
            <summary>
            Chave para o item do contador não universal.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Counter.IBusinessCounter.Max">
            <summary>
            Valor Máximo na utilização do contador.
            Ao atingir este número o contador é zerado.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Counter.IBusinessCounter.CounterName">
            <summary>
            Nome do contador atual
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Counter.IBusinessCounter.CounterType">
            <summary>
            Tipo do contador atual.
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.InternalServices.IAuditService">
            <summary>
            Interface do serviço de gravação de auditoria em Z_LOG
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.InternalServices.IAuditService.GetAuditInfo(System.String)">
            <summary>
            Obtém informações da configuração de auditora para determinada entidade
            </summary>
            <param name="entityDefinitionName"></param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.InternalServices.IAuditService.WriteAudit(Benner.Tecnologia.Business.AuditOperation,Benner.Tecnologia.Common.Handle,Benner.Tecnologia.Common.Handle,System.DateTime,System.String,System.Collections.Generic.List{Benner.Tecnologia.Business.AuditFieldValue})">
            <summary>
            Registra a auditoria em Z_LOG
            </summary>
            <param name="operation">Operação (Inclusão, alteração, exclusão)</param>
            <param name="tableHandle">Handle da tabela em Z_TABELAS</param>
            <param name="recordHandle">Handle do registro</param>
            <param name="dateTime">Data/hora</param>
            <param name="username">Usuário</param>
            <param name="oldFieldValues">Valores antigos alterados que serão registrados. Pode ser nulo.</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.InternalServices.IBusinessDocumentService">
            <summary>
            Interface do serviço de execução de gravação de arquivos (BDoc)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.InternalServices.BusinessEntityCompanyService.BusinessEntityCompanyService">
            <summary>
            Serviço de consulta de empresa mestre (EntityCompany)
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.InternalServices.BusinessEntityCompanyService.BusinessEntityCompanyService.EntityCompany(System.String)">
            <summary>
            Retorna o handle da empresa. Ou empresa mestre se o nome da tabela da entidade for por empresa mestre
            </summary>
            <param name="entityDefinitionName">Nome da entidade</param>
            <returns>Handle da empresa</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.InternalServices.IBusinessEntityCompanyService">
            <summary>
            Define a interface do serviço que entrega a empresa mestre 
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.InternalServices.IBusinessEntityCompanyService.EntityCompany(System.String)">
            <summary>
            Retorna o Handle da empresa mestre da entidade especializada.
            </summary>
            <param name="entityDefinitionName">Nome da tabela que se deseja consultar.</param>
            <returns>Empresa ou empresa mestre da tabela.</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.InternalServices.InteropUtils.PresentationInteropUtils">
            <summary>
            Serviço de interoperabilidade com o legado para camada de apresentação
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.InternalServices.InteropUtils.PresentationInteropUtils.SystemMonitorRecordGrouped(System.String,System.String,System.DateTime,System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Benner.Tecnologia.Business.InternalServices.IBusinessCounterService">
            <summary>
            Interface de Factory para utilização de Counter através do Jacobus.
            Para maiores exemplos de utilização verificar <seealso cref="!:Benner.Tecnologia.Application.Services.Counter.BusinessCounter"/>
            </summary>   
            Exemplo de utilização de BusinessCouterService
            Benner.Tecnologia.Application.Services.Counter
        </member>
        <member name="M:Benner.Tecnologia.Business.InternalServices.IBusinessCounterService.GetExisting(System.String)">
            <summary>
            Recupera um objeto de contador universal existente em Z_CONTADORES.
            Este método não gera nenhum exceção
            </summary>
            <param name="counterName">Nome do contador</param>
            <returns>Objeto que representa um contador</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.InternalServices.IBusinessCounterService.GetExisting(System.String,System.Int32)">
            <summary>
            Recupera um objeto de contador não universal existente em Z_CONTADORES.
            Este método não gera nenhum exceção
            </summary>
            <param name="counterName">Nome do contador</param>
            <param name="key">Identificador da chave para o item do contador não universal</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.InternalServices.IBusinessCounterService.GetLocked(System.String)">
            <summary>
            Recupera um objeto de contador universal existente em Z_CONTADORES. 
            Este método não gera nenhum exceção
            O objeto de retorno utilizará os métodos NewCounterLocked e NewCounterLocked2 para obter o contador. Sendo possível sua utilização em transação.
            </summary>
            <param name="counterName"></param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.InternalServices.IBusinessCounterService.GetLocked(System.String,System.Int32)">
            <summary>
            Recupera um objeto de contador não universal existente em Z_CONTADORES. 
            Este método não gera nenhum exceção
            O objeto de retorno utilizará os métodos NewCounterLocked e NewCounterLocked2 para obter o contador. Sendo possível sua utilização em transação.
            </summary>
            <param name="counterName">Nome do contador</param>
            <param name="key">Identificador da chave para o item do contador não universal</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.InternalServices.IBusinessCounterService.Get(System.String)">
            <summary>
            Recupera um objeto de contador universal existente em Z_CONTADORES. 
            Caso não existir, será criado o contador
            Este método não gera nenhum exceção
            O objeto de retorno utilizará os métodos NewCounter4 para obter o contador. 
            </summary>
            <param name="counterName">Nome do contador</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Benner.Tecnologia.Business.InternalServices.IBusinessCounterService.Get(System.String,System.Int32)" -->
        <member name="T:Benner.Tecnologia.Business.InternalServices.IMailMessageService">
            <summary>
            Complementa na camada de negócios a interface do serviço de envio de emails.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.InternalServices.IMailMessageService.ReplyTo">
            <summary>
            Propriedade para informar o "Reponder para".
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.InternalServices.IMailMessageService.SendTo">
            <summary>
            Destinatário da mensagem. Se for mais de um separar com ; (ponto e vírgula).
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.InternalServices.IMailMessageService.SystemUser">
            <summary>
            Handle do usuário remetente no envio de e-mail
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.InternalServices.IMailMessageService.Cc">
            <summary>
            Com cópia para. Se for mais de um separar com ; (ponto e vírgula).
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.InternalServices.IMailMessageService.Bcc">
            <summary>
            Cópia oculta. Se for mais de um separar com ; (ponto e vírgula).
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.InternalServices.IMailMessageService.Subject">
            <summary>
            Assunto do email.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.InternalServices.IMailMessageService.Body">
            <summary>
            Corpo da mensagem.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.InternalServices.IMailMessageService.IsBodyHtml">
            <summary>
            Informe True nesta propriedade se desejar informar um HTML como corpo do e-mail ao invés de informar um texto plano.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.InternalServices.IMailMessageService.AlternativeBody">
            <summary>
            Corpo alternativo da mensagem, em texto.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.InternalServices.IMailMessageService.Priority">
            <summary>
            Prioridade do e-mail
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.InternalServices.IMailMessageService.DeliveryNotificationOptions">
            <summary>
            Tipo de confirmação de recebimento. 
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.InternalServices.IMailMessageService.Send">
            <summary>
            Envia a mensagem
            Este método pode gerar uma exceção devido ao "time out" de 1 minuto.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.InternalServices.IMailMessageService.RequestReadReceipt">
            <summary>
            Solicita a confirmação de recebimento de leitura do email.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.InternalServices.IMailMessageService.AddAttachment(System.String)">
            <summary>
            Adiciona um anexo a mensagem
            Este método não exceção.
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:Benner.Tecnologia.Business.InternalServices.IMailMessageService.AddLinkedResource(System.String)">
            <summary>
            Adiciona uma imagem embarcada para o envio de email. O HTML  deve conter &lt; img src="cid:nomeImagem" /&gt;.
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="T:Benner.Tecnologia.Business.InternalServices.IBusinessAdministrationService">
            <summary>
            Define a interface do serviço de administração quanto a recursos exclusivos da camada de negócios.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.InternalServices.IBusinessAdministrationService.SetSystemInstanceName(System.String)">
            <summary>
            Define o nome da instância do sistema.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.InternalServices.IBusinessSecurityService.PasswordEncode(System.String)">
            <summary>
            Criptografa uma string com o algoritmo de senhas da Benner
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.InternalServices.IBusinessSecurityService.ChangePassword(System.String,System.String,System.String)">
            <summary>
            Altera a senha de um usuário passado como parâmetro no sistema atual
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.InternalServices.IInteropUtils">
            <summary>
            Utilitários genéricos de interoperabilidade com o legado
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.InternalServices.IInteropUtils.SystemMonitorRecordGrouped(System.String,System.String,System.DateTime,System.String)">
            <summary>
            Grava um registro em System Monitor de forma agrupada
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.InternalServices.IInteropUtils.CopyUser(Benner.Tecnologia.Common.Handle,Benner.Tecnologia.Common.Handle,System.String,System.String,System.String)">
            <summary>
            Copia um usuário de Z_GrupoUsuarios
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.LGPDAnonymizer">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.LGPDAnonymizer.All">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.LGPDAnonymizer.ByDocument(System.String)">
            <inheritdoc />
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateConditionFunction">
            <summary>
            @CONDICAO('NOME_CAMPO_NA_TABELA', 'OPERACAO', NOME_CAMPO_FILTRO)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateDateTimeFunction">
            <summary>
            @DATAHORA(dd/mm/aaaa hh24:mm:ss)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateTableFunction">
            <summary>
            @CRITERIOSELECAO
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateBitOffFunction">
            <summary>
            @BITDESLIGADO(NOMEDOCAMPO, VALORDOBIT)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateCriticoFunction">
            <summary>
            @CRITICO
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateBitOnFunction">
            <summary>
            @BITLIGADO(NOMEDOCAMPO, VALORDOBIT)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateMasterCompanyFunction">
            <summary>
            @EMPRESAMESTRE(NOMETABELA)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener">
            <summary>
            This class provides an empty implementation of <see cref="T:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener"/>,
            which can be extended to create a listener which only needs to handle a subset
            of the available methods.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.EnterQuery(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.QueryContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.query"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.ExitQuery(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.QueryContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.query"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.EnterItem(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.ItemContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.item"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.ExitItem(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.ItemContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.item"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.EnterItem_string(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Item_stringContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.item_string"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.ExitItem_string(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Item_stringContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.item_string"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.EnterSql_fragment(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Sql_fragmentContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.sql_fragment"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.ExitSql_fragment(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Sql_fragmentContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.sql_fragment"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.EnterFunction(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.FunctionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.function"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.ExitFunction(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.FunctionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.function"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.EnterParams(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.ParamsContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:QueryFunctionParser.params"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.ExitParams(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.ParamsContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:QueryFunctionParser.params"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.EnterParam_expr(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_exprContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_expr"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.ExitParam_expr(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_exprContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_expr"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.EnterParam(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.ParamContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.ExitParam(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.ParamContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.EnterParam_fragment(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_fragmentContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_fragment"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.ExitParam_fragment(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_fragmentContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_fragment"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.EnterParam_parentesis(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_parentesisContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_parentesis"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.ExitParam_parentesis(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_parentesisContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_parentesis"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.EnterParam_string(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_stringContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_string"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.ExitParam_string(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_stringContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_string"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.EnterParam_expr_inside(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_expr_insideContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_expr_inside"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.ExitParam_expr_inside(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_expr_insideContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_expr_inside"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.EnterParam_inside(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_insideContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_inside"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.ExitParam_inside(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_insideContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_inside"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.EnterParam_inside_fragment(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_inside_fragmentContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_inside_fragment"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.ExitParam_inside_fragment(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_inside_fragmentContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_inside_fragment"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.EnterString(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.StringContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:QueryFunctionParser.string"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.ExitString(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.StringContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:QueryFunctionParser.string"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.EnterEveryRule(Antlr4.Runtime.ParserRuleContext)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.ExitEveryRule(Antlr4.Runtime.ParserRuleContext)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionBaseListener.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener">
            <summary>
            This interface defines a complete listener for a parse tree produced by
            <see cref="T:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser"/>.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.EnterQuery(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.QueryContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.query"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.ExitQuery(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.QueryContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.query"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.EnterItem(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.ItemContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.item"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.ExitItem(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.ItemContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.item"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.EnterItem_string(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Item_stringContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.item_string"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.ExitItem_string(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Item_stringContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.item_string"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.EnterSql_fragment(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Sql_fragmentContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.sql_fragment"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.ExitSql_fragment(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Sql_fragmentContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.sql_fragment"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.EnterFunction(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.FunctionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.function"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.ExitFunction(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.FunctionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.function"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.EnterParams(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.ParamsContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:QueryFunctionParser.params"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.ExitParams(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.ParamsContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:QueryFunctionParser.params"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.EnterParam_expr(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_exprContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_expr"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.ExitParam_expr(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_exprContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_expr"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.EnterParam(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.ParamContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.ExitParam(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.ParamContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.EnterParam_fragment(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_fragmentContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_fragment"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.ExitParam_fragment(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_fragmentContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_fragment"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.EnterParam_parentesis(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_parentesisContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_parentesis"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.ExitParam_parentesis(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_parentesisContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_parentesis"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.EnterParam_string(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_stringContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_string"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.ExitParam_string(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_stringContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_string"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.EnterParam_expr_inside(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_expr_insideContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_expr_inside"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.ExitParam_expr_inside(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_expr_insideContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_expr_inside"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.EnterParam_inside(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_insideContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_inside"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.ExitParam_inside(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_insideContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_inside"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.EnterParam_inside_fragment(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_inside_fragmentContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_inside_fragment"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.ExitParam_inside_fragment(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.Param_inside_fragmentContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.param_inside_fragment"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.EnterString(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.StringContext)">
            <summary>
            Enter a parse tree produced by <see cref="!:QueryFunctionParser.string"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.Antlr.IQueryFunctionListener.ExitString(Benner.Tecnologia.Business.QueryFunctions.Antlr.QueryFunctionParser.StringContext)">
            <summary>
            Exit a parse tree produced by <see cref="!:QueryFunctionParser.string"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.Period">
            <summary>
            Cinto de utilidades para Datas
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.SelectFuncs">
            <summary>
            Cinto de utilidades para Datas
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.ParamsExtensions">
            <summary>
            Extensões para geração de nomes de parâmetros SQL
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.ParamsExtensions.ToParameterName(System.String)">
            <summary>
            Converte a string para um nome válido de parâmetro de SQL 
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.ParamsExtensions.ToParameterLiteral(System.String)">
            <summary>
            Converte um nome de parâmetro para literal no comando SQL. Ex.: PARAM para :PARAM
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.ITranslateFunction">
            <summary>
            Implementação de tradução de @FUNÇÃO
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.ITranslateFunctionDataSource">
            <summary>
            Tradução de @FUNÇÃO que requer dados externos
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.QueryFunctions.ITranslateFunctionDataSource.RequireData">
            <summary>
            Se a tradução deve ser acionada apenas se a Definition e os Fields forem informados.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.QueryFunctions.ITranslateFunctionDataSource.Definition">
            <summary>
            Definição de entidade
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.QueryFunctions.ITranslateFunctionDataSource.Fields">
            <summary>
            Campos e seus valores
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.ITranslateFunctionDataSource.EmptyResult(System.String,System.String)">
            <summary>
            Se RequireData é obrigátorio qual tipo de função é retornada
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.QueryFunctionErrorListener.SyntaxError(System.IO.TextWriter,Antlr4.Runtime.IRecognizer,System.Int32,System.Int32,System.Int32,System.String,Antlr4.Runtime.RecognitionException)">
            <summary>
            Lexer error
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.QueryFunctionErrorListener.SyntaxError(System.IO.TextWriter,Antlr4.Runtime.IRecognizer,Antlr4.Runtime.IToken,System.Int32,System.Int32,System.String,Antlr4.Runtime.RecognitionException)">
            <summary>
            Parsing error
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateAliasFunction">
            <summary>
            @ALIAS
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateDatabaseLinkFunction">
            <summary>
            @DATABASELINK() @DBLINK()
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateBranchesFunction">
            <summary>
            @FILIAIS
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateBranchFunction">
            <summary>
            @FILIAL
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateCompanyFunction">
            <summary>
            @EMPRESA
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateDateFunction">
            <summary>
            @DATA(dd/mm/aaaa)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateDatePartFunction">
            <summary>
            @DATA_PARTE e @DATAPARTE
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateExecFunctionFunction">
            <summary>
            @EXEC_FUNCTION
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateFieldFunction">
            <summary>
            @CAMPO / @~CAMPO
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateFortnightFunction">
            <summary>
            @QUINZENA[1] e @QUINZENA[2]
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateIsNullFunction">
            <summary>
            @TROCARNULO
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateOptionalSessionFunction">
            <summary>
            @~SESSAO
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions">
            <summary>
            Constantes das regex para tradução de @FUNÇÕES
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.FuncRegex">
            <summary>
            Regex que representa uma função. Ex.: @FUNCAO(PARAMETRO)
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.FuncNameRegex">
            <summary>
            Regex para o nome de uma função. Ex.: @FUNCAO
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.FuncOrParamRegex">
            <summary>
            Regex que representa uma função ou parâmetro. Ex.: @FUNCAO(PARAMETRO) ou :PARAMETRO
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.FuncNameOrParamNameRegex">
            <summary>
            Regex para o nome de uma função ou parâmetro. Ex.: @FUNCAO ou :PARAMETRO
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.FuncArgsRegex">
            <summary>
            Regex para os argumentos de uma função. Ex.: (PARAMETROS)
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.Lookup">
            <summary>
            Expressão GenSQL, ex: CAMPO>TABELA.CAMPO>TABELA.CAMPO...
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.TableField">
            <summary>
            Campo da tabela principal, ex: A.CAMPO
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.AnyField">
            <summary>
            Qualquer campo, ex: XYZ.CAMPO
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.Condition">
            <summary>
            Condição SQL (=, LIKE, IS, etc)
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.Value">
            <summary>
            Valor. Aceita parâmetros (:PARAM), string ('Texto'), funções (@FUNC(XPTO)) e demais literais numéricas e identificadores (999, CAMPO, TABELA.CAMPO).
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.Parameter">
            <summary>
            Parâmetro, ex: :PARAM
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.String">
            <summary>
            Literal string, ex: 'Texto'
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.Function">
            <summary>
            Função, ex: @AGORA, @DATA(25/12/2008), @MAIUSCULAS(:PARAM), @MAIUSCULAS('Texto'), @FUNCAO('Texto', :PARAM), @EXEC_FUNCTION(FUNCAO_DE_BANCO(:PARAM1, PARAM2))
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.FunctionName">
            <summary>
            Nome de função, ex: @FUNCAO, @FUNCAO[1]
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.FunctionArgument">
            <summary>
            Argumento de função incluindo os parentesis da função, ex: ('Texto'), (:PARAM) ou (XYZ.TABELA) 
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.FunctionMultiArguments">
            <summary>
            Múltiplos argumentos de função incluindo os parentesis da função, ex: ('Texto', :PARAM)
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.FunctionAsArgument">
            <summary>
            Argumento de função de @FUNCAO que é uma outra função de banco, utilizado para detectar os parâmetros do @EXEC_FUNCTION(FUNCAO_DE_BANCO(:PARAM1, PARAM2))
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.NumberOrIdentifier">
            <summary>
            Números ou identificadores, ex: 999, TABELA.CAMPO, CAMPO
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.Number">
            <summary>
            Números inteiros. Positivos ou negativos.
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.QueryFunctions.TranslateFunctions.Space">
            <summary>
            Espaços (podem ou não existir)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateMonthFunction">
            <summary>
            @MES[1] e @MES[2]
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateNowFunction">
            <summary>
            @NOW e @AGORA
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateQueryFunctions">
             <summary>
             Classe responsável pela tradução de funções Benner-SQL (@AGORA, @USUARIO, @CAMPO, etc)
             </summary>
             <example> Exemplo de utilização do método de Tradução de @FUNCOES.
             <code>
             <![CDATA[
               class MyClass 
               {
                  public void TraduzirArrobaFuncoes() 
                  {         
                      String sql = "SELECT * FROM TABELA A WHERE A.DATA = @AGORA AND A.DATA = @AGORA AND A.USUARIO = @USUARIO";
                      TranslateQueryFunctions translate = new TranslateQueryFunctions();
                      String translatedSql = translate.Translate(sql);
            
                      sql = "SELECT * FROM TABELA A WHERE A.DATA = @AGORA AND B.DATA = @AGORA";
                      translatedSql = translate.Translate(sql);
                  }
             
                  public void Ao_Utilizar_ARROBA_MAIUSCULAS_Em_Parametro_O_Valor_Do_Parametro_Deve_Ser_Modificado_Para_Maiusculo()
                  {
                      var sql = "Nome = @MAIUSCULAS(:Nome)";
                      var criteria = new Criteria();
                      criteria.Parameters.Add("Nome", "Benner");
             
                      var translateFunctions = new TranslateQueryFunctions();
                      var translatedSql = translateFunctions.Translate(sql, criteria);
             
                      Assert.AreEqual("BENNER", criteria.Parameters[0].Value);
                  }
                  public void Uma_Query_Com_ARROBA_SEMESTRE1_E_ARROBA_SEMESTRE2_Deve_Ser_Traduzida_E_Receber_Dois_Parametros_Com_Primeiro_E_Ultimo_Dia_Do_Semestre_Atual()
                  {
                      var sql = "Inicio = @SEMESTRE[1] and Final = @SEMESTRE[2]";
             
                      var translateFunctions = new TranslateQueryFunctions();
                      var translatedSql = translateFunctions.Translate(sql);
            
                      Assert.IsTrue(translatedSql.Contains(":SEMESTRE_1_") && translatedSql.Contains(":SEMESTRE_2_"));
                      Assert.AreEqual(2, translateFunctions.Criteria.Parameters.Count);
                      Assert.AreEqual(SelectFuncs.SixMonth(Period.Begin), (DateTime)translateFunctions.Criteria.Parameters[0].Value);
                      Assert.AreEqual(SelectFuncs.SixMonth(Period.End), (DateTime)translateFunctions.Criteria.Parameters[1].Value);
                  }
               }
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.TranslateQueryFunctions.#ctor">
            <summary>
            Instancia um TranslateQueryFunctions com otimização ativa
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.TranslateQueryFunctions.#ctor(System.Boolean)">
            <summary>
            Instancia um TranslateQueryFunctions passando um parâmetro de otimização. O parâmetro é ativo por padrão
            </summary>
            <param name="optimizeTranslation">Se deve otimizar a tradução checando por funções arroba</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.TranslateQueryFunctions.Translate(System.String)">
            <summary>
            Traduz funções Benner-SQL (@AGORA, @USUARIO, @CAMPO, etc)
            </summary>
            <param name="sql">Cláusula SQL com funções que devem ser traduzidas</param>
            <returns>Retorna uma string SQL com as funções traduzidas.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.TranslateQueryFunctions.TranslateToImportArtifacts(System.String)">
            <summary>
            Traduz funções Benner-SQL (@AGORA, @USUARIO, @CAMPO, etc)
            </summary>
            <param name="sql">Cláusula SQL com funções que devem ser traduzidas</param>
            <returns>Retorna uma string SQL com as funções traduzidas para importação de artefatos.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.TranslateQueryFunctions.TranslateToImportArtifacts(System.String,Benner.Tecnologia.Common.Criteria)">
            <summary>
            Traduz funções Benner-SQL (@AGORA, @USUARIO, @CAMPO, etc)
            </summary>
            <param name="sql">Cláusula SQL com funções que devem ser traduzidas</param>
            <param name="criteria">Objeto do tipo Criteria. Neste objeto poderão ser adicionados parâmetros com os resultados de algumas funções.</param>
            <returns>Retorna uma string SQL com as funções traduzidas para importação de artefatos.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.TranslateQueryFunctions.Translate(System.String,Benner.Tecnologia.Common.Criteria)">
            <summary>
            Traduz funções Benner-SQL (@AGORA, @USUARIO, @CAMPO, etc)
            </summary>
            <param name="sql">Cláusula SQL com funções que devem ser traduzidas</param>
            <param name="criteria">Objeto do tipo Criteria. Neste objeto poderão ser adicionados parâmetros com os resultados de algumas funções.</param>
            <returns>Retorna uma string SQL com as funções traduzidas.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.TranslateQueryFunctions.Translate(System.String,Benner.Tecnologia.Common.Criteria,Benner.Tecnologia.Common.EntityDefinition,Benner.Tecnologia.Common.NameValueDictionary)">
            <summary>
            Traduz funções Benner-SQL (@AGORA, @USUARIO, @CAMPO, etc)
            </summary>
            <param name="sql">Cláusula SQL com funções que devem ser traduzidas</param>
            <param name="criteria">Objeto do tipo Criteria. Neste objeto poderão ser adicionados parâmetros com os resultados de algumas funções.</param>
            <param name="externalDefinition">Definição da entidade que servirá para prover dados para a função</param>
            <param name="externalFields">Lista de campos e seus valores da entidade que irá prover dados para a função</param>
            <returns>Retorna uma string SQL com as funções traduzidas.</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateRoleFunction">
            <summary>
            @PAPEL
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateSelectionCriteriaFunction">
            <summary>
            @CRITERIOSELECAO
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateSessionFunction">
            <summary>
            @SESSAO
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateSixMonthsFunction">
            <summary>
            @SEMESTRE[1] e @SEMESTRE[2]
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateNextHandleFunction">
            <summary>
            @PROXHANDLE
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateTasksFunction">
            <summary>
            @TAREFAS
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateThreeMonthsFunction">
            <summary>
            @TRIMESTRE[1] e @TRIMESTRE[2]
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateTodayFunction">
            <summary>
            @TODAY e @HOJE
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateTwoMonthsFunction">
            <summary>
            @BIMESTRE[1] e @BIMESTRE[2]
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateTableFiltersFunction">
            <summary>
            @FILTROSDATABELA
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateUpperFunction">
            <summary>
            @MAIUSCULAS
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateUserFunction">
            <summary>
            @USUARIO
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateWeekFunction">
            <summary>
            @SEMANA[1] e @SEMANA[2]
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateWflCoordenacaoPapeis">
            <summary>
            @WFL_COORDENACAO_PAPEIS
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateWflCoordenacaoPapeisTarefas">
            <summary>
            @WFL_COORDENACAO_PAPEIS_TAREFAS
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateWflInbox">
            <summary>
            @WFL_INBOX
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.TranslateYearFunction">
            <summary>
            @ANO[1] e @ANO[2]
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.QueryFunctionListenerImplementation">
                                                         ///
              Grammar specified at the QueryFunction.g4  ///
              file using ANTLR grammar specification.    ///
                                                         ///
        </member>
        <member name="T:Benner.Tecnologia.Business.QueryFunctions.QueryFunctionMetadata">
            <summary>
            Guarda os dados de uma função arroba para serem traduzidos.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.QueryFunctionMetadata.#ctor(System.String)">
            <summary>
            Instancia a função arroba definindo qual o seu nome
            </summary>
            <param name="name">Nome da função arroba</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.QueryFunctionMetadata.AppendToCurrentParam(System.String)">
            <summary>
            Adiciona conteúdo a um parâmetro
            </summary>
            <param name="param">Conteúdo a ser adicionado</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.QueryFunctionMetadata.FinishCurrentParam">
            <summary>
            Encerra o conteúdo adicionado e adiciona o parâmetro à lista.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.QueryFunctions.QueryFunctionMetadata.Translate(Benner.Tecnologia.Common.Criteria,Benner.Tecnologia.Common.EntityDefinition,Benner.Tecnologia.Common.NameValueDictionary)">
            <summary>
            Traduz a função arroba com os parâmetros adicionados anteriormente
            </summary>
            <param name="criteria">Objeto do tipo Criteria. Neste objeto poderão ser adicionados parâmetros com os resultados de algumas funções.</param>
            <param name="externalDefinition">Definição da entidade que servirá para prover dados para a função</param>
            <param name="externalFields">Lista de campos e seus valores da entidade que irá prover dados para a função</param>
            <returns>Retorna uma string contenda a função traduzida.</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.SendSMS">
            <summary>
            Envio de SMS
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SendSMS.FromPhoneNumber">
            <summary>
            Número de telefone usado para o envio
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SendSMS.PhoneNumber">
            <summary>
            Número do Telefone para envio do SMS
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SendSMS.Text">
            <summary>
            Texto a ser enviado
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.SendSMS.Send">
            <summary>
            Enviar SMS
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.SendSMS.Send(System.String,System.String,System.String)">
            <summary>
            Enviar SMS
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.SMS.SendSMSTwilio">
            <summary>
            Envio de SMS da Twilio
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.SMS.SendSMSTwilio.#ctor(System.String,System.String)">
            <summary>
            construtor
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.SMS.SendSMSZenvia">
            <summary>
            Envio de SMS da Zenvia
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Services.IBusinessComponentFactory">
            <summary>
            Factory de componentes de negócio multi-camadas
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IBusinessComponentFactory.CreateInstance``1">
            <summary>
            Na camada Business cria uma instância do componente de negócio, na presentation cria um Proxy para o componente.
            </summary>
            <typeparam name="T">Interface ou classe do componente</typeparam>
            <returns>Instância do componente ou do proxy</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IBusinessComponentFactory.CreateInstance(System.Type)">
            <summary>
            Na camada Business cria uma instância do componente de negócio, na presentation cria um Proxy para o componente.
            </summary>
            <param name="type">Tipo da interface ou classe do componente</param>
            <returns>Instância do componente ou do proxy</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Services.IBusinessComponentObjectRegisterer">
            <summary>
            Registrador de componentes de negócio.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IBusinessComponentObjectRegisterer.Register``1(Ninject.IKernel)">
            <summary>
            Registra o tipo de BusinessComponent informado no Kernel do módulo Ninject.
            </summary>
            <typeparam name="T">Tipo do BusinessComponent a ser registrado (classe).</typeparam>
            <param name="kernel">Kernel do módulo Ninject onde o registro acontecerá.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IBusinessComponentObjectRegisterer.Register(Ninject.IKernel,System.Type)">
            <summary>
            Registra o tipo de BusinessComponent informado no Kernel do módulo Ninject.
            </summary>
            <param name="kernel">Kernel do módulo Ninject onde o registro acontecerá.</param>
            <param name="implementationType">Tipo do BusinessComponent a ser registrado (classe).</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IBusinessComponentObjectRegisterer.Register``2(Ninject.IKernel)">
            <summary>
            Registra a Interface e o BusinessComponent informados no Kernel do módulo Ninject.
            </summary>
            <typeparam name="TInterface">Tipo da Interface a ser registrada.</typeparam>
            <typeparam name="TComponente">Tipo do BusinessComponent a ser registrado (classe).</typeparam>
            <param name="kernel">Kernel do módulo Ninject onde o registro acontecerá.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IBusinessComponentObjectRegisterer.Register(Ninject.IKernel,System.Type,System.Type)">
            <summary>
            Registra a Interface e o BusinessComponent informados no Kernel do módulo Ninject.
            </summary>
            <param name="kernel">Kernel do módulo Ninject onde o registro acontecerá.</param>
            <param name="interfaceType">Tipo da Interface a ser registrada.</param>
            <param name="implementationType">Tipo do BusinessComponent a ser registrado.</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.Services.IBusinessComponentProxyRegisterer">
            <summary>
            Registrador de proxies para Componentes de negócio
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IBusinessComponentProxyRegisterer.RegisterProxy``1(Ninject.IKernel)">
            <summary>
            Registra no Ninject um proxy para um componente de negócio permitindo que o proxy seja injetado no código.
            Este proxy irá chamar os métodos do componente utilizando o BennerContext.BusinessComponent.Call, 
            possibilitando o acionamento do componente via camada de apresentação.
            </summary>
            <typeparam name="TInterface">Interface do componente de negócio</typeparam>
            <param name="kernel">Kernel do Ninject</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IBusinessComponentProxyRegisterer.RegisterProxy(Ninject.IKernel,System.Type)">
            <summary>
            Registra no Ninject um proxy para um componente de negócio permitindo que o proxy seja injetado no código.
            Este proxy irá chamar os métodos do componente utilizando o BennerContext.BusinessComponent.Call, 
            possibilitando o acionamento do componente via camada de apresentação.
            </summary>
            <param name="kernel">Kernel do Ninject</param>
            <param name="interfaceType">Interface do componente de negócio</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.Services.IMailService">
            <summary>
            Serviço de envio de email
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IMailService.NewMailMessage">
            <summary>
            Cria uma nova mensagem de email
            </summary>
            <returns>Instância de MailMessage</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IMailService.NewMailMessage(Benner.Tecnologia.Common.Handle,System.String,System.String)">
            <summary>
            Inicializa a mensagem com os parâmetros informados.
            </summary>
            <param name="systemUser">Handle do usuário remetente do e-mail que será enviado</param>
            <param name="to">Destinatário(s) do e-mail. Separados por ',' ou ';'</param>
            <param name="subject">Assunto do e-email</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IMailService.NewMailMessage(Benner.Tecnologia.Common.Handle,System.String,System.String,System.String)">
            <summary>
            Inicializa a mensagem com os parâmetros informados.
            </summary>
            <param name="systemUser">Handle do usuário remetente do e-mail que será enviado</param>
            <param name="to">Destinatário(s) do e-mail. Separados por ',' ou ';'</param>
            <param name="subject">Assunto do e-email</param>
            <param name="body">Corpo ou mensagem do e-mail que será enviado. Utilizar a propriedade <see cref="P:Benner.Tecnologia.Business.IMailMessage.Body"/> para completar o texto da mensagem a ser enviada.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IMailService.NewMailMessage(Benner.Tecnologia.Common.Handle,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Inicializa a mensagem com os parâmetros informados.
            </summary>
            <param name="systemUser">Handle do usuário remetente do e-mail que será enviado</param>
            <param name="to">Destinatário(s) do e-mail. Separados por ',' ou ';'</param>
            <param name="subject">Assunto do e-email</param>
            <param name="body">Corpo ou mensagem do e-mail que será enviado. Utilizar a propriedade <see cref="P:Benner.Tecnologia.Business.IMailMessage.Body"/> para completar o texto da mensagem a ser enviada.</param>
            <param name="bodyIsHtml">Se a mensagem deve ser enviada como HTML ou texto puro. Valor padrão é texto puro.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IMailService.NewMailMessage(Benner.Tecnologia.Common.Handle,System.String,System.String,System.String,System.Boolean,System.String)">
            <summary>
            Inicializa a mensagem com os parâmetros informados.
            </summary>
            <param name="systemUser">Handle do usuário remetente do e-mail que será enviado</param>
            <param name="to">Destinatário(s) do e-mail. Separados por ',' ou ';'</param>
            <param name="subject">Assunto do e-email</param>
            <param name="body">Corpo ou mensagem do e-mail que será enviado. Utilizar a propriedade <see cref="P:Benner.Tecnologia.Business.IMailMessage.Body"/> para completar o texto da mensagem a ser enviada.</param>
            <param name="bodyIsHtml">Se a mensagem deve ser enviada como HTML ou texto puro. Valor padrão é texto puro.</param>
            <param name="alternativeBody">Corpo ou mensagem alternativo, que sempre será enviado como texto."/> </param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IMailService.Send(Benner.Tecnologia.Business.IMailMessage)">
            <summary>
            Envia a mensagem. 
            </summary>
            <param name="mailMessage">Mensagem de email</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IMailService.Send(System.String,System.String,System.String)">
            <summary>
            Envia a mensagem com os parametros informados. O remetente será o usuário atual
            Por padrão o corpo da mensagem é HTML, o parametro opicional isBodyHtml pode alterar isto.
            Se ambos corpos forem informados, ambos serão enviados em partes diferentes, e o parâmetro body será em texto.
            </summary>
            <param name="to">Destinatário(s) do e-mail. Separados por ',' ou ';'</param>
            <param name="subject">Assunto do e-email</param>
            <param name="body">Corpo ou mensagem do e-mail que será enviado.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IMailService.Send(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Envia a mensagem com os parametros informados. O remetente será o usuário atual
            Por padrão o corpo da mensagem é HTML, o parametro opicional isBodyHtml pode alterar isto.
            Se ambos corpos forem informados, ambos serão enviados em partes diferentes, e o parâmetro body será em texto.
            </summary>
            <param name="to">Destinatário(s) do e-mail. Separados por ',' ou ';'</param>
            <param name="subject">Assunto do e-email</param>
            <param name="body">Corpo ou mensagem do e-mail que será enviado.</param>
            <param name="isBodyHtml">Se a mensagem deve ser enviada como HTML ou texto puro. Valor padrão é texto puro.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IMailService.Send(System.String,System.String,System.String,System.Boolean,System.String)">
            <summary>
            Envia a mensagem com os parametros informados. O remetente será o usuário atual
            Por padrão o corpo da mensagem é HTML, o parametro opicional isBodyHtml pode alterar isto.
            Se ambos corpos forem informados, ambos serão enviados em partes diferentes, e o parâmetro body será em texto.
            </summary>
            <param name="to">Destinatário(s) do e-mail. Separados por ',' ou ';'</param>
            <param name="subject">Assunto do e-email</param>
            <param name="body">Corpo ou mensagem do e-mail que será enviado.</param>
            <param name="isBodyHtml">Se a mensagem deve ser enviada como HTML ou texto puro. Valor padrão é texto puro.</param>
            <param name="alternativeBody">Corpo ou mensagem alternativa do e-mail que será enviado. Normalmente texto puro para clientes que não visualizam HTML. Opcional, e sempre será enviado como texto.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IMailService.Send(Benner.Tecnologia.Common.Handle,System.String,System.String,System.String)">
            <summary>
            Envia a mensagem com os parametros informados. 
            Por padrão o corpo da mensagem é HTML, o parametro opicional isBodyHtml pode alterar isto.
            Se ambos corpos forem informados, ambos serão enviados em partes diferentes, e o parâmetro body será em texto.
            </summary>
            <param name="systemUser">Usuário remetente do e-mail que será enviado</param>
            <param name="to">Destinatário(s) do e-mail. Separados por ',' ou ';'</param>
            <param name="subject">Assunto do e-email</param>
            <param name="body">Corpo ou mensagem do e-mail que será enviado.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IMailService.Send(Benner.Tecnologia.Common.Handle,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Envia a mensagem com os parametros informados. 
            Por padrão o corpo da mensagem é HTML, o parametro opicional isBodyHtml pode alterar isto.
            Se ambos corpos forem informados, ambos serão enviados em partes diferentes, e o parâmetro body será em texto.
            </summary>
            <param name="systemUser">Usuário remetente do e-mail que será enviado</param>
            <param name="to">Destinatário(s) do e-mail. Separados por ',' ou ';'</param>
            <param name="subject">Assunto do e-email</param>
            <param name="body">Corpo ou mensagem do e-mail que será enviado.</param>
            <param name="isBodyHtml">Se a mensagem deve ser enviada como HTML ou texto puro. Valor padrão é texto puro.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IMailService.Send(Benner.Tecnologia.Common.Handle,System.String,System.String,System.String,System.Boolean,System.String)">
            <summary>
            Envia a mensagem com os parametros informados. 
            Por padrão o corpo da mensagem é HTML, o parametro opicional isBodyHtml pode alterar isto.
            Se ambos corpos forem informados, ambos serão enviados em partes diferentes, e o parâmetro body será em texto.
            </summary>
            <param name="systemUser">Usuário remetente do e-mail que será enviado</param>
            <param name="to">Destinatário(s) do e-mail. Separados por ',' ou ';'</param>
            <param name="subject">Assunto do e-email</param>
            <param name="body">Corpo ou mensagem do e-mail que será enviado.</param>
            <param name="isBodyHtml">Se a mensagem deve ser enviada como HTML ou texto puro. Valor padrão é texto puro.</param>
            <param name="alternativeBody">Corpo alternativo da mensagem. Normalmente texto puro para clientes que não visualizam HTML.</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.Services.IBennerEnvironment">
            <summary>
            Informações do ambiente Benner atual
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IBennerEnvironment.ReloadEnvironmentInfo">
            <summary>
            Recarrega as informações de ambiente (Se é produção e descrição)
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Services.IBennerEnvironment.IsProduction">
            <summary>
            Retorna true se é ambiente de produção
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Services.IBennerEnvironment.Description">
            <summary>
            Descrição do ambiente
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Services.IBennerEnvironment.IsBenner">
            <summary>
            Retorna true se é um ambiente instalado internamente na Benner e false se for ambiente de cliente
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Services.IBennerEnvironment.IsCustomSystem">
            <summary>
            Retorna true se é um sistema específico
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Services.IBennerEnvironment.IsVerticalSystem">
            <summary>
            Retorna true se é um sistema vertical
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Services.IBennerEnvironment.ServerDate">
            <summary>
            Data atual na camada de negócio (apenas data)
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Services.IBennerEnvironment.ServerDateTime">
            <summary>
            Data e hora atual na camada de negócio
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Services.IBennerEnvironment.DbVersion">
            <summary>
            Versão da base de dados (Versão DB)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Services.IBusinessComponentObjectFactory">
            <summary>
            Factory para componentes de negócio.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IBusinessComponentObjectFactory.CreateInstance``1">
            <summary>
            Cria uma instância do tipo do BusinessComponent informado.
            </summary>
            <typeparam name="T">Tipo do BusinessComponent a ser instanciado.</typeparam>
            <returns>Instância do  BusinessComponent solicitado.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IBusinessComponentObjectFactory.CreateInstance(System.Type)">
            <summary>
            Cria uma instância do tipo do BusinessComponent informado.
            </summary>
            <param name="type">Tipo do BusinessComponent a ser instanciado.</param>
            <returns>Instância do  BusinessComponent solicitado.</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Services.IBusinessComponentProxyFactory">
            <summary>
            Factory de proxies para componentes de negócio.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IBusinessComponentProxyFactory.CreateProxyInstance``1">
            <summary>
            Cria um proxy para um componente de negócio a partir da sua interface. Este proxy irá chamar os métodos
            do componente utilizando o BennerContext.BusinessComponent.Call, possibilitando o acionamento do componente
            via camada de apresentação.
            </summary>
            <typeparam name="TInterface">Interface do componente de negócio</typeparam>
            <returns>Proxy para o componente</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IBusinessComponentProxyFactory.CreateProxyInstance(System.Type)">
            <summary>
            Cria um proxy para um componente de negócio a partir da sua interface. Este proxy irá chamar os métodos
            do componente utilizando o BennerContext.BusinessComponent.Call, possibilitando o acionamento do componente
            via camada de apresentação.
            </summary>
            <param name="interfaceType">Interface do componente de negócio</param>
            <returns>Proxy para o componente</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Services.IBusinessCounterFactory">
            <summary>
            Contadores de negócio
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IBusinessCounterFactory.GetExisting(System.String)">
            <summary>
            Recupera um objeto de contador universal existente em Z_CONTADORES.
            Este método não gera nenhum exceção
            </summary>
            <overloads>
            Recupera um objeto de contador. Já deve existir na base em Z_CONTADORES.
            Não suporta NextSuggest(int suggest).
            </overloads>
            <param name="counterName">Nome do contador</param>
            <returns>Objeto que representa um contador</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IBusinessCounterFactory.GetExisting(System.String,System.Int32)">
            <summary>
            Recupera um objeto de contador não universal existente em Z_CONTADORES.
            Este método não gera nenhum exceção
            </summary>
            
            <param name="counterName">Nome do contador</param>
            <param name="key">Identificador da chave para o item do contador não universal</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IBusinessCounterFactory.GetLocked(System.String)">
            <summary>
            Recupera um objeto de contador universal existente em Z_CONTADORES. 
            Este método não gera nenhum exceção
            O objeto de retorno utilizará os métodos NewCounterLocked e NewCounterLocked2 para obter o contador. Sendo possível sua utilização em transação.
            </summary>
            <overloads>
            Recupera um objeto de contador que já deve existir na base em Z_CONTADORES. 
            Ao utilizar o contador, deve estar em contexto transacional. Semelhante ao NewConterLocked
            </overloads>
            <param name="counterName">Nome do contador</param>
            <returns>Objeto que representa um contador</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IBusinessCounterFactory.GetLocked(System.String,System.Int32)">
            <summary>
            Recupera um objeto de contador não universal existente em Z_CONTADORES. 
            Este método não gera nenhum exceção
            O objeto de retorno utilizará os métodos NewCounterLocked e NewCounterLocked2 para obter o contador. Sendo possível sua utilização em transação.
            </summary>
            <param name="counterName">Nome do contador</param>
            <param name="key">Identificador da chave para o item do contador não universal</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IBusinessCounterFactory.Get(System.String)">
            <summary>
            Recupera um objeto de contador universal existente em Z_CONTADORES. 
            Caso não existir, será criado o contador
            Este método não gera nenhum exceção
            O objeto de retorno utilizará os métodos NewCounter4 para obter o contador. 
            </summary>
            <overloads>
            Recupera um objeto de contador. Na utilização, caso o contador não existir, o mesmo será cadastrado.
            </overloads>
            <param name="counterName">Nome do contador</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IBusinessCounterFactory.Get(System.String,System.Int32)">
            <summary>
            Recupera um objeto de contador universal existente em Z_CONTADORES. 
            Caso não existir, será criado o contador
            O objeto de retorno utilizará os métodos NewCounter4 para obter o contador. 
            </summary>
            <param name="counterName">Nome do contador</param>
            <param name="key">Identificador da chave para o item do contador não universal</param>
            <returns></returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Services.IProcessLogFactory">
            <summary>
            Factory do IProcessLog para monitoramento de processos
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IProcessLogFactory.GetMainProcess">
            <summary>
            Retorna o processo pai caso ele exista, em cenários de processos aninhados.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IProcessLogFactory.GetScheduledProcess">
            <summary>
            Retorna o agendamento que deu origem ao processamento.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Services.IProcessLogFactory.CreateProcessLog">
            <summary>
            Nova instância de IProcessLog
            </summary>
            <returns>Instância de ProcessLog</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.BefVersionValidator.BefVersionValidatorComponent">
            <summary>
            Esta classe se propõe a validar a versão das dlls que compõem o BEF
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BefVersionValidator.BefVersionValidatorComponent.ValidateBefVersion(System.String)">
            <summary>
            Validação de versão de dll e requisitos de dll do Bef.
            </summary>
            <param name="requiredBefVersion">Versão requerida Ex: 16.0.0.0</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.BefVersionValidator.BefVersionValidatorEntity">
            <summary>
            Esta classe se propõe a validar a versão das dlls que compõem o BEF
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BefVersionValidator.BefVersionValidatorEntity.ValidateVersionRequired(System.String)">
            <summary>
            Valida a versão do BEF com a versão da Commom. É chamado pelo Runner, não alterar seu nome.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BefVersionValidator.BefVersionValidatorEntity.ValidateBefVersion(Benner.Tecnologia.Business.BusinessArgs)">
            <summary>
            Valida a versão do BEF com a versão passada por parametro no BusinessArgs
            </summary>
            <param name="args">BusinessArgs contendo a chave REQUIRED_BEF_VERSION com a versão que deve ser validada.</param>
            <returns></returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessComponent">
            <summary>
            Classe abstrata para o desenvolvimento de componentes de negócio e factory de componentes de negócio
            </summary>
            <summary>
            Classe abstrata para o desenvolvimento de componentes de negócio e factory de componentes de negócio
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponent.CreateProxyInstance``1">
            <summary>
            Cria um proxy para um componente de negócio a partir da sua interface. Este proxy irá chamar os métodos
            do componente utilizando o BennerContext.BusinessComponent.Call, possibilitando o acionamento do componente
            via camada de apresentação.
            </summary>
            <typeparam name="TInterface">Interface do componente de negócio</typeparam>
            <returns>Proxy para o componente</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponent.CreateProxyInstance(System.Type)">
            <summary>
            Cria um proxy para um componente de negócio a partir da sua interface. Este proxy irá chamar os métodos
            do componente utilizando o BennerContext.BusinessComponent.Call, possibilitando o acionamento do componente
            via camada de apresentação.
            </summary>
            <param name="interfaceType">Interface do componente de negócio</param>
            <returns>Proxy para o componente</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponent.RegisterProxy``1(Ninject.IKernel)">
            <summary>
            Registra no Ninject um proxy para um componente de negócio permitindo que o proxy seja injetado no código.
            Este proxy irá chamar os métodos do componente utilizando o BennerContext.BusinessComponent.Call, 
            possibilitando o acionamento do componente via camada de apresentação.
            </summary>
            <typeparam name="TInterface">Interface do componente de negócio</typeparam>
            <param name="kernel">Kernel do Ninject</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponent.RegisterProxy(Ninject.IKernel,System.Type)">
            <summary>
            Registra no Ninject um proxy para um componente de negócio permitindo que o proxy seja injetado no código.
            Este proxy irá chamar os métodos do componente utilizando o BennerContext.BusinessComponent.Call, 
            possibilitando o acionamento do componente via camada de apresentação.
            </summary>
            <param name="kernel">Kernel do Ninject</param>
            <param name="interfaceType">Interface do componente de negócio</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponent.#ctor">
            <summary>
            Construtor padrão de BusinessComponente. Desativado.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponent.CreateInstance``1">
            <summary>
            Cria uma instância do tipo do BusinessComponent informado.
            </summary>
            <typeparam name="T">Tipo do BusinessComponent a ser instanciado.</typeparam>
            <returns>Instância do  BusinessComponent solicitado.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponent.CreateInstance(System.Type)">
            <summary>
            Cria uma instância do tipo do BusinessComponent informado.
            </summary>
            <param name="type">Tipo do BusinessComponent a ser instanciado.</param>
            <returns>Instância do  BusinessComponent solicitado.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponent.Register``1(Ninject.IKernel)">
            <summary>
            Registra o tipo de BusinessComponent informado no Kernel do módulo Ninject.
            </summary>
            <typeparam name="T">Tipo do BusinessComponent a ser registrado (classe).</typeparam>
            <param name="kernel">Kernel do módulo Ninject onde o registro acontecerá.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponent.Register(Ninject.IKernel,System.Type)">
            <summary>
            Registra o tipo de BusinessComponent informado no Kernel do módulo Ninject.
            </summary>
            <param name="kernel">Kernel do módulo Ninject onde o registro acontecerá.</param>
            <param name="implementationType">Tipo do BusinessComponent a ser registrado (classe).</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponent.Register``2(Ninject.IKernel)">
            <summary>
            Registra a Interface e o BusinessComponent informados no Kernel do módulo Ninject.
            </summary>
            <typeparam name="TInterface">Tipo da Interface a ser registrada.</typeparam>
            <typeparam name="TComponent">Tipo do BusinessComponent a ser registrado (classe).</typeparam>
            <param name="kernel">Kernel do módulo Ninject onde o registro acontecerá.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponent.Register(Ninject.IKernel,System.Type,System.Type)">
            <summary>
            Registra a Interface e o BusinessComponent informados no Kernel do módulo Ninject.
            </summary>
            <param name="kernel">Kernel do módulo Ninject onde o registro acontecerá.</param>
            <param name="interfaceType">Tipo da Interface a ser registrada.</param>
            <param name="implementationType">Tipo do BusinessComponent a ser registrado.</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessComponentObjectFactory">
            <summary>
            Factory para componentes de negócio. Está interno pois a idéia é impedir o uso na camada incorreta.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponentObjectFactory.CreateInstance``1">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponentObjectFactory.CreateInstance(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessComponentProxyFactory">
            <summary>
            Factory de proxies para componentes de negócio. Está interno pois a idéia é impedir o uso na camada incorreta.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponentProxyFactory.CreateProxyInstance``1">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponentProxyFactory.CreateProxyInstance(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessEntity`1">
            <summary>
            Classe base para a implementação de entidades de negócio.
            </summary>
            <typeparam name="T">Tipo que vai representar a entidade.</typeparam>
            <remarks>
            <para>
            Entidades de negócio são objetos que não apenas contém os dados de uma entidade mas também publicam os comportamentos (regras de negócio) 
            específicos desta entidade. 
            </para><para>
            As entidades de negócio do aplicativo devem herdar desta classe, sendo declaradas conforme este exemplo:
            </para><para>
            public class DocumentoFinanceiro : BusinessEntity&lt;DocumentoFinanceiro&gt;.
            </para>
            </remarks>
            <summary>
            Classe base para a implementação de entidades de negócio.
            </summary>
            <summary>
            Classe base para a implementação de entidades de negócio.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Benner#Tecnologia#Business#IBusinessEntity#NewHandle">
            <summary>
            Obtém um novo Handle para esta entidade
            </summary>
            <returns>Novo Handle</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Benner#Tecnologia#Business#IBusinessEntity#VirtualValidate(Microsoft.Practices.EnterpriseLibrary.Validation.ValidationResults)">
            <summary>
            Roda a validação da entidade implementada pelo desenvolvedor no método virtual Validate.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Benner#Tecnologia#Business#IBusinessEntity#InteropValidate">
            <summary>
            Este metódo é chamado pelo Provider/Runner para executar a validação da entidade.
            A validação do Builder não é executada pois o próprio Provider/Runner já o fazem.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.BusinessEntity`1.Benner#Tecnologia#Business#IBusinessEntity#EnsureBusinessLogicExecution">
            <summary>
            Se verdadeiro, vai executar a regra de negócio mesmo que seja uma entidade manipulada diretamente 
            pelas interfaces da ferramenta. Ou seja, vai executar mesmo que TransitoryData.DisableBusinessScript = true. 
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.BusinessEntity`1.Benner#Tecnologia#Business#IBusinessEntity#EntityForScriptUIExecutionOnly">
            <summary>
            Se a entidade serve apenas para rodar scripts de interface
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.BusinessEntity`1.Benner#Tecnologia#Business#IBusinessEntity#DisableBusinessLogicExecution">
            <summary>
            Se deve ou não executar regras de negócio
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Benner#Tecnologia#Business#IBusinessEntity#ResetOutputMessage">
            <summary>
            Limpa as mensagens que porventura foram informadas na operação anterior.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Benner#Tecnologia#Business#IBusinessEntity#LogMethod(System.String)">
            <summary>
            Registra no log o nome do método executado.
            </summary>
            <param name="methodName">Nome do método.</param>
        </member>
        <member name="P:Benner.Tecnologia.Business.BusinessEntity`1.Benner#Tecnologia#Business#IBusinessEntity#AutoFillDefaultValues">
            <summary>
            Determina os campos da entidade devem ser preenchidos automaticamente com o seu valor padrão.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Call(System.String,Benner.Tecnologia.Common.EntityBase,Benner.Tecnologia.Common.NameValueDictionary)">
            <summary>
            Executa uma função da entidade.
            </summary>        
            /// <param name="functionName">Nome da função</param>
            <param name="dataEntity">Dados adicionais a serem utilizados pela função (opcional).</param>
            <param name="transitoryVars">Dados adicionais a serem utilizados pela função (opcional).</param>
            <returns>Retorno da execução da função</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Call(System.String,Benner.Tecnologia.Common.EnterpriseServiceLibrary.Request,Benner.Tecnologia.Common.EntityBase)">
            <summary>
            Executa uma função da entidade passando um documento estruturado (dto) para a lógica de negócio
            </summary>
            <param name="functionName">Nome da função</param>
            <param name="request">Documento estruturado</param>
            <param name="dataEntity">Dados adicionais a serem utilizados pela função (opcional)</param>
            <returns>Retorno da execução da função</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.WebCreating">
            <summary>
            Executa regra de negócio relativa ao momento em que uma nova entidade é criada na camada de apresentação na Web.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.WebCreated">
            <summary>
            Executa regra de negócio relativa ao momento em que uma nova entidade foi criada na camada de apresentação na Web.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.WebEditing">
            <summary>
            Executa regra de negócio relativa ao momento em que a entidade entra em edição na camada de apresentação na Web.
            </summary>
            <remarks>
            Este método é invocado quando a entidade é obtida em modo de edição, ou seja, 
            quando é passado no parâmetro do método "Get" o enumerador "GetMode.Edit".
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.WebEdited">
            <summary>
            Executa regra de negócio relativa ao momento em que a entidade entrou em edição na camada de apresentação na Web.
            </summary>
            <remarks>
            Este método é invocado quando a entidade foi obtida em modo de edição, ou seja, 
            quando foi passado no parâmetro do método "Get" o enumerador "GetMode.Edit".
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.WebValidating">
            <summary>
            Executa regra de negócio relativa ao momento em que a entidade é validada na camada de apresentação na Web
            </summary>
            <remarks>
            Este método é invocado pelo método público "Save" da entidade, antes de ela ser validada e persistida 
            e, nesta ocasião, o contexto ainda não possui transação aberta.
            Este método deve ser utilizado para ajustar os valores das propriedades da entidade antes da persistência (ex. valores dos campos obrigatórios).
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.WebSaving">
            <summary>
            Executa regra de negócio relativa ao momento em que a entidade é persistida na camada de apresentação na Web.
            </summary>
            <remarks>
            Este método é invocado pelo método público "Save" da entidade, após ela ser validada e antes dela ser efetivamente persistida 
            e, nesta ocasião, o contexto ainda não possui transação aberta.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.WebSaved">
            <summary>
            Executa regra de negócio relativa ao momento em que a entidade foi persistida na camada de apresentação na Web.
            </summary>
            <remarks>
            Este método é invocado pelo método público "Save" da entidade, depois de ela ser efetivamente persistida 
            e, nesta ocasião, o contexto possui transação aberta.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.WebDeleting">
            <summary>
            Executa regra de negócio relativa ao momento em que a entidade é excluída na camada de apresentação na Web.
            </summary>
            <remarks>
            Este método é invocado pelo método público "Delete" da entidade, antes de ela ser efetivamente excluída 
            e, nesta ocasião, o contexto possui transação aberta.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.WebDeleted">
            <summary>
            Executa regra de negócio relativa ao momento em que a entidade foi excluída na camada de apresentação na Web.
            </summary>
            <remarks>
            Este método é invocado pelo método público "Delete" da entidade, depois de ela ser efetivamente excluída 
            e, nesta ocasião, o contexto possui transação aberta.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.WebGetting">
            <summary>
            Executa regra de negócio relativa ao momento em que a entidade é obtida na camada de apresentação na Web.
            </summary>
            <remarks>
            Este método é invocado quando uma entidade é obtida pelo método "Get".
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.WebGot">
            <summary>
            Executa regra de negócio relativo ao momento em que a entidade foi obtida na camada de apresentação na Web.
            </summary>
            <remarks>
            Este método é invocado quando uma entidade foi obtida pelo método "Get".
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Validate">
            <summary>
            Executa a validação da entidade
            </summary>
            <returns>Lista de resultados da validação.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Validate(System.Boolean)">
            <summary>
            Executa a validação da entidade com a opção de lançar uma exceção caso a entidade não seja válida.
            </summary>
            <param name="throwOnFail">Determina se uma exceção deve ser lançada caso a entidade não seja válida.</param>
            <remarks>
            Este método é especialmente útil quando não se deseja ler os resultados da validação mas apenas interromper o processo 
            caso a validação falhe.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Validate(Microsoft.Practices.EnterpriseLibrary.Validation.ValidationResults)">
            <summary>
            Valida a entidade incrementando uma lista já existente de resultados de validação.
            </summary>
            <param name="validationResults">Lista de resultados de validação a ser incrementada por esta validação.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.NewHandle">
            <summary>
            Obtém novo handle para a entidade representada por esta classe.
            </summary>
            <returns>Retorna o novo handle adquirido.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.EntityCompany">
            <summary>
            Retorna a empresa mestre da entidade especializada.
            </summary>       
            <overload>Retorna a empresa ou empresa mestre da entidade especializada</overload>
            <returns>Empresa ou empresa mestre da tabela.</returns>
            <example>
            Retornar todas as Mascáras de Z_MASCARAS da empresa ou empresa mestre
            <code>
            [EntityDefinitionName("Z_MASCARAS")]
            public class Mascaras : BusinessEntity&lt;Mascaras&gt; { 
            ... 
                public static Entities&lt;Mascaras&gt; GetManyByCompany()
                {
                   return GetMany(new Criteria("EMPRESA = " + EntityCompany()));
                }
            ...
            }
            </code>
            </example>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.EntityCompany(System.String)">
            <summary>
            Retorna a empresa mestre da tabela
            </summary>
            <param name="entityDefinitionName">Nome da tabela que se deseja consultar.</param>
            <returns>Empresa ou empresa mestre da tabela.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.OnBusinessEntityDeserialized(System.Runtime.Serialization.StreamingContext)">
            <summary>
            A desserialização não chama construtores/inicializadores. Precisamos disto.
            </summary>
            <param name="context">Contexto do desserializador</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.LogMethod(System.String)">
            <summary>
            Registra no log o nome do método executado.
            </summary>
            <param name="methodName">Nome do método.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.ResetOutputMessage">
            <summary>
            Limpa as mensagens que porventura foram informadas na operação anterior.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.LoadLogicalEntityDefinition">
            <summary>
            Carrega as informações de entidade lógica da BusinessEntity caso não tenham sido carregadas
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Creating">
            <summary>
            Executa regra de negócio relativa ao momento em que uma nova entidade é criada.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Created">
            <summary>
            Executa regra de negócio relativa ao momento em que uma nova entidade foi criada.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Editing">
            <summary>
            Executa regra de negócio relativa ao momento em que a entidade entra em edição.
            </summary>
            <remarks>
            Este método é invocado quando a entidade é obtida em modo de edição, ou seja, 
            quando é passado no parâmetro do método "Get" o enumerador "GetMode.Edit".
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Edited">
            <summary>
            Executa regra de negócio relativa ao momento em que a entidade entrou em edição.
            </summary>
            <remarks>
            Este método é invocado quando a entidade foi obtida em modo de edição, ou seja, 
            quando foi passado no parâmetro do método "Get" o enumerador "GetMode.Edit".
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Validating">
            <summary>
            Executa regra de negócio relativa ao momento em que a entidade é validada
            </summary>
            <remarks>
            Este método é invocado pelo método público "Save" da entidade, antes de ela ser validada e persistida 
            e, nesta ocasião, o contexto ainda não possui transação aberta.
            Este método deve ser utilizado para ajustar os valores das propriedades da entidade antes da persistência (ex. valores dos campos obrigatórios).
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Saving">
            <summary>
            Executa regra de negócio relativa ao momento em que a entidade é persistida.
            </summary>
            <remarks>
            Este método é invocado pelo método público "Save" da entidade, após ela ser validada e antes dela ser efetivamente persistida 
            e, nesta ocasião, o contexto ainda não possui transação aberta.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Saved">
            <summary>
            Executa regra de negócio relativa ao momento em que a entidade foi persistida.
            </summary>
            <remarks>
            Este método é invocado pelo método público "Save" da entidade, depois de ela ser efetivamente persistida 
            e, nesta ocasião, o contexto possui transação aberta.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Deleting">
            <summary>
            Executa regra de negócio relativa ao momento em que a entidade é excluída.
            </summary>
            <remarks>
            Este método é invocado pelo método público "Delete" da entidade, antes de ela ser efetivamente excluída 
            e, nesta ocasião, o contexto possui transação aberta.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Deleted">
            <summary>
            Executa regra de negócio relativa ao momento em que a entidade foi excluída.
            </summary>
            <remarks>
            Este método é invocado pelo método público "Delete" da entidade, depois de ela ser efetivamente excluída 
            e, nesta ocasião, o contexto possui transação aberta.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Getting">
            <summary>
            Executa regra de negócio relativa ao momento em que a entidade é obtida.
            </summary>
            <remarks>
            Este método é invocado quando uma entidade é obtida pelo método "Get".
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Got">
            <summary>
            Executa regra de negócio relativo ao momento em que a entidade foi obtida.
            </summary>
            <remarks>
            Este método é invocado quando uma entidade foi obtida pelo método "Get".
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.ExternalValidate(System.String)">
            <summary>
            Executa regra de negócio de validação de lotes do Integrator.
            </summary>
            <remarks>
            Este método é invocado quando uma entidade é acionada pelo Serviço V do Integrator.
            </remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.BusinessEntity`1.IsLogicalEntity">
            <summary>
            Retorna true caso seja uma Entidade Lógica
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.BusinessEntity`1.LogicalEntityDefinition">
            <summary>
            Obtém a denfinição de entidade da entidade lógica. 
            </summary>
            <remarks>
            Se BusinessEntity.IsLogicalEntity seja true, então esta propriedade irá retornar uma instância da definição de entidade da entidade lógica em uso. 
            Caso contrário (BusinessEntity.IsLogicalEntity é false), irá retornar null.
            </remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.BusinessEntity`1.AutoFillDefaultValues">
            <summary>
            Determina os campos da entidade devem ser preenchidos automaticamente com o seu valor padrão.
            </summary>
            <remarks>
            O valor padrão desta propriedade é true.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.GetEntityDefinition">
            <summary>
            Obtém a definição da entidade representada pela classe.
            </summary>
            <returns>Retorna a definição da entidade representada pela classe.</returns>
            <remarks>
            A definição da entidade é obtida com base no nome de definição de entidade informado no atributo de classe "EntityDefinitionName".
            </remarks>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.EntityNotFoundException">Pode estar faltando o atributo EntityDefinitionName na classe da entidade.</exception> 
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Save">
            <summary>
            Persiste a entidade.
            </summary>
            <remarks>
            Este método é invocado pelos consumidores da classe e, além de persistir a entidade, executa regra de negócio relativa ao momento em que a entidade é persistida. 
            Classes herdadas de BusinessEntity não devem sobrescrever este método.
            Para a escrita de regra de negócio, devem ser sobrescritos os métodos "Saving" e "Saved".
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Delete">
            <summary>
            Exclui a entidade.
            </summary>
            <remarks>
            Este método é invocado pelos consumidores da classe e, além de excluir a entidade, executa regra de negócio relativa ao momento em que a entidade é excluída. 
            Classes herdadas de BusinessEntity não devem sobrescrever este método. 
            Para escrita de regras de negócio, devem ser sobrescritos os métodos "Deleting" e "Deleted".
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.InvokeCreate">
            <summary>
            Executa regra de negócio relativa à criação de uma nova entidade.
            </summary>
            <remarks>
            Este método é invocado pelo factory de entidades quando uma nova entidade é criada. 
            Para escrita de regra de negócio relativa a esta operação, devem sobrescritos os métodos "Creating" e "Created".
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.InvokeCreate(Benner.Tecnologia.Common.EntityBase)">
            <summary>
            Executa regra de negócio relativa à criação de uma nova entidade.
            </summary>
            <param name="sourceEntity">Entidade que será clonada</param>
            <remarks>
            Este método é invocado pelo factory de entidades quando uma nova entidade é criada. 
            Para escrita de regra de negócio relativa a esta operação, devem sobrescritos os métodos "Creating" e "Created".
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.InvokeGet">
            <summary>
            Executa regra de negócio relativa ao momento em que a entidade é obtida.
            </summary>
            <remarks>
            Este método é invocado pelo factory de entidades quando uma entidade é resgatada. 
            Para escrita de regra relativa a esta operação, devem ser sobrescritos os métodos "Getting" e "Got".
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.InvokeEdit">
            <summary>
            Executa regra de negócio relativa ao momento em que a entidade é colocada em edição.
            </summary>
            <remarks>
            Este método é invocado pelo factory de entidades quando uma entidade é resgatada para edição. 
            Para escrita de regra relativa a esta operação, devem ser sobrescritos os métodos "Editing" e "Edited".
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.CreateClone(Benner.Tecnologia.Common.Handle)">
            <summary>
            Cria uma nova instância da entidade copiando os valores das propriedades de uma entidade modelo.
            A entidade modelo será obtida através do Handle informado.
            </summary>
            <param name="handle">Handle da entidade modelo que será obtida e terá os valores das propriedades copiados para a nova entidade.</param>
            <returns>Uma nova entidade.</returns>
            <remarks>A entidade será retornada em modo de inserção.</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.CreateClone(`0)">
            <summary>
            Cria uma nova instância da entidade copiando os valores das propriedades de uma entidade modelo.
            </summary>
            <param name="sourceEntity">Entidade modelo que terá os valores das propriedades copiados para a nova entidade.</param>
            <returns>Uma nova entidade. </returns>
            /// <remarks>A entidade será retornada em modo de inserção.</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Create(Benner.Tecnologia.Common.NameValueDictionary)">
            <summary>
            Cria uma nova instância da entidade.
            </summary>
            <overloads>
            Cria uma nova instância da entidade.
            </overloads>
            <param name="suggestedValues">Dicionário contendo valores sugeridos, que a nova instância de entidade irá assumir.</param>
            <returns>Uma nova entidade.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Create">
            <summary>
            Cria uma nova instância inicializada da entidade.
            </summary>
            <returns>Uma nova instância inicializada da entidade.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Create(Benner.Tecnologia.Common.NameValueDictionary,Benner.Tecnologia.Common.TransitoryData)">
            <summary>
            Cria uma nova instância inicializada da entidade.
            </summary>
            <param name="suggestedValues">Dicionário contendo valores sugeridos, que a nova instância de entidade irá assumir.</param>
            <param name="transitoryData">Dicionário contendo os dados transitórios.</param>
            <returns>Uma nova instância inicializada da entidade.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Get(Benner.Tecnologia.Common.Handle)">
            <summary>
            Obtém uma instância da entidade em modo de leitura.
            </summary>
            <overloads>
            Recupera, da origem de dados, uma instância da entidade.
            </overloads>
            <param name="handle">Chave primária.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Get(Benner.Tecnologia.Common.Handle,Benner.Tecnologia.Common.GetMode)">
            <summary>
            Obtém uma instância da entidade em modo de leitura ou de edição.
            </summary>
            <param name="handle">Chave primária.</param>
            <param name="mode">Modo em que o registro deve estar após a recuperação.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Get(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém uma instância da entidade em modo de leitura.
            </summary>
            <param name="criteria">Critério de seleção que identifique um único registro.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Get(Benner.Tecnologia.Common.Criteria,Benner.Tecnologia.Common.GetMode)">
            <summary>
            Obtém uma instância da entidade em modo de leitura ou de edição.
            </summary>
            <param name="criteria">Critério de seleção que identifique um único registro.</param>
            <param name="mode">Modo em que o registro deve estar após a recuperação.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Get(Benner.Tecnologia.Common.Criteria,Benner.Tecnologia.Common.GetMode,Benner.Tecnologia.Common.TransitoryData)">
            <summary>
            Obtém uma instância da entidade em modo de    leitura ou de edição.
            </summary>
            <param name="criteria">Critério de seleção que identifique um único registro.</param>
            <param name="mode">Modo em que o registro deve estar após a recuperação.</param>
            <param name="transitoryData">Dados transitórios da requisição</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.GetAll">
            <summary>
            Obtém todas as instâncias de uma entidade da origem de dados.
            </summary>
            <overloads>
            Obtém, da origem de dados, todas as instâncias da entidade.
            </overloads>
            <returns>Uma coleção com as instâncias da entidade requisitada.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.GetAll(Benner.Tecnologia.Common.TransitoryData)">
            <summary>
            Obtém todas as instâncias de uma entidade da origem de dados.
            </summary>
            <param name="transitoryData">Dicionário contendo os dados transitórios.</param>
            <returns>Uma coleção com as instâncias da entidade requisitada.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.GetFirstOrDefault(Benner.Tecnologia.Common.Handle)">
            <summary>
            Recupera uma instância da entidade.
            </summary>
            <param name="handle">Handle para recuperar a entidade.</param>
            <returns>Caso a condição retorne uma ou mais entidades este método retornará a primeira entidade, 
            caso não haja entidades que cumpram esta condição será retornado nulo.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.GetFirstOrDefault(Benner.Tecnologia.Common.Handle,Benner.Tecnologia.Common.GetMode)">
            <summary>
            Recupera uma instância da entidade.
            </summary>
            <param name="handle">Handle para recuperar a entidade.</param>
            <param name="getMode">GetMode para buscar a entidade com o estado já alterado.</param>
            <returns>Caso a condição retorne uma ou mais entidades este método retornará a primeira entidade, 
            caso não haja entidades que cumpram esta condição será retornado nulo.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.GetFirstOrDefault(Benner.Tecnologia.Common.Handle,Benner.Tecnologia.Common.GetMode,Benner.Tecnologia.Common.TransitoryData)">
            <summary>
            Recupera uma instância da entidade.
            </summary>
            <param name="handle">Handle para recuperar a entidade.</param>
            <param name="getMode">GetMode para buscar a entidade com o estado já alterado.</param>
            <param name="transitoryData">Dados que são passados entre camadas.</param>
            <returns>Caso a condição retorne uma ou mais entidades este método retornará a primeira entidade, 
            caso não haja entidades que cumpram esta condição será retornado nulo.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.GetFirstOrDefault(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Recupera uma instância da entidade.
            </summary>
            <param name="criteria">Critério de seleção que identifique o registro.</param>
            <returns>Caso a condição retorne uma ou mais entidades este método retornará a primeira entidade, 
            caso não haja entidades que cumpram esta condição será retornado nulo.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.GetFirstOrDefault(Benner.Tecnologia.Common.Criteria,Benner.Tecnologia.Common.GetMode)">
            <summary>
            Recupera uma instância da entidade.
            </summary>
            <param name="criteria">Critério de seleção que identifique o registro.</param>
            <param name="getMode">GetMode para buscar a entidade com o estado já alterado.</param>
            <returns>Caso a condição retorne uma ou mais entidades este método retornará a primeira entidade, 
            caso não haja entidades que cumpram esta condição será retornado nulo.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.GetFirstOrDefault(Benner.Tecnologia.Common.Criteria,Benner.Tecnologia.Common.TransitoryData)">
            <summary>
            Recupera uma instância da entidade.
            </summary>
            <param name="criteria">Critério de seleção que identifique o registro.</param>
            <param name="transitoryData">Dados que são passados entre camadas.</param>
            <returns>Caso a condição retorne uma ou mais entidades este método retornará a primeira entidade, 
            caso não haja entidades que cumpram esta condição será retornado nulo.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.GetFirstOrDefault(Benner.Tecnologia.Common.Criteria,Benner.Tecnologia.Common.GetMode,Benner.Tecnologia.Common.TransitoryData)">
            <summary>
            Recupera uma instância da entidade.
            </summary>
            <param name="criteria">Critério de seleção que identifique o registro.</param>
            <param name="getMode">GetMode para buscar a entidade com o estado já alterado.</param>
            <param name="transitoryData">Dados que são passados entre camadas.</param>
            <returns>Caso a condição retorne uma ou mais entidades este método retornará a primeira entidade, 
            caso não haja entidades que cumpram esta condição será retornado nulo.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.GetMany(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém várias instâncias de entidade da origem de dados.
            </summary>
            <overloads>
            Obtém, da origem de dados, várias instâncias da entidade.
            </overloads>
            <param name="criteria">O critério para recuperar a coleção de instâncias da entidade.</param>
            <returns>
            Uma coleção com as instâncias da entidade requisitada.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.GetMany(Benner.Tecnologia.Common.Criteria,Benner.Tecnologia.Common.TransitoryData)">
            <summary>
            Obtém várias instâncias de entidade da origem de dados.
            </summary>
            <param name="criteria">O critério para recuperar a coleção de instâncias da entidade.</param>
            <param name="transitoryData">Dicionário contendo os dados transitórios.</param>
            <returns>
            Uma coleção com as instâncias da entidade requisitada.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.CountAll">
            <summary>
            Conta todas as instâncias de uma entidade da origem de dados.
            </summary>
            <overloads>
            Conta todas as instâncias da entidade na origem de dados.
            </overloads>
            <returns>A quantidade de instâncias da entidade existentes na origem de dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.CountAll(Benner.Tecnologia.Common.TransitoryData)">
            <summary>
            Conta todas as instâncias de uma entidade da origem de dados.
            </summary>
            <param name="transitoryData">Dicionário contendo dos dados transitórios.</param>
            <returns>A quantidade de instâncias da entidade existentes na origem de dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.CountMany(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Conta as instâncias de uma entidade da origem de dados que atendem a um determinado critério de seleção.
            </summary>
            <overloads>
            Conta, na origem de dados, as instâncias de uma entidade que atendam a um determinado critério de seleção.
            </overloads>
            <param name="criteria">O critério para contar as instâncias da entidade.</param>
            <returns>A quantidade de instâncias da entidade existentes na origem de dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.CountMany(Benner.Tecnologia.Common.Criteria,Benner.Tecnologia.Common.TransitoryData)">
            <summary>
            Conta as instâncias de uma entidade da origem de dados que atendem a um determinado critério de seleção.
            </summary>
            <param name="criteria">O critério para contar as instâncias da entidade.</param>
            <param name="transitoryData">Dicionário contendo dos dados transitórios.</param>
            <returns>A quantidade de instâncias da entidade existentes na origem de dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.DeleteMany(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Exclui as instâncias de uma entidade da origem de dados que atendem a um determinado critério de seleção.
            </summary>
            <overloads>
            Exclui, da origem de dados, as instâncias de uma entidade que atendam a um determinado critério de seleção.
            </overloads>
            <param name="criteria">O critério para excluir as instâncias da entidade.</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.DeleteMany(Benner.Tecnologia.Common.Criteria,Benner.Tecnologia.Common.TransitoryData)">
            <summary>
            Exclui as instâncias de uma entidade da origem de dados que atendem a um determinado critério de seleção.
            </summary>
            <param name="criteria">O critério para excluir as instâncias da entidade.</param>
            <param name="transitoryData">Dicionário contendo dos dados transitórios.</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Exists(Benner.Tecnologia.Common.Handle)">
            <summary>
            Verifica se existe um objeto pela sua chave primária.
            </summary>
            <overloads>
            Verifica a existência de uma entidade pela sua chave primária.
            </overloads>
            <param name="handle">Chave primária do objeto a ser verificado.</param>
            <returns>true se existir um objeto com esta chave na base de dados, false se não existir.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Exists(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Verifica se existe ao menos um objeto.
            </summary>
            <param name="criteria">Critérios de seleção para a pesquisa.</param>
            <returns>true se existir ao menos um objeto na base de dados que atenda aos critérios, false se não existir.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Exists(Benner.Tecnologia.Common.Criteria,Benner.Tecnologia.Common.TransitoryData)">
            <summary>
            Verifica se existe ao menos um objeto.
            </summary>
            <param name="criteria">Critérios de seleção para a pesquisa.</param>
            <param name="transitoryData">Dicionário contendo os dados transitórios.</param>
            <returns>true se existir ao menos um objeto na base de dados que atenda aos critérios, false se não existir.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.GetHandle(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém o Handle de uma determinada entidade com base em um critério de seleção.
            </summary>
            <param name="criteria">Critério de seleção para obter o Handle.</param>
            <returns>Handle da entidade encontrada com base no critério de seleção.</returns>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.HandleNotFoundException">Lança uma HandleNotFoundException se não encontrar um Handle com base no critério de seleção informado.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.TooManyRowsException">Lança uma TooManyRowsException se encontrar mais de um Handle com base no critério de seleção informado.</exception>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.DoEdit">
            <summary>
            Método disparado pelo framework para colocar a entidade em edição
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.Edit">
            <summary>
            Coloca em estado de edição uma entidade obtida em modo de leitura.
            </summary>
            <remarks>
            Este método pode ser invocado pelos consumidores da classe ou por métodos da própria classe. 
            Quando executado, põe a entidade em modo de edição, executando a regra de negócio relativa a esta operação. 
            Classes herdadas de BusinessEntity não devem sobrescrever este método. 
            Para a escrita de regra de negócio, devem ser sobrescritos os métodos "Editing" e "Edited".
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.GetAll(Benner.Tecnologia.Common.GetMode)">
            <summary>
            Obtém todas as instâncias de uma entidade da origem de dados.
            </summary>
            <param name="mode">Modo de recuperação da entidade, determinando seu estado após ser obtida.</param>
            <returns>Uma coleção com as instâncias da entidade requisitada.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.GetAll(Benner.Tecnologia.Common.GetMode,Benner.Tecnologia.Common.TransitoryData)">
            <summary>
            Obtém todas as instâncias de uma entidade da origem de dados.
            </summary>
            <param name="transitoryData">Dicionário contendo os dados transitórios.</param>
            <param name="mode">Modo de recuperação da entidade, determinando seu estado após ser obtida.</param>
            <returns>Uma coleção com as instâncias da entidade requisitada.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.GetMany(Benner.Tecnologia.Common.Criteria,Benner.Tecnologia.Common.GetMode)">
            <summary>
            Obtém várias instâncias de entidade da origem de dados.
            </summary>
            <param name="criteria">O critério para recuperar a coleção de instâncias da entidade.</param>
            <param name="mode">Modo de recuperação da entidade, determinando seu estado após ser obtida.</param>
            <returns>
            Uma coleção com as instâncias da entidade requisitada.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.GetMany(Benner.Tecnologia.Common.Criteria,Benner.Tecnologia.Common.GetMode,Benner.Tecnologia.Common.TransitoryData)">
            <summary>
            Obtém várias instâncias de entidade da origem de dados.
            </summary>
            <param name="criteria">O critério para recuperar a coleção de instâncias da entidade.</param>
            <param name="transitoryData">Dicionário contendo os dados transitórios.</param>
            <param name="mode">Modo de recuperação da entidade, determinando seu estado após ser obtida.</param>
            <returns>
            Uma coleção com as instâncias da entidade requisitada.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.FetchMany(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém várias instâncias de entidade da origem de dados. Retorna um IEnumerable&lt;T&gt;, possibilitando carregamento sob demanda das entidades.
            </summary>
            <param name="criteria">O critério para recuperar a coleção de instâncias da entidade.</param>
            <returns>Um IEnumerable para percorrer as instâncias das entidades</returns>
            <remarks>
            Ao contrário do método GetMany, o método FetchMany permite ler entidades sob-demanda, carregando uma de cada vez evitando consumo excessivo de memória.
            
            Ao utilizar este método deve-se utilizar preferênciamente o foreach. 
            Se for utilizar o IEnumerable explicitamente é impressíndível que o Dispose seja chamado, caso contrário corre-se o risco de deixar um cursor aberto no banco de dados.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.FetchMany(Benner.Tecnologia.Common.Criteria,Benner.Tecnologia.Common.GetMode)">
            <summary>
            Obtém várias instâncias de entidade da origem de dados. Retorna um IEnumerable&lt;T&gt;, possibilitando carregamento sob demanda das entidades.
            </summary>
            <param name="criteria">O critério para recuperar a coleção de instâncias da entidade.</param>
            <param name="mode">Modo de recuperação da entidade, determinando seu estado após ser obtida.</param>
            <returns>Um IEnumerable para percorrer as instâncias das entidades</returns>
            <remarks>
            Ao contrário do método GetMany, o método FetchMany permite ler entidades sob-demanda, carregando uma de cada vez evitando consumo excessivo de memória.
            
            Ao utilizar este método deve-se utilizar preferênciamente o foreach. 
            Se for utilizar o IEnumerable explicitamente é impressíndível que o Dispose seja chamado, caso contrário corre-se o risco de deixar um cursor aberto no banco de dados.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.FetchMany(Benner.Tecnologia.Common.Criteria,Benner.Tecnologia.Common.TransitoryData)">
            <summary>
            Obtém várias instâncias de entidade da origem de dados. Retorna um IEnumerable&lt;T&gt;, possibilitando carregamento sob demanda das entidades.
            </summary>
            <param name="criteria">O critério para recuperar a coleção de instâncias da entidade.</param>
            <param name="transitoryData">Dicionário contendo os dados transitórios.</param>
            <returns>Um IEnumerable para percorrer as instâncias das entidades</returns>
            <remarks>
            Ao contrário do método GetMany, o método FetchMany permite ler entidades sob-demanda, carregando uma de cada vez evitando consumo excessivo de memória.
            
            Ao utilizar este método deve-se utilizar preferênciamente o foreach. 
            Se for utilizar o IEnumerable explicitamente é impressíndível que o Dispose seja chamado, caso contrário corre-se o risco de deixar um cursor aberto no banco de dados.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntity`1.FetchMany(Benner.Tecnologia.Common.Criteria,Benner.Tecnologia.Common.GetMode,Benner.Tecnologia.Common.TransitoryData)">
            <summary>
            Obtém várias instâncias de entidade da origem de dados. Retorna um IEnumerable&lt;T&gt;, possibilitando carregamento sob demanda das entidades.
            </summary>
            <param name="criteria">O critério para recuperar a coleção de instâncias da entidade.</param>
            <param name="mode">Modo de recuperação da entidade, determinando seu estado após ser obtida.</param>
            <param name="transitoryData">Dicionário contendo os dados transitórios.</param>
            <returns>Um IEnumerable para percorrer as instâncias das entidades</returns>
            <remarks>
            Ao contrário do método GetMany, o método FetchMany permite ler entidades sob-demanda, carregando uma de cada vez evitando consumo excessivo de memória.
            
            Ao utilizar este método deve-se utilizar preferênciamente o foreach. 
            Se for utilizar o IEnumerable explicitamente é impressíndível que o Dispose seja chamado, caso contrário corre-se o risco de deixar um cursor aberto no banco de dados.
            </remarks>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessObject.LogicEngine.EntityDocuments`1">
            <summary>
            Gerenciamento de documentos da entidade
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessObject.LogicEngine.BusinessLogicEngine`1">
            <summary>
            Motor de regra de negócio para entidades que executam na BusinessLayer (Runner/Provider)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessObject.LogicEngine.EntityDefaultValues`1">
            <summary>
            Valores padrão dos campos da entidade
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessObject.LogicEngine.LogicEngine`1">
            <summary>
            Motor genérico de regra de negócio da BusinessEntity
            </summary>
            <typeparam name="T">Tipo da entidade de negócio</typeparam>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessObject.LogicEngine.LogicControl">
            <summary>
            Executa a regra passada e garante a execução das regras de negócio base
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessObject.LogicEngine.LogicControl.ExecuteBusinessLogic(Benner.Tecnologia.Business.IBusinessEntity,System.Action)">
            <summary>
            Executa a regra de negócio
            </summary>
            <param name="entity">Entidade na qual a regra irá executar</param>
            <param name="action">Regra de negócio</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessObject.LogicEngine.LogicControl.SetBaseLogicExecuted">
            <summary>
            Avisa que todas as regras base foram executadas
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessObject.LogicEngine.LogicEngineFactory">
            <summary>
            Factory do motor de regra de negócio. Leva em conta o contexto para decidir qual motor irá utilizar
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessObject.LogicEngine.LogicEngineFactory.CreateEngine``1(``0)">
            <summary>
            Cria um motor de regra de negócio conforme o contexto da BusinessEntity
            </summary>
            <param name="entity">Entidade de negócio</param>
            <returns>Motor de regra de negócio</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessObject.LogicEngine.PresentationLogicEngine`1">
            <summary>
            Motor de regra de negócio para entidades de camada de apresentação 
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessObject.LogicEngine.SegregatedPresentationLogicEngine`1">
            <summary>
            Motor de regra de negócio para entidades de camada de apresentação segregada (Onde há uma DLL exclusiva para camada de apresentação)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessObject.LogicEngine.SilverlightLogicEngine`1">
            <summary>
            Motor de regra de negócio para entidades de negócio que rodam no Silverlight
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessObject.LogicEngine.VoidLogicEngine`1">
            <summary>
            Motor de regra de negócio utilizado em entidades que não devem rodar regra de negócio (ScriptUI, Entidade de primeiro nível do Runner/Provider, Entidade parcial)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessObject.LogicEngine.EntityValidation">
            <summary>
            Faz a validação da entidade
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.BusinessObject.LogicEngine.EntityValidation.SkipNativeValidation">
            <summary>
            Se deve ignorar a validação nativa (definições do Builder) 
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessObject.LogicEngine.EntityValidation.#ctor(Benner.Tecnologia.Common.Services.IAdministrationService,Benner.Tecnologia.Common.EntityBase)">
            <summary>
            Instância de EntityValidation para validar a entidade
            </summary>
            <param name="administrationService">Serviço de administração da arquitetura.</param>
            <param name="entity">Entidade que será validada</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessObject.LogicEngine.EntityValidation.ValidateAndThrowOnError">
            <summary>
            Valida completamente a entidade (Definições no Builder, filial e método virtual Validate)). Em caso de erros de validação lança EntityValidationException.
            </summary>
            <remarks>
            Em caso de erros de validação, lança uma EntityValidationException com detalhes do erro.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessObject.LogicEngine.EntityValidation.Validate(Microsoft.Practices.EnterpriseLibrary.Validation.ValidationResults)">
            <summary>
            Valida completamente a entidade (Definições no Builder, filial e método virtual Validate). Em caso de erros de validação não lança exception.
            </summary>
            <param name="validationResults">Coleção de resultados de validação que será preenchida com os problemas de validação</param>
            <remarks>
            Em caso de erros de validação, não é lançada nenhuma exception, apenas a coleção validationResults será preenchida com os erros.
            </remarks>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessObject.LogicEngine.NativeValidation">
            <summary>
            Validações de campos conforme regras definidas no Benner Builder
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessObject.LogicEngine.NativeValidation.#ctor(Benner.Tecnologia.Common.EntityBase)">
            <summary>
            Construtor do NativeValidation, para fazer validações definidas no Builder
            </summary>
            <param name="entity"></param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessObject.LogicEngine.NativeValidation.Validate(Microsoft.Practices.EnterpriseLibrary.Validation.ValidationResults)">
            <summary>
            Validação Nativa da Entidade conforme definição do Builder.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessObject.LogicEngine.NativeValidation.PrepareCheckFieldsRequired">
            <summary>
            Percorre a lista auxiliar com os campos a serem validados e seta o required conforme definição do Builder e visibilidades nas TABs.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessObject.LogicEngine.NativeValidation.FillListFieldsForValidation">
            <summary>
            "Alimenta" a lista auxiliar com os campos a serem validados.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessObject.LogicEngine.NativeValidation.AddListFieldForValidation(Benner.Tecnologia.Common.LayoutItemDefinition,System.String)">
            <summary>
            Adiciona na lista os campos que serão validados.
            IMPORTANTE: Required está sendo atribuído fixo como false, 
                        pois depois este valor será alterado como tab selecionada e obrigatoriedade do Builder
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessObject.LogicEngine.NativeValidation.InternalMapFieldsForValidation(Benner.Tecnologia.Common.LayoutItemDefinition,System.String)">
            <summary>
            Mapeando tipo de campo para validação.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessObject.LogicEngine.NativeValidation.InternalMapFieldInLayoutPageDefinion(Benner.Tecnologia.Common.LayoutPageDefinition,System.String)">
            <summary>
            Percorrer / Trata campos tipo TAB e/ou TAB não ligada a dados)
            </summary>
            <param name="layoutPage">Campo tab a ser percorrido.</param>
            <param name="immediateParent">Ancestral imediato do "layoutPage".</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessObject.LogicEngine.NativeValidation.InternalMapFieldInLayoutGroupDefinion(Benner.Tecnologia.Common.LayoutGroupDefinition)">
            <summary>
            Trata campos do tipo GRUPO - LayoutGroupDefinion
            </summary>
            <param name="layoutGroup">Campo tipo GRUPO a ser percorrido.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessObject.LogicEngine.NativeValidation.InternalMapFieldInLayoutTabFieldDefinion(Benner.Tecnologia.Common.LayoutTabFieldDefinition)">
            <summary>
            Trata campos do tipo TAB - LayoutTabFieldDefinion
            </summary>
            <param name="layoutTabField">Campo tipo TAB a ser percorrido.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessObject.LogicEngine.NativeValidation.InternalMapParentFields">
            <summary>
            Atribui os parent fisicos para os devidos campos.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessObject.LogicEngine.NativeValidation.InternalGetFieldParent(Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation)">
            <summary>
            Identifica o ancestral de um campo.
            </summary>
            <param name="field">Campo tipo TAB (não ligado a dados) a ser percorrido.</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessArgs">
            <summary>
            Representa os argumentos para execução de um método de uma entidade de negócio.
            </summary>
            <remarks>
            Os métodos invocados pela interface gráfica recebem uma instância desta classe como parâmetro. 
            O método pode, então, obter deste objeto os argumentos para sua execução. 
            O resultado da execução do método também pode ser informado neste objeto.
            </remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.BusinessArgs.Message">
            <summary>
            Mensagem que descreve para o usuário o resultado da execução do método.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.BusinessArgs.DataEntity">
            <summary>
            Entidade que fornece informações adicionais para execução do método.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.BusinessArgs.TransitoryVars">
            <summary>
            Dicionário de dados que fornece informações adicionais para execução do método, 
            podendo também receber informações que serão retornadas para o chamador.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.BusinessArgs.SelectedEntitiesHandles">
            <summary>
            Coleção dos handles das entidades selecionadas
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.BusinessArgs.Request">
            <summary>
            Objetos de request de um serviço de negócio
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.BusinessArgs.Response">
            <summary>
            Objetos de response de um serviço de negócio
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessComponent`1">
            <summary>
            Classe abstrata para o desenvolvimento de componentes de negócio
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessComponent`1.CreateInstance">
            <summary>
            Cria uma instância do componente de negócio respeitando a customização por camadas de desenvolvimento
            </summary>
            <returns>Instância do componente de negócio</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessEntityDao`2">
            <summary>
            DAO para BusinessEntity
            </summary>
            <summary>
            DAO para BusinessEntity
            </summary>
            <typeparam name="T">Classe concreta da BusinessEntity</typeparam>
            <typeparam name="U">Interface da BusinessEntity</typeparam>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.Create">
            <summary>
            Cria uma nova instância inicializada da entidade.
            </summary>
            <returns>Uma nova instância inicializada da entidade.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.Create(Benner.Tecnologia.Common.NameValueDictionary)">
            <summary>
            Cria uma nova instância da entidade.
            </summary>
            <param name="suggestedValues">Dicionário contendo valores sugeridos, que a nova instância de entidade irá assumir.</param>
            <returns>Uma nova entidade.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.CreateClone(Benner.Tecnologia.Common.Handle)">
            <summary>
            Cria uma nova instância da entidade copiando os valores das propriedades de uma entidade modelo.
            A entidade modelo será obtida através do Handle informado.
            </summary>
            <param name="handle">Handle da entidade modelo que será obtida e terá os valores das propriedades copiados para a nova entidade.</param>
            <returns>Uma nova entidade.</returns>
            <remarks>A entidade será retornada em modo de inserção.</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.CreateClone(`1)">
            <summary>
            Cria uma nova instância da entidade copiando os valores das propriedades de uma entidade modelo.
            </summary>
            <param name="sourceEntity">Entidade modelo que terá os valores das propriedades copiados para a nova entidade.</param>
            <returns>Uma nova entidade. </returns>
            <remarks>A entidade será retornada em modo de inserção.</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.DeleteMany(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Exclui as instâncias de uma entidade da origem de dados que atendem a um determinado critério de seleção.
            </summary>
            <param name="criteria">O critério para excluir as instâncias da entidade.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.Save(`1)">
            <summary>
            Salva a entidade na base de dados
            </summary>
            <param name="entity">Instância da entidade</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.Delete(`1)">
            <summary>
            Exclui a entidade da base de dados
            </summary>
            <param name="entity">Instância da entidade</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.FetchMany(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém várias instâncias de entidade da origem de dados. Retorna um IEnumerable&lt;T&gt;, possibilitando carregamento sob demanda das entidades.
            </summary>
            <param name="criteria">O critério para recuperar a coleção de instâncias da entidade.</param>
            <returns>Um IEnumerable para percorrer as instâncias das entidades</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.GetMany(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e obtém várias instâncias de entidade da origem de dados.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <returns>
            Uma coleção com as instâncias da entidade requisitada.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.GetMany(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}},Benner.Tecnologia.Common.Criteria)">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e obtém várias instâncias de entidade da origem de dados.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <param name="criteria">A criteria utilizada para executar a consulta</param>
            <returns>
            Uma coleção com as instâncias da entidade requisitada.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.Get(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e obtém uma instância da entidade em modo de leitura.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.Get(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}},Benner.Tecnologia.Common.Criteria)">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e obtém uma instância da entidade em modo de leitura.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <param name="criteria">A criteria utilizada para executar a consulta</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.Exists(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e verifica se existe ao menos um objeto.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <returns>True se existir ao menos um objeto na base de dados que atenda aos critérios, false se não existir.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.Exists(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}},Benner.Tecnologia.Common.Criteria)">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e verifica se existe ao menos um objeto.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <param name="criteria">A criteria utilizada para executar a consulta</param>
            <returns>True se existir ao menos um objeto na base de dados que atenda aos critérios, false se não existir.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.GetFirstOrDefault(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e recupera uma instância da entidade.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <returns>Caso a condição retorne uma ou mais entidades este método retornará a primeira entidade, 
            caso não haja entidades que cumpram esta condição será retornado nulo.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.GetFirstOrDefault(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}},Benner.Tecnologia.Common.Criteria)">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e recupera uma instância da entidade.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <param name="criteria">A criteria utilizada para executar a consulta</param>
            <returns>Caso a condição retorne uma ou mais entidades este método retornará a primeira entidade, 
            caso não haja entidades que cumpram esta condição será retornado nulo.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.GetHandle(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e obtém o Handle de uma determinada entidade com base em um critério de seleção.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <returns>Handle da entidade encontrada com base no critério de seleção.</returns>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.HandleNotFoundException">Lança uma HandleNotFoundException se não encontrar um Handle com base no critério de seleção informado.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.TooManyRowsException">Lança uma TooManyRowsException se encontrar mais de um Handle com base no critério de seleção informado.</exception>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.GetHandle(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}},Benner.Tecnologia.Common.Criteria)">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e obtém o Handle de uma determinada entidade com base em um critério de seleção.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <param name="criteria">A criteria utilizada para executar a consulta</param>
            <returns>Handle da entidade encontrada com base no critério de seleção.</returns>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.HandleNotFoundException">Lança uma HandleNotFoundException se não encontrar um Handle com base no critério de seleção informado.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.TooManyRowsException">Lança uma TooManyRowsException se encontrar mais de um Handle com base no critério de seleção informado.</exception>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.GetForEdit(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}},Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém uma instância da entidade em modo de edição a partir de uma definição de entidade.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <param name="criteria">Critério de seleção que identifique um único registro.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.GetForEdit(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Obtém uma instância da entidade em modo de edição a partir de uma definição de entidade.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.DeleteMany(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e exclui as instâncias de uma entidade da origem de dados que atendem a um determinado critério de seleção.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.DeleteMany(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}},Benner.Tecnologia.Common.Criteria)">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e exclui as instâncias de uma entidade da origem de dados que atendem a um determinado critério de seleção.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <param name="criteria">A criteria utilizada para executar a consulta</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.FetchMany(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Obtém várias instâncias de entidade da origem de dados. Retorna um IEnumerable&lt;T&gt;, possibilitando carregamento sob demanda das entidades.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <returns>Um IEnumerable para percorrer as instâncias das entidades</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.FetchMany(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}},Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém várias instâncias de entidade da origem de dados. Retorna um IEnumerable&lt;T&gt;, possibilitando carregamento sob demanda das entidades.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <param name="criteria">A criteria utilizada para executar a consulta</param>
            <returns>Um IEnumerable para percorrer as instâncias das entidades</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.GetTransitoryData(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Converte a expressão do tipo genérico para o tipo concreto e cria uma TransitoryData preenchendo com a expressão criada.
            </summary>
            <param name="expression">A Expressão para realizar o filtro com tipo genérico</param>
            <returns>Retorna a <see cref="T:Benner.Tecnologia.Common.TransitoryData"/> com a expressão preenchida </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.CountMany(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e
            conta as instâncias de uma entidade da origem de dados que atendem a um determinado critério de seleção
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <returns> 
            A quantidade de instâncias da entidade existentes na origem de dados.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.#ctor">
            <summary>
            Instancia o DAO utilizando a definição declarada no atributo EntityDefinitionName de T
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.#ctor(Benner.Tecnologia.Common.EntityDefinition)">
            <summary>
            Instancia o DAO com uma definição passada como parâmetro
            </summary>
            <param name="definition">Definição de entidade</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.CreateInstance``1">
            <summary>
            Cria uma instância do DAO da entidade.
            </summary>
            <typeparam name="V">Tipo do DAO a ser instanciado.</typeparam>
            <returns>Implementação mais específica do DAO da entidade.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.Exists(Benner.Tecnologia.Common.Handle)">
            <summary>
            Verifica se existe um objeto pela sua chave primária.
            </summary>
            <param name="handle">Chave primária do objeto a ser verificado.</param>
            <returns>true se existir um objeto com esta chave na base de dados, false se não existir.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.Exists(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Verifica se existe ao menos um objeto.
            </summary>
            <param name="criteria">Critérios de seleção para a pesquisa.</param>
            <returns>true se existir ao menos um objeto na base de dados que atenda aos critérios, false se não existir.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.GetMany(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém várias instâncias de entidade da origem de dados. 
            </summary>
            <param name="criteria">O critério para recuperar a coleção de instâncias da entidade.</param>
            <returns>Um IList com todas as entidades</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.Get(Benner.Tecnologia.Common.Handle)">
            <summary>
            Obtém uma instância da entidade em modo de leitura.
            </summary>
            <param name="handle">Chave primária.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.GetForEdit(Benner.Tecnologia.Common.Handle)">
            <summary>
            Obtém uma instância da entidade em modo de edição.
            </summary>
            <param name="handle">Chave primária.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.Get(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém uma instância da entidade em modo de leitura.
            </summary>
            <param name="criteria">Critério de seleção que identifique um único registro.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.GetForEdit(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém uma instância da entidade em modo de edição.
            </summary>
            <param name="criteria">Critério de seleção que identifique um único registro.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.Get(Benner.Tecnologia.Common.EntityDefinition,Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém uma instância da entidade em modo de leitura a partir de uma definição de entidade.
            </summary>
            <param name="entityDefinition">Definição de entidade a ser obtida.</param>
            <param name="criteria">Critério de seleção que identifique um único registro.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.GetForEdit(Benner.Tecnologia.Common.EntityDefinition,Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém uma instância da entidade em modo de edição a partir de uma definição de entidade.
            </summary>
            <param name="entityDefinition">Definição de entidade a ser obtida.</param>
            <param name="criteria">Critério de seleção que identifique um único registro.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.GetFirstOrDefault(Benner.Tecnologia.Common.Handle)">
            <summary>
            Recupera uma instância da entidade em modo leitura.
            </summary>
            <param name="handle">Handle para recuperar a entidade.</param>
            <returns>Caso a condição retorne uma ou mais entidades este método retornará a primeira entidade, 
            caso não haja entidades que cumpram esta condição será retornado nulo.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.GetFirstOrDefault(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Recupera uma instância da entidade em modo leitura.
            </summary>
            <param name="criteria">Critério de seleção que identifique o registro.</param>
            <returns>Caso a condição retorne uma ou mais entidades este método retornará a primeira entidade, 
            caso não haja entidades que cumpram esta condição será retornado nulo.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.GetHandle(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém o Handle de uma determinada entidade com base em um critério de seleção.
            </summary>
            <param name="criteria">Critério de seleção para obter o Handle.</param>
            <returns>Handle da entidade encontrada com base no critério de seleção.</returns>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.HandleNotFoundException">Lança uma HandleNotFoundException se não encontrar um Handle com base no critério de seleção informado.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.TooManyRowsException">Lança uma TooManyRowsException se encontrar mais de um Handle com base no critério de seleção informado.</exception>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDao`2.CountMany(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Conta as instâncias de uma entidade da origem de dados que atendem a um determinado critério de seleção.
            </summary>
            <param name="criteria">O critério para contar as instâncias da entidade.</param>
            <returns>A quantidade de instâncias da entidade existentes na origem de dados.</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.IBusinessOperationInvoker">
            <summary>
            Permite invocar as regras de negócio programadas na entidade (Saved, Saving, etc)
            Estas operações não estão disponíveis no Silverlight
            </summary>
            <summary>
            Permite invocar as regras de negócio programadas na entidade (Saved, Saving, etc)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.EntityDefinitionNameAttribute">
            
            <summary>
            Define o nome da definição da entidade representada por um objeto de negócio.
            </summary>
            <remarks>
            Utilize este atributo para identificar, em uma classe que especializa uma entidade, qual entidade se está especializando.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.EntityDefinitionNameAttribute.#ctor(System.String)">
            <summary>
            Define o nome da definição da entidade representada por um objeto de negócio.
            </summary>
            <param name="entityDefinitionName">Nome da definição da entidade que será representada pelo objeto de negócio.</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.IBusinessEntity">
            <summary>
            Define a interface de uma entidade de negócio.
            </summary>
            <summary>
            Define a interface de uma entidade de negócio.
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.IBusinessEntityDao`1">
            <summary>
            Comportamentos do Dao para BusinessEntity
            </summary>
            <summary>
            Comportamentos do Dao para BusinessEntity
            </summary>
            <typeparam name="U">Interface da BusinessEntity</typeparam>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.Create">
            <summary>
            Cria uma nova instância inicializada da entidade.
            </summary>
            <returns>Uma nova instância inicializada da entidade.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.Create(Benner.Tecnologia.Common.NameValueDictionary)">
            <summary>
            Cria uma nova instância da entidade.
            </summary>
            <param name="suggestedValues">Dicionário contendo valores sugeridos, que a nova instância de entidade irá assumir.</param>
            <returns>Uma nova entidade.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.CreateClone(Benner.Tecnologia.Common.Handle)">
            <summary>
            Cria uma nova instância da entidade copiando os valores das propriedades de uma entidade modelo.
            A entidade modelo será obtida através do Handle informado.
            </summary>
            <param name="handle">Handle da entidade modelo que será obtida e terá os valores das propriedades copiados para a nova entidade.</param>
            <returns>Uma nova entidade.</returns>
            <remarks>A entidade será retornada em modo de inserção.</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.CreateClone(`0)">
            <summary>
            Cria uma nova instância da entidade copiando os valores das propriedades de uma entidade modelo.
            </summary>
            <param name="sourceEntity">Entidade modelo que terá os valores das propriedades copiados para a nova entidade.</param>
            <returns>Uma nova entidade. </returns>
            <remarks>A entidade será retornada em modo de inserção.</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.DeleteMany(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Exclui as instâncias de uma entidade da origem de dados que atendem a um determinado critério de seleção.
            </summary>
            <param name="criteria">O critério para excluir as instâncias da entidade.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.Save(`0)">
            <summary>
            Salva a entidade na base de dados
            </summary>
            <param name="entity">Instância da entidade</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.Delete(`0)">
            <summary>
            Exclui a entidade da base de dados
            </summary>
            <param name="entity">Instância da entidade</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.FetchMany(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém várias instâncias de entidade da origem de dados. Retorna um IEnumerable&lt;T&gt;, possibilitando carregamento sob demanda das entidades.
            </summary>
            <param name="criteria">O critério para recuperar a coleção de instâncias da entidade.</param>
            <returns>Um IEnumerable para percorrer as instâncias das entidades</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.GetMany(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e obtém várias instâncias de entidade da origem de dados.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <returns>
            Uma coleção com as instâncias da entidade requisitada.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.GetMany(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},Benner.Tecnologia.Common.Criteria)">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e obtém várias instâncias de entidade da origem de dados.
            Poderá ser configurado <see cref="T:Benner.Tecnologia.Common.Criteria"/> e caso seja adicionado alguma cláusula WHERE, será adicionada com a condição AND da tradução da expressão.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <param name="criteria">A criteria utilizada para executar a consulta</param>
            <returns>
            Uma coleção com as instâncias da entidade requisitada.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.Get(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e obtém uma instância da entidade em modo de leitura.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.Get(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},Benner.Tecnologia.Common.Criteria)">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e obtém uma instância da entidade em modo de leitura.
            Poderá ser configurado <see cref="T:Benner.Tecnologia.Common.Criteria"/> e caso seja adicionado alguma cláusula WHERE, será adicionada com a condição AND da tradução da expressão.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <param name="criteria">A criteria utilizada para executar a consulta</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.Exists(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e verifica se existe ao menos um objeto.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <returns>True se existir ao menos um objeto na base de dados que atenda aos critérios, false se não existir.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.Exists(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},Benner.Tecnologia.Common.Criteria)">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e verifica se existe ao menos um objeto.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <param name="criteria">A criteria utilizada para executar a consulta</param>
            <returns>True se existir ao menos um objeto na base de dados que atenda aos critérios, false se não existir.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.GetFirstOrDefault(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e recupera uma instância da entidade.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <returns>Caso a condição retorne uma ou mais entidades este método retornará a primeira entidade, 
            caso não haja entidades que cumpram esta condição será retornado nulo.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.GetFirstOrDefault(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},Benner.Tecnologia.Common.Criteria)">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e recupera uma instância da entidade.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <param name="criteria">A criteria utilizada para executar a consulta</param>
            <returns>Caso a condição retorne uma ou mais entidades este método retornará a primeira entidade, 
            caso não haja entidades que cumpram esta condição será retornado nulo.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.GetHandle(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Obtém o Handle de uma determinada entidade com base em um critério de seleção.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <returns>Handle da entidade encontrada com base no critério de seleção.</returns>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.HandleNotFoundException">Lança uma HandleNotFoundException se não encontrar um Handle com base no critério de seleção informado.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.TooManyRowsException">Lança uma TooManyRowsException se encontrar mais de um Handle com base no critério de seleção informado.</exception>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.GetHandle(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém o Handle de uma determinada entidade com base em um critério de seleção.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <param name="criteria">A criteria utilizada para executar a consulta</param>
            <returns>Handle da entidade encontrada com base no critério de seleção.</returns>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.HandleNotFoundException">Lança uma HandleNotFoundException se não encontrar um Handle com base no critério de seleção informado.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.TooManyRowsException">Lança uma TooManyRowsException se encontrar mais de um Handle com base no critério de seleção informado.</exception>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.GetForEdit(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém uma instância da entidade em modo de edição a partir de uma definição de entidade.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <param name="criteria">Critério de seleção que identifique um único registro.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.GetForEdit(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Obtém uma instância da entidade em modo de edição a partir de uma definição de entidade.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.DeleteMany(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e exclui as instâncias de uma entidade da origem de dados que atendem a um determinado critério de seleção.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.DeleteMany(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},Benner.Tecnologia.Common.Criteria)">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e exclui as instâncias de uma entidade da origem de dados que atendem a um determinado critério de seleção.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <param name="criteria">A criteria utilizada para executar a consulta</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.FetchMany(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Obtém várias instâncias de entidade da origem de dados. Retorna um IEnumerable&lt;T&gt;, possibilitando carregamento sob demanda das entidades.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <returns>Um IEnumerable para percorrer as instâncias das entidades</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.FetchMany(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém várias instâncias de entidade da origem de dados. Retorna um IEnumerable&lt;T&gt;, possibilitando carregamento sob demanda das entidades.
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <param name="criteria">A criteria utilizada para executar a consulta</param>
            <returns>Um IEnumerable para percorrer as instâncias das entidades</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.CountMany(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Traduz a expressão lambda para um <see cref="T:Benner.Tecnologia.Common.Criteria"/> e
            conta as instâncias de uma entidade da origem de dados que atendem a um determinado critério de seleção
            </summary>
            <param name="expression">A expressão lambda que será traduzida.</param>
            <returns> 
            A quantidade de instâncias da entidade existentes na origem de dados.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.Exists(Benner.Tecnologia.Common.Handle)">
            <summary>
            Verifica se existe um objeto pela sua chave primária.
            </summary>
            <param name="handle">Chave primária do objeto a ser verificado.</param>
            <returns>true se existir um objeto com esta chave na base de dados, false se não existir.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.Exists(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Verifica se existe ao menos um objeto.
            </summary>
            <param name="criteria">Critérios de seleção para a pesquisa.</param>
            <returns>true se existir ao menos um objeto na base de dados que atenda aos critérios, false se não existir.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.GetMany(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém várias instâncias de entidade da origem de dados. 
            </summary>
            <param name="criteria">O critério para recuperar a coleção de instâncias da entidade.</param>
            <returns>Um IList com todas as entidades</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.Get(Benner.Tecnologia.Common.Handle)">
            <summary>
            Obtém uma instância da entidade em modo de leitura.
            </summary>
            <param name="handle">Chave primária.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.GetForEdit(Benner.Tecnologia.Common.Handle)">
            <summary>
            Obtém uma instância da entidade em modo de edição.
            </summary>
            <param name="handle">Chave primária.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.Get(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém uma instância da entidade em modo de leitura.
            </summary>
            <param name="criteria">Critério de seleção que identifique um único registro.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.GetForEdit(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém uma instância da entidade em modo de edição.
            </summary>
            <param name="criteria">Critério de seleção que identifique um único registro.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.Get(Benner.Tecnologia.Common.EntityDefinition,Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém uma instância da entidade em modo de leitura a partir de uma definição de entidade.
            </summary>
            <param name="entityDefinition">Definição de entidade a ser obtida.</param>
            <param name="criteria">Critério de seleção que identifique um único registro.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.GetForEdit(Benner.Tecnologia.Common.EntityDefinition,Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém uma instância da entidade em modo de edição a partir de uma definição de entidade.
            </summary>
            <param name="entityDefinition">Definição de entidade a ser obtida.</param>
            <param name="criteria">Critério de seleção que identifique um único registro.</param>
            <returns>Uma nova instância da entidade com os dados.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.GetFirstOrDefault(Benner.Tecnologia.Common.Handle)">
            <summary>
            Recupera uma instância da entidade em modo leitura.
            </summary>
            <param name="handle">Handle para recuperar a entidade.</param>
            <returns>Caso a condição retorne uma ou mais entidades este método retornará a primeira entidade, 
            caso não haja entidades que cumpram esta condição será retornado nulo.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.GetFirstOrDefault(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Recupera uma instância da entidade em modo leitura.
            </summary>
            <param name="criteria">Critério de seleção que identifique o registro.</param>
            <returns>Caso a condição retorne uma ou mais entidades este método retornará a primeira entidade, 
            caso não haja entidades que cumpram esta condição será retornado nulo.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.GetHandle(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Obtém o Handle de uma determinada entidade com base em um critério de seleção.
            </summary>
            <param name="criteria">Critério de seleção para obter o Handle.</param>
            <returns>Handle da entidade encontrada com base no critério de seleção.</returns>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.HandleNotFoundException">Lança uma HandleNotFoundException se não encontrar um Handle com base no critério de seleção informado.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.TooManyRowsException">Lança uma TooManyRowsException se encontrar mais de um Handle com base no critério de seleção informado.</exception>
        </member>
        <member name="M:Benner.Tecnologia.Business.IBusinessEntityDao`1.CountMany(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Conta as instâncias de uma entidade da origem de dados que atendem a um determinado critério de seleção.
            </summary>
            <param name="criteria">O critério para contar as instâncias da entidade.</param>
            <returns>A quantidade de instâncias da entidade existentes na origem de dados.</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.IEntityModerator">
            <summary>
            Define a interface de uma classe que fornece interoperabilidade de Entidades entre ambiente gerenciado (.Net) e não gerenciado (Delphi).
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.IEntityModerator.InteroperableEntity">
            <summary>
            Entidade interoperável.
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.SerializableBusinessArgs">
            <summary>
            Encapsula os dados de um <see cref="T:Benner.Tecnologia.Business.BusinessArgs"/> para transporte entre as camadas do aplicativo.
            </summary>
            <remarks>
            Uma instância desta classe é utilizada para reconstituir o <see cref="T:Benner.Tecnologia.Business.BusinessArgs"/> 
            na camada de negócios e transporta dados que não poderiam ser serializados junto com o <see cref="T:Benner.Tecnologia.Business.BusinessArgs"/>, 
            como definições de entidades.
            </remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.SerializableBusinessArgs.Message">
            <summary>
            Mensagem que descreve para o usuário o resultado da execução do método.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SerializableBusinessArgs.DataEntity">
            <summary>
            Entidade que fornece informações adicionais para execução do método.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SerializableBusinessArgs.TransitoryVars">
            <summary>
            Dicionário de dados que fornece informações adicionais para execução do método, 
            podendo também receber informações que serão retornadas para o chamador.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SerializableBusinessArgs.DataEntityDescription">
            <summary>
            Descritor da definição da entidade BusinessArgs.DataEntity.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SerializableBusinessArgs.SelectedEntitiesHandles">
            <summary>
            Coleção dos handles das entidades selecionadas
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SerializableBusinessArgs.RequestXmlContent">
            <summary>
            Request vindo do serviço (documento estruturado) em formato XML
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SerializableBusinessArgs.ResponseXmlContent">
            <summary>
            Request vindo do serviço (documento estruturado) em formato XML
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SerializableBusinessArgs.FunctionContext">
            <summary>
            Contexto da execução do método
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.BennerEnvironment">
            <summary>
            Informações do ambiente Benner atual. Prefira utilizar IBennerEnvironment injetado.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BennerEnvironment.ClearStaticCache">
            <summary>
            Recarrega as informações de ambiente (Se é produção e descrição). Obsoleto. Utilize ReloadEnvironmentInfo.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BennerEnvironment.ReloadEnvironmentInfo">
            <summary>
            Recarrega as informações de ambiente (Se é produção e descrição)
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.BennerEnvironment.IsProduction">
            <summary>
            Retorna true se é ambiente de produção
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.BennerEnvironment.Description">
            <summary>
            Descrição do ambiente
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.BennerEnvironment.IsBenner">
            <summary>
            Retorna true se é um ambiente instalado internamente na Benner e false se for ambiente de cliente
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.BennerEnvironment.IsCustomSystem">
            <summary>
            Retorna true se é um sistema específico
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.BennerEnvironment.IsVerticalSystem">
            <summary>
            Retorna true se é um sistema vertical
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.BennerEnvironment.ServerDate">
            <summary>
            Data atual na camada de negócio (apenas data)
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.BennerEnvironment.ServerDateTime">
            <summary>
            Data e hora atual na camada de negócio
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.BennerEnvironment.DbVersion">
            <summary>
            Versão da base de dados (Versão DB)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.EnvironmentInfo.BennerEnvironmentImplementation">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.EnvironmentInfo.BennerEnvironmentImplementation.ReloadEnvironmentInfo">
            <inheritdoc />
        </member>
        <member name="P:Benner.Tecnologia.Business.EnvironmentInfo.BennerEnvironmentImplementation.IsProduction">
            <inheritdoc />
        </member>
        <member name="P:Benner.Tecnologia.Business.EnvironmentInfo.BennerEnvironmentImplementation.Description">
            <inheritdoc />
        </member>
        <member name="P:Benner.Tecnologia.Business.EnvironmentInfo.BennerEnvironmentImplementation.IsBenner">
            <inheritdoc />
        </member>
        <member name="P:Benner.Tecnologia.Business.EnvironmentInfo.BennerEnvironmentImplementation.IsCustomSystem">
            <inheritdoc />
        </member>
        <member name="P:Benner.Tecnologia.Business.EnvironmentInfo.BennerEnvironmentImplementation.IsVerticalSystem">
            <inheritdoc />
        </member>
        <member name="P:Benner.Tecnologia.Business.EnvironmentInfo.BennerEnvironmentImplementation.ServerDate">
            <inheritdoc />
        </member>
        <member name="P:Benner.Tecnologia.Business.EnvironmentInfo.BennerEnvironmentImplementation.ServerDateTime">
            <inheritdoc />
        </member>
        <member name="P:Benner.Tecnologia.Business.EnvironmentInfo.BennerEnvironmentImplementation.DbVersion">
            <inheritdoc />
        </member>
        <member name="T:Benner.Tecnologia.Business.IMailMessage">
            <summary>
            Mensagem de email
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.IMailMessage.AlternativeBody">
            <summary>
            Corpo alternativo da mensagem em HTML.Normalmente texto puro para clientes que não visualizam HTML.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.IMailMessage.Bcc">
            <summary>
            Cópia oculta. Se houver mais de um separar com ; (ponto e vírgula).
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.IMailMessage.Body">
            <summary>
            Corpo da mensagem.
            Se a propriedade IsBodyHtml estiver informada como true, podem existir instruções HTML no corpo da mensagem.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.IMailMessage.Cc">
            <summary>
            Com cópia para. Se houver mais de um separar com ; (ponto e vírgula).
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.IMailMessage.IsBodyHtml">
            <summary>
            Informe True nesta propriedade se desejar informar um HTML como corpo do e-mail ao invés de informar um texto plano.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.IMailMessage.Priority">
            <summary>
            Prioridade do e-mail
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.IMailMessage.ReplyTo">
            <summary>
            Propriedade para informar o "Reponder para".
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.IMailMessage.RequestReadReceipt">
            <summary>
            Solicita a confirmação de recebimento de leitura do email.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.IMailMessage.SendTo">
            <summary>
            Destinatário da mensagem. Se houver mais de um separar com ; (ponto e vírgula).
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.IMailMessage.Subject">
            <summary>
            Assunto da mensagem.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.IMailMessage.SystemUser">
            <summary>
            Handle do usuário remetente no envio de e-mail
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.IMailMessage.AddAttachment(System.IO.Stream,System.String)">
            <summary>
            Anexa um novo arquivo à mensagem. O conteúdo do arquivo será o stream.
            Se existir mais de um arquivo desses, deve existir um comando AddAttachment para cada arquivo que se deseja anexar.
            </summary>
            <param name="content">Conteúdo do arquivo</param>
            <param name="fileName">
            Nome do arquivo no anexo.
            </param>
        </member>
        <member name="M:Benner.Tecnologia.Business.IMailMessage.AddAttachment(System.String)">
            <summary>
            Anexa arquivos à mensagem. 
            Se existir mais de um arquivo desses, deve existir um comando AddAttachment para cada arquivo que se deseja anexar.
            </summary>
            <param name="fileName">
            Nome do arquivo que deseja anexar.
            O arquivo deve ser informado com o caminho completo. Ex.: c:\benner\arquivo.txt
            </param>
        </member>
        <member name="M:Benner.Tecnologia.Business.IMailMessage.AddLinkedResource(System.IO.Stream,System.String)">
            <summary>
            Adiciona uma imagem embarcada para o envio de email. O HTML <see cref="P:Benner.Tecnologia.Business.IMailMessage.Body"/> deve conter &lt; img src="cid:nomeImagem" /&gt; para referênciar a imagem no corpo do email.
            </summary>
            <param name="content">Conteúdo do arquivo</param>
            <param name="resourceName">
            Nome do arquivo
            </param>
        </member>
        <member name="M:Benner.Tecnologia.Business.IMailMessage.AddLinkedResource(System.String)">
            <summary>
            Adiciona uma imagem embarcada para o envio de email. O HTML <see cref="P:Benner.Tecnologia.Business.IMailMessage.Body"/> deve conter &lt; img src="cid:nomeImagem" /&gt; para referênciar a imagem no corpo do email.
            </summary>
            <param name="fileName">
            Nome do arquivo que deseja anexar.
            O arquivo deve ser informado com o caminho completo. Ex.: c:\benner\arquivo.txt
            </param>
        </member>
        <member name="T:Benner.Tecnologia.Business.MailService">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.MailService.NewMailMessage">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.MailService.NewMailMessage(Benner.Tecnologia.Common.Handle,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.MailService.NewMailMessage(Benner.Tecnologia.Common.Handle,System.String,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.MailService.NewMailMessage(Benner.Tecnologia.Common.Handle,System.String,System.String,System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.MailService.NewMailMessage(Benner.Tecnologia.Common.Handle,System.String,System.String,System.String,System.Boolean,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.MailService.Send(Benner.Tecnologia.Business.IMailMessage)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.MailService.Send(System.String,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.MailService.Send(System.String,System.String,System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.MailService.Send(System.String,System.String,System.String,System.Boolean,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.MailService.Send(Benner.Tecnologia.Common.Handle,System.String,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.MailService.Send(Benner.Tecnologia.Common.Handle,System.String,System.String,System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.MailService.Send(Benner.Tecnologia.Common.Handle,System.String,System.String,System.String,System.Boolean,System.String)">
            <inheritdoc />
        </member>
        <member name="T:Benner.Tecnologia.Business.DataReader.DataReader">
            <summary>
            DataReader para leitura rápida de dados do BEF
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.DataReader.DataReader.CreateDataReaderService">
            <inheritdoc />        
        </member>
        <member name="M:Benner.Tecnologia.Business.DataReader.DataReader.#ctor(System.String,Benner.Tecnologia.Common.ParameterCollection)">
            <summary>
            Instancia um novo DataReader
            </summary>
            <param name="commandText">Comando SQL de consulta que será executado.</param>
            <param name="parameters">Parâmetros da consulta.</param>
        </member>
        <member name="P:Benner.Tecnologia.Business.DataReader.DataReader.FieldCount">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.DataReader.DataReader.GetFieldName(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.DataReader.DataReader.GetDataType(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Benner.Tecnologia.Business.DataReader.DataReader.GetEnumerator">
            <summary>
            Obtém os resultados da consulta.
            </summary>
            <returns>Retorna uma coleção de DataReaderRecord.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.DataReader.DataReader.Finalize">
            <summary>
            Finalizador
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.DataReader.DataReader.Dispose(System.Boolean)">
            <summary>
            Finaliza o DataReader
            </summary>
            <param name="disposing">True se foi chamado diretamente</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.DataReader.DataReader.Dispose">
            <summary>
            Finaliza o DataReader
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.IProcessLog">
            <summary>
            Torna um bloco de código parte de um processo monitorado.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.IProcessLog.Message">
            <summary>
            Mensagem informativa do status do processo.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.IProcessLog.Aborting">
            <summary>
            Verifica se o cancelamento do processo foi solicitado.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.IProcessLog.AbortUser">
            <summary>
            Retorna o nome do Usuário que solicitou o cancelamento do processo.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.IProcessLog.Handle">
            <summary>
            Handle do processo. Pode retornar nulo se ainda não foi executado o Start.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.IProcessLog.Start(System.String,System.Int32,System.Int32)">
            <summary>
            Inicia um novo processo monitorado. Pode ser chamado mais de uma vez para atualizar informações passadas.
            </summary>
            <param name="processLogName">Nome do processo que será mostrado no monitor de processos.</param>
            <param name="startValue">Valor inicial para controle do progresso do processo.</param>
            <param name="endValue">Valor final para controle do progresso do processo.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.IProcessLog.Update(System.Int32,System.Int32)">
            <summary>
            Atualiza um processo monitorado sem informar o nome, apenas o valor final e inicial. Só pode ser utilizado se o processo já foi iniciado (método Start) ou foi disparado pelo BTL ou BServer.
            </summary>
            <param name="startValue">Valor inicial para controle do progresso do processo</param>
            <param name="endValue">Valor final para controle do progresso do processo</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.IProcessLog.Abort(System.String)">
            <summary>
            Aborta um processo monitorado.
            </summary>
            <param name="message">Mensagem descritiva com o motivo pelo qual o processo foi abortado.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.IProcessLog.IncreaseProgress">
            <summary>
            Aumenta automaticamente o progresso do processo. Esta operação só é efetivada a cada 3 segundos. 
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.IProcessLog.IncreaseProgress(System.String)">
            <summary>
            Aumenta automaticamente o progresso do processo. Esta operação só é efetivada a cada 3 segundos. 
            </summary>
            <param name="message">Mensagem informativa do status do processo</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.IProcessLog.IncreaseProgress(System.Int32)">
            <summary>
            Aumenta o progresso do processo de acordo com <paramref name="increaseBy"/>. Esta operação só é efetivada a cada 3 segundos.
            </summary>
            <param name="increaseBy">O número de posições a incrementar</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.IProcessLog.Complete">
            <summary>
            Finaliza com sucesso um processo caso o método Complete ou CompleteWithError tenha sido chamado pela implementação
            da interface IProcessLogService.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.IProcessLog.CompleteWithError(System.String)">
            <summary>
            Finaliza com erro um processo.
            </summary>
            <param name="message">Mensagem descritiva com o motivo pelo qual o processo foi finalizado com erro.</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.ProcessLogFactory">
            <inheritdoc />    
        </member>
        <member name="M:Benner.Tecnologia.Business.ProcessLogFactory.CreateProcessLog">
            <inheritdoc />    
        </member>
        <member name="M:Benner.Tecnologia.Business.ProcessLogFactory.GetMainProcess">
            <inheritdoc />    
        </member>
        <member name="M:Benner.Tecnologia.Business.ProcessLogFactory.GetScheduledProcess">
            <inheritdoc />    
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.IBusinessTask">
            <summary>
            Representa uma tarefa
            </summary>
            <remarks>Para conhecer detalhes do funcionamento acesse <a href="Wiki?API do Business Tasks Library/Acompanhamento de tarefas">Acompanhamento de tarefas</a>.</remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.IBusinessTask.ProcessHandle">
            <summary>
            Identificação da tarefa
            </summary>
            <remarks>O ProcessHandle é um long que representa o Handle da tarefa disparada em Z_PROCESSOS, ele pode ser obtido através de <see cref="T:Benner.Tecnologia.Business.Tasks.BusinessTask"/> ou <c>BusinessTask&lt;TResponse&gt;</c>
            <code>
            // Disparando uma tarefa
            var task = BusinessTask.Factory.NewComponentTask&lt;Tarefa&gt;()
                .Start();
                    
             
            // Obtendo o ProcessHandle da tarefa
            var processHandle = task.ProcessHandle;
            </code>
            Através do <c>ProcessHandle</c> é possível recuperar informações, mesmo que tenha sido disparada em outro ponto do sistema, seja via API ou via consulta direta em <c>Z_PROCESSOS</c> (apenas para fins administrativos).</remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.IBusinessTask.Status">
            <summary>
            Status da tarefa
            </summary>
            <remarks>A propriedade Status retorna a situação atual da tarefa disparada. Ela retorna um enumerador do tipo ProcessStatus.
            O status da tarefa é obtido da coluna SITUAÇÃO de Z_PROCESSOS.
            Caso a tarefa não exista, será retornado <c>ProcessStatus.None</c></remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.IBusinessTask.IsTerminated">
            <summary>
            Verifica se a tarefa está terminada
            </summary>
            <remarks>Basicamente irá retornar <c>true</c> se o <c>Status</c> da tarefa for <c>ProcessStatus.Success</c>, <c>ProcessStatus.Error</c> ou <c>ProcessStatus.Aborted</c>.</remarks>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.InvalidTaskException">A tarefa não existe.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Benner.Tecnologia.Business.Tasks.IBusinessTask.RequestAbort" -->
        <member name="P:Benner.Tecnologia.Business.Tasks.IBusinessTask.Messages">
            <summary>
            Mensagens geradas pela tarefa durante a sua execução
            </summary>
            <remarks>As mensagens são geradas via <see cref="T:Benner.Tecnologia.Business.ProcessLog"/></remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.IBusinessTask.Host">
            <summary>
            Host de quem gerou a tarefa.
            </summary>
            <return>Retorna o host de quem disparou a tarefa.</return>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.IBusinessTask.User">
            <summary>
            Host de quem gerou a tarefa.
            </summary>
            <return>Retorna o host de quem disparou a tarefa.</return>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.IBusinessTask.StartDate">
            <summary>
            Data de inicio de quando a tarefa é iniciada.
            </summary>
            <return>Retorna a data de inicio da tarefa.</return>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTask.GetBDebuggerLog">
            <summary>
            Obtém o log do BDebugger da tarefa executada.
            </summary>
            <remarks>O método <c>GetBDebuggerLog()</c> retorna uma <c>string</c> com todo o log de BDebugger gerado. Deve ser chamado apenas ao final da execução da tarefa e só irá retornar informações se a tarefa terminou com erro ou foi configurada com o <c>AlwaysGenerateBDebugger()</c>.
            Deve ser utilizado para ajudar no desenvolvimento.</remarks>
            <returns><c>String</c> com o log do processamento.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTask.Wait(System.Int64)">
            <summary>
            Aguarda a tarefa encerrar 
            </summary>
            <remarks>Aguarda o término de uma tarefa. O término pode ocorrer por cancelamento, erro ou sucesso na execução da tarefa. Se a tarefa não foi executada com sucesso (devido a cancelamento ou erro) será lançada uma exceção.
            Aguardar uma tarefa terminar através do método <c>Wait()</c> com tempo limite (parâmetro <paramref name="millisecondsTimeout"/>) maior que zero torna a interação com a tarefa síncrona. Prefira, por exemplo, acompanhar o status da tarefa de forma assíncrona para determinar se foi concluída com sucesso/erro/cancelamento (Propriedade <see cref="P:Benner.Tecnologia.Business.Tasks.BusinessTask.Status"/>).</remarks>
            <param name="millisecondsTimeout">Tempo limite em milisegundos para aguardar o término da tarefa.</param>       
            <exception cref="T:System.InvalidOperationException">Quando <c>WaitResult</c> é chamado passando <paramref name="millisecondsTimeout"/> com valor maior que 0 a partir de uma tarefa que está em execução.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.TaskExecutionException">Quando ocorre um erro genérico na execução da tarefa.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.NotFinishedTaskException">A tarefa não terminou.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.InvalidTaskException">A tarefa não existe.</exception>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.IBusinessTask.ErrorMessage">
            <summary>
            Mensagem de erro da tarefa. 
            </summary>
            <remarks>Retorna <c>null</c> se a tarefa não terminou com erro.
            Esta propriedade lê o conteúdo do campo OCORRENCIA de Z_PROCESSOS.</remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.IBusinessTask.Exception">
            <summary>
            Exceção ocorrida na execução da tarefa. Retorna nulo se a tarefa não terminou com erro ou não existe exceção.
            </summary>
            <remarks>A propriedade Exception retorna o objeto de exceção ocorrido na tarefa. Pode retornar nulo caso não tenha ocorrido exceção. Por exemplo: Tarefa terminou com sucesso ou a tarefa ainda não terminou.</remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.IBusinessTask.ProgressPercent">
            <summary>
            Obtém o percentual de progresso da tarefa. 
            </summary>
            <remarks>Calculado com o valor inicial, valor final e valor atual da tarefa.</remarks>
            <returns>Percentual calculado.</returns>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.InvalidTaskException">A tarefa não existe.</exception>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.IBusinessTask.Description">
            <summary>
            Obtém a descrição da tarefa.
            </summary>
            <remarks>Retorna o valor da coluna NOME de Z_PROCESSOS.</remarks>
            <returns>Descrição da tarefa</returns>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.InvalidTaskException">A tarefa não existe.</exception>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.IBusinessTask`1">
            <summary>
            Representa uma tarefa com um retorno específico.
            </summary>
            <remarks>Para conhecer detalhes do funcionamento acesse <a href="Wiki?API do Business Tasks Library/Acompanhamento de tarefas">Acompanhamento de tarefas</a>.</remarks>
            <typeparam name="TResponse">Tipo do retorno</typeparam>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.IBusinessTask`1.Result">
            <summary>
            Obtém o resultado da tarefa
            </summary>
            <remarks>Obtém o resultado (ou retorno) de uma tarefa executada com sucesso. Se a tarefa não foi executada com sucesso (devido a cancelamento ou erro) será lançada uma exceção.</remarks>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.TaskExecutionException">Quando ocorre um erro genérico na execução da tarefa.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.NotFinishedTaskException">A tarefa não terminou.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.InvalidTaskException">A tarefa não existe.</exception>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.IBusinessTask`1.ResultTypeName">
            <summary>
            Obtém o nome do tipo do resultado da tarefa
            </summary>
            <remarks>Pode retornar null se o tipo não pode ser determinado</remarks>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.InvalidTaskException">A tarefa não existe.</exception>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.IBusinessTask`1.ResultType">
            <summary>
            Obtém o tipo do resultado da tarefa
            </summary>
            <remarks>Pode retornar null se o tipo não pode ser determinado</remarks>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.InvalidTaskException">A tarefa não existe.</exception>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTask`1.WaitResult(System.Int64)">
            <summary>
            Aguarda a tarefa encerrar e obtém o resultado
            </summary>
            <param name="millisecondsTimeout">Tempo limite em milisegundos para aguardar o término da tarefa.</param>
            <remarks>Aguarda o término de uma tarefa e retorna o resultado. O término pode ocorrer por cancelamento, erro ou sucesso na execução da tarefa. Se a tarefa não foi executada com sucesso (devido a cancelamento ou erro) será lançada uma exceção. 
            O método <c>WaitResult()</c> deve ser utilizado apenas em tarefas que possuem retorno.
            Aguardar uma tarefa terminar através do método <c>WaitResult()</c> com tempo limite (parâmetro <paramref name="millisecondsTimeout"/>) maior que zero torna a interação com a tarefa síncrona.
            Prefira, por exemplo, acompanhar o status da tarefa de forma assíncrona e obter o resultado apenas quando a mesma for concluída com sucesso (Propriedade Status).</remarks>
            <returns>Resultado da tarefa</returns>
            <exception cref="T:System.InvalidOperationException">Quando <c>WaitResult</c> é chamado passando <paramref name="millisecondsTimeout"/> com valor maior que 0 a partir de uma tarefa que está em execução.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.TaskExecutionException">Quando ocorre um erro genérico na execução da tarefa.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.NotFinishedTaskException">A tarefa não terminou.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.InvalidTaskException">A tarefa não existe.</exception>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.IBusinessTaskFactory">
            <summary>
            Factory de tarefas
            </summary>
            <remarks>Para conhecer detalhes sobre o disparo de tarefas acesse <a href="Wiki?API do Business Tasks Library/Disparo de tarefas">Disparo de tarefas</a> na nossa Wiki.</remarks>
            <summary>
            Factory de tarefas
            </summary>
            <remarks>Para conhecer detalhes sobre o disparo de tarefas acesse <a href="Wiki?API do Business Tasks Library/Disparo de tarefas">Disparo de tarefas</a> na nossa Wiki.</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskFactory.NewComponentTask``1">
            <summary>
            Nova tarefa de BusinessComponent. Necessário que o componente implemente a interface IBusinessTaskAction ou IBusinessTaskFunc.
            </summary>
            <typeparam name="T">Componente de negócio</typeparam>
            <returns>Retorna instância de ComponentTaskSyntax para configuração da tarefa com interface fluente</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskFactory.NewComponentTask(System.Type)">
            <summary>
            Nova tarefa de BusinessComponent. Necessário que o componente implemente a interface IBusinessTaskAction ou IBusinessTaskFunc.
            </summary>
            <param name="businessComponentType">Tipo do componente de negócio</param>
            <returns>Retorna instância de ComponentTaskSyntax para configuração da tarefa com interface fluente</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskFactory.GetTask(System.Int64)">
            <summary>
            Obtém uma tarefa já disparada
            </summary>
            <param name="processHandle">Handle do processo</param>
            <returns>Instância de BusinessTask para acompanhar/controlar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskFactory.GetTask``1(System.Int64)">
            <summary>
            Obtém uma tarefa já disparada que possui response.
            </summary>
            <param name="processHandle">Handle do processo</param>
            <typeparam name="TResponse">Tipo do retorno da tarefa</typeparam>
            <returns>Instância de BusinessTask&lt;TResponse&gt; para acompanhar/controlar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskFactory.NewComponentTask(System.String)">
            <summary>
            Nova tarefa de BusinessComponent. Necessário que o componente implemente a interface IBusinessTaskAction ou IBusinessTaskFunc.
            </summary>
            <param name="businessComponentTypeName">Nome completo do componente de negócio no seguinte formato: Namespace.Componente, Assembly</param>
            <returns>Retorna instância de ComponentTaskSyntax para configuração da tarefa com interface fluente</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskFactory.NewDllTask(System.String)">
            <summary>
            Nova tarefa de DLL (legado)
            </summary>
            <param name="dllClassName">Nome da Dll</param>
            <returns>Retorna instância de DllTaskSyntax para configuração da tarefa com interface fluente</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskFactory.NewMacroTask(System.String)">
            <summary>
            Nova tarefa de Macro (legado)
            </summary>
            <param name="macroIdCode">Código de identificação da macro (Campo CODIGO de Z_MACROS)</param>
            <returns>Retorna instância de MacroTaskSyntax para configuração da tarefa com interface fluente</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskFactory.NewMacroTask(System.Int64)">
            <summary>
            Nova tarefa de Macro (legado)
            </summary>
            <param name="macroHandle">Handle da macro</param>
            <returns>Retorna instância de MacroTaskSyntax para configuração da tarefa com interface fluente</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.IBusinessTaskSyntax`2">
            <summary>
            Representa a sintaxe fluente para disparo de Tasks no BTL
            </summary>
            <typeparam name="TTaskSyntax">Sub sintaxe</typeparam>
            <typeparam name="TTaskRequest">Tipo da request (mensagem)</typeparam>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.IBusinessTaskSyntax`2.TaskRequest">
            <summary>
            Request gerada pela sintaxe fluente
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskSyntax`2.WithDescription(System.String,System.Object[])">
            <summary>
            Configura uma descrição para a tarefa que será disparada. Será exibida no monitor de processos.
            </summary>
            <param name="description">Descrição</param>
            <param name="parameters">Parâmetros que serão inseridos na descrição</param>
            <returns>Instância da sintaxe fluente para configurar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskSyntax`2.WithDescription(System.String)">
            <summary>
            Configura uma descrição para a tarefa que será disparada. Será exibida no monitor de processos.
            </summary>
            <param name="description">Descrição</param>
            <returns>Instância da sintaxe fluente para configurar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskSyntax`2.WithCompany(Benner.Tecnologia.Common.Company)">
            <summary>
            Configura a empresa que será utilizada para executar a tarefa. Ao configurar a empresa, serão selecionadas todas as filiais automaticamente.
            </summary>
            <param name="companyEntity">Entidade da empresa</param>
            <returns>Instância da sintaxe fluente para configurar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskSyntax`2.WithCompany(Benner.Tecnologia.Common.Handle)">
            <summary>
            Configura a empresa que será utilizada para executar a tarefa. 
            Ao configurar a empresa, serão selecionadas todas as filiais automaticamente.
            </summary>
            <param name="companyHandle">Handle da empresa</param>
            <returns>Instância da sintaxe fluente para configurar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskSyntax`2.WithBranch(Benner.Tecnologia.Common.Branch)">
            <summary>
            Configura a filial que será utilizada para executar a tarefa.
            Se for informado null, serão selecionadas todas as filiais.
            </summary>
            <param name="branchEntity">Entidade da filial</param>
            <returns>Instância da sintaxe fluente para configurar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskSyntax`2.WithBranch(Benner.Tecnologia.Common.Handle)">
            <summary>
            Configura a filial que será utilizada para executar a tarefa.
            Se for informado 0, serão selecionadas todas as filiais.
            </summary>
            <param name="branchHandle">Handle da filial</param>
            <returns>Instância da sintaxe fluente para configurar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskSyntax`2.WithAllBranches">
            <summary>
            Configura a tarefa para executar utilizando todas as filiais que o usuário tem acesso
            </summary>
            <returns>Instância da sintaxe fluente para configurar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskSyntax`2.WithPriority(System.Int32)">
            <summary>
            Ordem de prioridade para execução. Quanto menor o valor informado, mais alta é a prioridade. Aceita valores negativos.
            </summary>
            <param name="priority"></param>
            <returns>Instância da sintaxe fluente para configurar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskSyntax`2.RunAs(System.String)">
            <summary>
            Configura o usuário de sistema (Z_GRUPOUSUARIOS) que irá executar a tarefa
            </summary>
            <param name="userName">Apelido do usuário</param>
            <returns>Instância da sintaxe fluente para configurar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskSyntax`2.WithNotification">
            <summary>
            O disparo da tarefa deve gerar notificação para o usuario
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskSyntax`2.AlwaysGenerateBDebugger">
            <summary>
            Sempre armazena o log do BDebugger quando possível. 
            Por padrão o log do BDebugger só é salvo em caso de erro.
            </summary>
            <returns>Instância de TTaskSyntax para continuar a configurar a task</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskSyntax`2.CanReprocess">
            <summary>
            Se pode reprocessar a tarefa no caso de reinicialização do BTL
            </summary>
            <returns>Instância de TTaskSyntax para continuar a configurar a task</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.IComponentTaskSyntax">
            <summary>
            Sintaxe fluente para criação de tarefas de BusinessComponents
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IComponentTaskSyntax.WithRequestValue``1(``0)">
            <summary>
            Passa um request para o componente que irá executar a tarefa
            </summary>
            <typeparam name="TRequest">Tipo do request</typeparam>
            <param name="request">Valor do request</param>
            <returns>Instância de ComponentTaskSyntax para continuar a configurar a task</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IComponentTaskSyntax.Start">
            <summary>
            Inicia a tarefa que não terá resposta (IBusinessTaskAction)
            </summary>
            <returns>Objeto BusinessTask para controle do processo</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IComponentTaskSyntax.Start``1">
            <summary>
            Inicia a tarefa que terá resposta (IBusinessTaskFunc) cujo tipo será o tipo passado
            </summary>
            <typeparam name="TResponse">Tipo da resposta do processo</typeparam>
            <returns>Objeto BusinessTask para controle do processo</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.IDllTaskSyntax">
            <summary>
            Sintaxe fluente para criação de tarefas de Dll (Legado)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.ILegacyTaskSyntax`2">
            <summary>
            Representa a sintaxe fluente para disparo de Tasks no BTL para legado
            </summary>
            <typeparam name="TTaskSyntax">Sub sintaxe</typeparam>
            <typeparam name="TTaskRequest">Tipo da request (mensagem)</typeparam>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ILegacyTaskSyntax`2.AddSessionVar(System.String,System.String)">
            <summary>
            Adiciona uma variável de sessão (SESSIONVAR) a tarefa que será executada
            </summary>
            <param name="varName">Nome da variável de sessão</param>
            <param name="varValue">Valor da variável de sessão</param>
            <returns>Instância de TTaskSyntax para continuar a configurar a task</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ILegacyTaskSyntax`2.WithData``1(System.Collections.Generic.IList{``0})">
            <summary>
            Envia para o ServerContainer do BSistema uma lista de objetos
            </summary>
            <typeparam name="T">Tipo item da lista</typeparam>
            <param name="data">Lista de objetos</param>
            <returns>Instância de TTaskSyntax para continuar a configurar a task</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ILegacyTaskSyntax`2.WithData``1(Benner.Tecnologia.Common.Entities{``0})">
            <summary>
            Envia para o ServerContainer do BSistema uma lista de entidades
            </summary>
            <typeparam name="T">Tipo da entidade</typeparam>
            <param name="entities">Lista de entidades</param>
            <returns>Instância de TTaskSyntax para continuar a configurar a task</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ILegacyTaskSyntax`2.Start">
            <summary>
            Inicia a tarefa do legado.
            </summary>
            <returns>Objeto BusinessTask&lt;string&gt; para controle do processo e obtenção do InfoDescription</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.IMacroTaskSyntax">
            <summary>
            Sintaxe fluente para criação de tarefas de Macro (Legado)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.BusinessTask">
            <summary>
            Representa uma tarefa
            </summary>
            <remarks>Para conhecer detalhes do funcionamento acesse <a href="Wiki?API do Business Tasks Library/Acompanhamento de tarefas">Acompanhamento de tarefas</a>.</remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.BusinessTask.TasksService">
            <summary>
            Serviço de tarefas
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.BusinessTask.Factory">
            <summary>
            Factory de tarefas
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.BusinessTask.ProcessHandle">
            <summary>
            Identificação da tarefa
            </summary>
            <remarks>O ProcessHandle é um long que representa o Handle da tarefa disparada em Z_PROCESSOS, ele pode ser obtido através de <see cref="T:Benner.Tecnologia.Business.Tasks.BusinessTask"/> ou <c>BusinessTask&lt;TResponse&gt;</c>
            <code>
            // Disparando uma tarefa
            var task = BusinessTask.Factory.NewComponentTask&lt;Tarefa&gt;()
                .Start();
                    
             
            // Obtendo o ProcessHandle da tarefa
            var processHandle = task.ProcessHandle;
            </code>
            Através do <c>ProcessHandle</c> é possível recuperar informações, mesmo que tenha sido disparada em outro ponto do sistema, seja via API ou via consulta direta em <c>Z_PROCESSOS</c> (apenas para fins administrativos).</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTask.#ctor(Benner.Tecnologia.Common.Services.ITasksService,System.Int64)">
            <summary>
            Inicializa classe que representa tarefa
            </summary>
            <remarks>Para conhecer detalhes do funcionamento acesse <a href="Wiki?API do Business Tasks Library/Acompanhamento de tarefas">Acompanhamento de tarefas</a>.</remarks>
            <param name="taskService">Serviço de tarefas</param>
            <param name="processHandle">Handle do processo da Tarefa</param>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.BusinessTask.Status">
            <summary>
            Status da tarefa
            </summary>
            <remarks>A propriedade Status retorna a situação atual da tarefa disparada. Ela retorna um enumerador do tipo ProcessStatus.
            O status da tarefa é obtido da coluna SITUAÇÃO de Z_PROCESSOS.
            Caso a tarefa não exista, será retornado <c>ProcessStatus.None</c></remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.BusinessTask.IsTerminated">
            <summary>
            Verifica se a tarefa está terminada
            </summary>
            <remarks>Basicamente irá retornar <c>true</c> se o <c>Status</c> da tarefa for <c>ProcessStatus.Success</c>, <c>ProcessStatus.Error</c> ou <c>ProcessStatus.Aborted</c>.</remarks>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.InvalidTaskException">A tarefa não existe.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Benner.Tecnologia.Business.Tasks.BusinessTask.RequestAbort" -->
        <member name="P:Benner.Tecnologia.Business.Tasks.BusinessTask.Messages">
            <summary>
            Mensagens geradas pela tarefa durante a sua execução
            </summary>
            <remarks>As mensagens são geradas via <see cref="T:Benner.Tecnologia.Business.ProcessLog"/></remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.BusinessTask.Host">
            <summary>
            Host de quem gerou a tarefa.
            </summary>
            <return>Retorna o host de quem disparou a tarefa.</return>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.BusinessTask.User">
            <summary>
            Host de quem gerou a tarefa.
            </summary>
            <return>Retorna o host de quem disparou a tarefa.</return>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.BusinessTask.StartDate">
            <summary>
            Data de inicio de quando a tarefa é iniciada.
            </summary>
            <return>Retorna a data de inicio da tarefa.</return>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTask.GetBDebuggerLog">
            <summary>
            Obtém o log do BDebugger da tarefa executada.
            </summary>
            <remarks>O método <c>GetBDebuggerLog()</c> retorna uma <c>string</c> com todo o log de BDebugger gerado. Deve ser chamado apenas ao final da execução da tarefa e só irá retornar informações se a tarefa terminou com erro ou foi configurada com o <c>AlwaysGenerateBDebugger()</c>.
            Deve ser utilizado para ajudar no desenvolvimento.</remarks>
            <returns><c>String</c> com o log do processamento.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTask.Wait(System.Int64)">
            <summary>
            Aguarda a tarefa encerrar 
            </summary>
            <remarks>Aguarda o término de uma tarefa. O término pode ocorrer por cancelamento, erro ou sucesso na execução da tarefa. Se a tarefa não foi executada com sucesso (devido a cancelamento ou erro) será lançada uma exceção.
            Aguardar uma tarefa terminar através do método <c>Wait()</c> com tempo limite (parâmetro <paramref name="millisecondsTimeout"/>) maior que zero torna a interação com a tarefa síncrona. Prefira, por exemplo, acompanhar o status da tarefa de forma assíncrona para determinar se foi concluída com sucesso/erro/cancelamento (Propriedade <see cref="P:Benner.Tecnologia.Business.Tasks.BusinessTask.Status"/>).</remarks>
            <param name="millisecondsTimeout">Tempo limite em milisegundos para aguardar o término da tarefa.</param>       
            <exception cref="T:System.InvalidOperationException">Quando <c>WaitResult</c> é chamado passando <paramref name="millisecondsTimeout"/> com valor maior que 0 a partir de uma tarefa que está em execução.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.TaskExecutionException">Quando ocorre um erro genérico na execução da tarefa.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.NotFinishedTaskException">A tarefa não terminou.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.InvalidTaskException">A tarefa não existe.</exception>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.BusinessTask.ErrorMessage">
            <summary>
            Mensagem de erro da tarefa. 
            </summary>
            <remarks>Retorna <c>null</c> se a tarefa não terminou com erro.
            Esta propriedade lê o conteúdo do campo OCORRENCIA de Z_PROCESSOS.</remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.BusinessTask.Exception">
            <summary>
            Exceção ocorrida na execução da tarefa. Retorna nulo se a tarefa não terminou com erro ou não existe exceção.
            </summary>
            <remarks>A propriedade Exception retorna o objeto de exceção ocorrido na tarefa. Pode retornar nulo caso não tenha ocorrido exceção. Por exemplo: Tarefa terminou com sucesso ou a tarefa ainda não terminou.</remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.BusinessTask.ProgressPercent">
            <summary>
            Obtém o percentual de progresso da tarefa. 
            </summary>
            <remarks>Calculado com o valor inicial, valor final e valor atual da tarefa.</remarks>
            <returns>Percentual calculado.</returns>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.InvalidTaskException">A tarefa não existe.</exception>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.BusinessTask.Description">
            <summary>
            Obtém a descrição da tarefa.
            </summary>
            <remarks>Retorna o valor da coluna NOME de Z_PROCESSOS.</remarks>
            <returns>Descrição da tarefa</returns>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.InvalidTaskException">A tarefa não existe.</exception>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.BusinessTask`1">
            <summary>
            Representa uma tarefa com um retorno específico.
            </summary>
            <remarks>Para conhecer detalhes do funcionamento acesse <a href="Wiki?API do Business Tasks Library/Acompanhamento de tarefas">Acompanhamento de tarefas</a>.</remarks>
            <typeparam name="TResponse">Tipo do retorno</typeparam>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTask`1.#ctor(Benner.Tecnologia.Common.Services.ITasksService,System.Int64)">
            <summary>
            Construtor
            </summary>
            <param name="taskService">Serviço de gerenciamento de tarefas</param>
            <param name="processHandle">ProcessHandle da tarefa</param>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.BusinessTask`1.Result">
            <summary>
            Obtém o resultado da tarefa
            </summary>
            <remarks>Obtém o resultado (ou retorno) de uma tarefa executada com sucesso. Se a tarefa não foi executada com sucesso (devido a cancelamento ou erro) será lançada uma exceção.</remarks>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.TaskExecutionException">Quando ocorre um erro genérico na execução da tarefa.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.NotFinishedTaskException">A tarefa não terminou.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.InvalidTaskException">A tarefa não existe.</exception>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.BusinessTask`1.ResultTypeName">
            <summary>
            Obtém o nome do tipo do resultado da tarefa
            </summary>
            <remarks>Pode retornar null se o tipo não pode ser determinado</remarks>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.InvalidTaskException">A tarefa não existe.</exception>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.BusinessTask`1.ResultType">
            <summary>
            Obtém o tipo do resultado da tarefa
            </summary>
            <remarks>Pode retornar null se o tipo não pode ser determinado</remarks>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.InvalidTaskException">A tarefa não existe.</exception>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTask`1.WaitResult(System.Int64)">
            <summary>
            Aguarda a tarefa encerrar e obtém o resultado
            </summary>
            <param name="millisecondsTimeout">Tempo limite em milisegundos para aguardar o término da tarefa.</param>
            <remarks>Aguarda o término de uma tarefa e retorna o resultado. O término pode ocorrer por cancelamento, erro ou sucesso na execução da tarefa. Se a tarefa não foi executada com sucesso (devido a cancelamento ou erro) será lançada uma exceção. 
            O método <c>WaitResult()</c> deve ser utilizado apenas em tarefas que possuem retorno.
            Aguardar uma tarefa terminar através do método <c>WaitResult()</c> com tempo limite (parâmetro <paramref name="millisecondsTimeout"/>) maior que zero torna a interação com a tarefa síncrona.
            Prefira, por exemplo, acompanhar o status da tarefa de forma assíncrona e obter o resultado apenas quando a mesma for concluída com sucesso (Propriedade Status).</remarks>
            <returns>Resultado da tarefa</returns>
            <exception cref="T:System.InvalidOperationException">Quando <c>WaitResult</c> é chamado passando <paramref name="millisecondsTimeout"/> com valor maior que 0 a partir de uma tarefa que está em execução.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.TaskExecutionException">Quando ocorre um erro genérico na execução da tarefa.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.NotFinishedTaskException">A tarefa não terminou.</exception>
            <exception cref="T:Benner.Tecnologia.Common.Exceptions.InvalidTaskException">A tarefa não existe.</exception>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.BusinessTaskFactory">
            <summary>
            Factory de tarefas
            </summary>
            <remarks>Para conhecer detalhes sobre o disparo de tarefas acesse <a href="Wiki?API do Business Tasks Library/Disparo de tarefas">Disparo de tarefas</a> na nossa Wiki.</remarks>
            <summary>
            Factory de tarefas
            </summary>
            <remarks>Para conhecer detalhes sobre o disparo de tarefas acesse <a href="Wiki?API do Business Tasks Library/Disparo de tarefas">Disparo de tarefas</a> na nossa Wiki.</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskFactory.NewComponentTask``1">
            <summary>
            Nova tarefa de BusinessComponent. Necessário que o componente implemente a interface IBusinessTaskAction ou IBusinessTaskFunc.
            </summary>
            <typeparam name="T">Componente de negócio</typeparam>
            <returns>Retorna instância de ComponentTaskSyntax para configuração da tarefa com interface fluente</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskFactory.NewComponentTask(System.Type)">
            <summary>
            Nova tarefa de BusinessComponent. Necessário que o componente implemente a interface IBusinessTaskAction ou IBusinessTaskFunc.
            </summary>
            <param name="businessComponentType">Tipo do componente de negócio</param>
            <returns>Retorna instância de ComponentTaskSyntax para configuração da tarefa com interface fluente</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskFactory.#ctor(Benner.Tecnologia.Common.Services.ITasksService,Benner.Tecnologia.Common.Services.ISecurityService,Benner.Tecnologia.Common.Services.IAdministrationService)">
            <summary>
            Inicializa factory de Tarefas
            </summary>
            <param name="taskService">Serviço de tarefas</param>
            <param name="securityService">Serviço de segurança</param>
            <param name="administrationService">Serviço de administração</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskFactory.GetTask(System.Int64)">
            <summary>
            Obtém uma tarefa já disparada
            </summary>
            <param name="processHandle">Handle do processo</param>
            <returns>Instância de BusinessTask para acompanhar/controlar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskFactory.GetTask``1(System.Int64)">
            <summary>
            Obtém uma tarefa já disparada que possui response.
            </summary>
            <param name="processHandle">Handle do processo</param>
            <typeparam name="TResponse">Tipo do retorno da tarefa</typeparam>
            <returns>Instância de BusinessTask&lt;TResponse&gt; para acompanhar/controlar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskFactory.NewComponentTask(System.String)">
            <summary>
            Nova tarefa de BusinessComponent. Necessário que o componente implemente a interface IBusinessTaskAction ou IBusinessTaskFunc.
            </summary>
            <param name="businessComponentTypeName">Nome completo do componente de negócio no seguinte formato: Namespace.Componente, Assembly</param>
            <returns>Retorna instância de ComponentTaskSyntax para configuração da tarefa com interface fluente</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskFactory.NewReportTask(Benner.Tecnologia.Common.Handle)">
            <summary>
            Nova tarefa de relatório.
            </summary>
            <param name="reportHandle">Handle do relatório que será emitido.</param>
            <returns>Retorna instância de ReportComponentTaskSyntax para configuração da tarefa com interface fluente.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskFactory.NewReportTask(System.String)">
            <summary>
            Nova tarefa de relatório.
            </summary>
            <param name="reportCode">Codigo do relatório que será emitido.</param>
            <returns>Retorna instância de ReportComponentTaskSyntax para configuração da tarefa com interface fluente.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskFactory.NewDllTask(System.String)">
            <summary>
            Nova tarefa de DLL (legado)
            </summary>
            <param name="dllClassName">Nome da Dll</param>
            <returns>Retorna instância de DllTaskSyntax para configuração da tarefa com interface fluente</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskFactory.NewMacroTask(System.String)">
            <summary>
            Nova tarefa de Macro (legado)
            </summary>
            <param name="macroIdCode">Código de identificação da macro (Campo CODIGO de Z_MACROS)</param>
            <returns>Retorna instância de MacroTaskSyntax para configuração da tarefa com interface fluente</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskFactory.NewMacroTask(System.Int64)">
            <summary>
            Nova tarefa de Macro (legado)
            </summary>
            <param name="macroHandle">Handle da macro</param>
            <returns>Retorna instância de MacroTaskSyntax para configuração da tarefa com interface fluente</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.BusinessTaskSyntax`2">
            <summary>
            Representa a sintaxe fluente para disparo de Tasks no BTL
            </summary>
            <typeparam name="TTaskSyntax">Sub sintaxe</typeparam>
            <typeparam name="TTaskRequest">Tipo da request (mensagem)</typeparam>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.BusinessTaskSyntax`2.TasksService">
            <summary>
            Serviço de tarefas
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.Tasks.BusinessTaskSyntax`2._notifyTaskStart">
            <summary>
            Se o disparo da tarefa irá gerar uma notificação
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Tasks.BusinessTaskSyntax`2.TaskRequest">
            <summary>
            Request gerada pela sintaxe fluente
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskSyntax`2.#ctor(Benner.Tecnologia.Common.Services.ITasksService,Benner.Tecnologia.Common.Services.ISecurityService,Benner.Tecnologia.Common.Services.IAdministrationService)">
            <summary>
            Inicializa a sintaxe fluente
            </summary>
            <param name="taskService">Serviço de tarefas</param>
            <param name="securityService">Serviço de segurança</param>
            <param name="administrationService">Serviço de administração</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskSyntax`2.WithDescription(System.String,System.Object[])">
            <summary>
            Configura uma descrição para a tarefa que será disparada. Será exibida no monitor de processos.
            </summary>
            <param name="description">Descrição</param>
            <param name="parameters">Parâmetros que serão inseridos na descrição</param>
            <returns>Instância da sintaxe fluente para configurar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskSyntax`2.WithDescription(System.String)">
            <summary>
            Configura uma descrição para a tarefa que será disparada. Será exibida no monitor de processos.
            </summary>
            <param name="description">Descrição</param>
            <returns>Instância da sintaxe fluente para configurar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskSyntax`2.WithCompany(Benner.Tecnologia.Common.Company)">
            <summary>
            Configura a empresa que será utilizada para executar a tarefa. Ao configurar a empresa, serão selecionadas todas as filiais automaticamente.
            </summary>
            <param name="companyEntity">Entidade da empresa</param>
            <returns>Instância da sintaxe fluente para configurar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskSyntax`2.WithCompany(Benner.Tecnologia.Common.Handle)">
            <summary>
            Configura a empresa que será utilizada para executar a tarefa. 
            Ao configurar a empresa, serão selecionadas todas as filiais automaticamente.
            </summary>
            <param name="companyHandle">Handle da empresa</param>
            <returns>Instância da sintaxe fluente para configurar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskSyntax`2.WithBranch(Benner.Tecnologia.Common.Branch)">
            <summary>
            Configura a filial que será utilizada para executar a tarefa.
            Se for informado null, serão selecionadas todas as filiais.
            </summary>
            <param name="branchEntity">Entidade da filial</param>
            <returns>Instância da sintaxe fluente para configurar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskSyntax`2.WithBranch(Benner.Tecnologia.Common.Handle)">
            <summary>
            Configura a filial que será utilizada para executar a tarefa.
            Se for informado 0, serão selecionadas todas as filiais.
            </summary>
            <param name="branchHandle">Handle da filial</param>
            <returns>Instância da sintaxe fluente para configurar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskSyntax`2.WithAllBranches">
            <summary>
            Configura a tarefa para executar utilizando todas as filiais que o usuário tem acesso
            </summary>
            <returns>Instância da sintaxe fluente para configurar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskSyntax`2.WithPriority(System.Int32)">
            <summary>
            Ordem de prioridade para execução. Quanto menor o valor informado, mais alta é a prioridade. Aceita valores negativos.
            </summary>
            <param name="priority"></param>
            <returns>Instância da sintaxe fluente para configurar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskSyntax`2.RunAs(System.String)">
            <summary>
            Configura o usuário de sistema (Z_GRUPOUSUARIOS) que irá executar a tarefa
            </summary>
            <param name="userName">Apelido do usuário</param>
            <returns>Instância da sintaxe fluente para configurar a tarefa</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskSyntax`2.WithNotification">
            <summary>
            O disparo da tarefa deve gerar notificação para o usuario
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskSyntax`2.CanReprocess">
            <summary>
            Se pode reprocessar a tarefa no caso de reinicialização do BTL
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskSyntax`2.AlwaysGenerateBDebugger">
            <summary>
            Sempre armazena o log do BDebugger quando possível. 
            Por padrão o log do BDebugger só é salvo em caso de erro.
            </summary>
            <returns>Instância de TTaskSyntax para continuar a configurar a task</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.BusinessTaskSyntax`2.StartTask(System.Type)">
            <summary>
            Cria o processo em Z_PROCESSOS e envia a mensagem da tarefa
            </summary>
            <param name="returnType">Tipo do retorno da tarefa</param>
            <returns>ProcessHandle da tarefa</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.ComponentTaskSyntax">
            <summary>
            Sintaxe fluente para criação de tarefas de BusinessComponents
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ComponentTaskSyntax.#ctor(Benner.Tecnologia.Common.Services.ITasksService,Benner.Tecnologia.Common.Services.ISecurityService,Benner.Tecnologia.Common.Services.IAdministrationService,System.String)">
            <summary>
            Inicializa sintaxe fluente
            </summary>
            <param name="taskService">Serviço de tarefas</param>
            <param name="securityService">Serviço de segurança</param>
            <param name="administrationService">Serviço de administração</param>
            <param name="componentTypeName">Nome completo do componente de negócio</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ComponentTaskSyntax.WithRequestValue``1(``0)">
            <summary>
            Passa um request para o componente que irá executar a tarefa
            </summary>
            <typeparam name="TRequest">Tipo do request</typeparam>
            <param name="request">Valor do request</param>
            <returns>Instância de ComponentTaskSyntax para continuar a configurar a task</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ComponentTaskSyntax.AlwaysGenerateBDebugger">
            <summary>
            Sempre armazena o log do BDebugger quando possível. 
            Por padrão o log do BDebugger só é salvo em caso de erro.
            </summary>
            <returns>Instância de ComponentTaskSyntax para continuar a configurar a task</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ComponentTaskSyntax.Start">
            <summary>
            Inicia a tarefa que não terá resposta (IBusinessTaskAction)
            </summary>
            <returns>Objeto BusinessTask para controle do processo</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ComponentTaskSyntax.Start``1">
            <summary>
            Inicia a tarefa que terá resposta (IBusinessTaskFunc) cujo tipo será o tipo passado
            </summary>
            <typeparam name="TResponse">Tipo da resposta do processo</typeparam>
            <returns>Objeto BusinessTask para controle do processo</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.DllTaskSyntax">
            <summary>
            Sintaxe fluente para criação de tarefas de Dll (Legado)
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.DllTaskSyntax.#ctor(Benner.Tecnologia.Common.Services.ITasksService,Benner.Tecnologia.Common.Services.ISecurityService,Benner.Tecnologia.Common.Services.IAdministrationService,System.String)">
            <summary>
            Inicializa sintaxe fluente
            </summary>
            <param name="taskService">Serviço de tarefas</param>
            <param name="securityService">Serviço de segurança</param>
            <param name="administrationService">Serviço de administração</param>
            <param name="dllClassName">Dll</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.IBusinessTaskAction">
            <summary>
            Interface para implementação de tarefas em BusinessComponents
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskAction.Run">
            <summary>
            Método de execução
            </summary>
            <returns>Objeto de saída</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.IBusinessTaskAction`1">
            <summary>
            Interface para implementação de tarefas em BusinessComponents
            </summary>
            <typeparam name="TRequest">Tipo do objeto de entrada</typeparam>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskAction`1.Run(`0)">
            <summary>
            Método de execução
            </summary>
            <param name="request">Objeto de entrada</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.IBusinessTaskFunc`1">
            <summary>
            Interface para implementação de tarefas em BusinessComponents
            </summary>
            <typeparam name="TRequest">Tipo do objeto de entrada</typeparam>
            <typeparam name="TResponse">Tipo do objeto de saída</typeparam>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskFunc`1.Run">
            <summary>
            Método de execução
            </summary>
            <returns>Objeto de saída</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.IBusinessTaskFunc`2">
            <summary>
            Interface para implementação de tarefas em BusinessComponents
            </summary>
            <typeparam name="TRequest">Tipo do objeto de entrada</typeparam>
            <typeparam name="TResponse">Tipo do objeto de saída</typeparam>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.IBusinessTaskFunc`2.Run(`0)">
            <summary>
            Método de execução
            </summary>
            <param name="request">Objeto de entrada</param>
            <returns>Objeto de saída</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.LegacyTaskSyntax`2">
            <summary>
            Representa a sintaxe fluente para disparo de Tasks no BTL para legado
            </summary>
            <typeparam name="TTaskSyntax">Sub sintaxe</typeparam>
            <typeparam name="TTaskRequest">Tipo da request (mensagem)</typeparam>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.LegacyTaskSyntax`2.#ctor(Benner.Tecnologia.Common.Services.ITasksService,Benner.Tecnologia.Common.Services.ISecurityService,Benner.Tecnologia.Common.Services.IAdministrationService)">
            <summary>
            Inicializa a sintaxe fluente (legado: macro e dll)
            </summary>
            <param name="taskService">Serviço de tarefas</param>
            <param name="securityService">Serviço de segurança</param>
            <param name="administrationService">Serviço de administração</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.LegacyTaskSyntax`2.AlwaysGenerateBDebugger">
            <summary>
            Sempre armazena o log do BDebugger quando possível. 
            Por padrão o log do BDebugger só é salvo em caso de erro.
            </summary>
            <returns>Instância de TTaskSyntax para continuar a configurar a task</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.LegacyTaskSyntax`2.AddSessionVar(System.String,System.String)">
            <summary>
            Adiciona uma variável de sessão (SESSIONVAR) a tarefa que será executada
            </summary>
            <param name="varName">Nome da variável de sessão</param>
            <param name="varValue">Valor da variável de sessão</param>
            <returns>Instância de TTaskSyntax para continuar a configurar a task</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.LegacyTaskSyntax`2.WithData``1(System.Collections.Generic.IList{``0})">
            <summary>
            Envia para o ServerContainer do BSistema uma lista de objetos
            </summary>
            <typeparam name="T">Tipo item da lista</typeparam>
            <param name="data">Lista de objetos</param>
            <returns>Instância de TTaskSyntax para continuar a configurar a task</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.LegacyTaskSyntax`2.WithData``1(Benner.Tecnologia.Common.Entities{``0})">
            <summary>
            Envia para o ServerContainer do BSistema uma lista de entidades
            </summary>
            <typeparam name="T">Tipo da entidade</typeparam>
            <param name="entities">Lista de entidades</param>
            <returns>Instância de TTaskSyntax para continuar a configurar a task</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.LegacyTaskSyntax`2.Start">
            <summary>
            Inicia a tarefa do legado.
            </summary>
            <returns>Objeto BusinessTask&lt;string&gt; para controle do processo e obtenção do InfoDescription</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.MacroTaskSyntax">
            <summary>
            Sintaxe fluente para criação de tarefas de Macro (Legado)
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.MacroTaskSyntax.#ctor(Benner.Tecnologia.Common.Services.ITasksService,Benner.Tecnologia.Common.Services.ISecurityService,Benner.Tecnologia.Common.Services.IAdministrationService,System.String)">
            <summary>
            Inicializa sintaxe fluente
            </summary>
            <param name="taskService">Serviço de tarefas</param>
            <param name="securityService">Serviço de segurança</param>
            <param name="administrationService">Serviço de administração</param>
            <param name="macroIdCode">Código de identificação da macro (Campo CODIGO de Z_MACROS)</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.Tasks.ReportComponentTaskSyntax">
            <summary>
            Sintaxe fluente para a criação de tarefas de emissão de relatórios.
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.Tasks.ReportComponentTaskSyntax._componentRequest">
            <summary>
            Request passada para o ReportTaskExecutor.Run (componente de negócio) que irá emitir o relatório
            Esse _componentRequest (DataContract) é diferente da TaskRequest (ProtoContract) que também é preenchida nessa classe.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ReportComponentTaskSyntax.#ctor(Benner.Tecnologia.Common.Services.ITasksService,Benner.Tecnologia.Common.Services.ISecurityService,Benner.Tecnologia.Common.Services.IAdministrationService,Benner.Tecnologia.Common.Handle)">
            <summary>
            Inicializa da sintaxe fluente.
            </summary>
            <param name="taskService">Serviço de tarefas.</param>
            <param name="securityService">Serviço de segurança</param>
            <param name="administrationService">Serviço de administração.</param>
            <param name="reportHandle">Handle do relatório que será emitido.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ReportComponentTaskSyntax.#ctor(Benner.Tecnologia.Common.Services.ITasksService,Benner.Tecnologia.Common.Services.ISecurityService,Benner.Tecnologia.Common.Services.IAdministrationService,System.String)">
            <summary>
            Inicializa da sintaxe fluente.
            </summary>
            <param name="taskService">Serviço de tarefas.</param>
            <param name="securityService">Serviço de segurança</param>
            <param name="administrationService">Serviço de administração.</param>
            <param name="reportCode">Código do relatório que será emitido.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ReportComponentTaskSyntax.WithCriteria(Benner.Tecnologia.Common.Criteria)">
            <summary>
            Passa um criteria que será utilizado no filtro do relatório.
            </summary>
            <param name="criteria">Criteria para filtro.</param>
            <returns>Instância de ReportComponentTaskSystax para continuar a configurar a task.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ReportComponentTaskSyntax.WithDefaultFilter">
            <summary>
            Infica se será permitido executar filtros antes da emissão do relatório.
            </summary>
            <returns>Instância de ReportComponentTaskSystax para continuar a configurar a task.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ReportComponentTaskSyntax.WithCompanyFilter">
            <summary>
            Indica se os dados do relatório serão filtrados pela empresa corrente.
            </summary>
            <returns>Instância de ReportComponentTaskSystax para continuar a configurar a task.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ReportComponentTaskSyntax.WithFilter(Benner.Tecnologia.Common.EntityBase)">
            <summary>
            Passa uma entidade de entrada de dados para o relatório.
            </summary>
            <param name="filter">Entidade de entrada de dados.</param>
            <returns>Instância de ReportComponentTaskSystax para continuar a configurar a task.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ReportComponentTaskSyntax.ExportToFormat(System.String)">
            <summary>
            Define o formato que o relatório será emitido.
            </summary>
            <param name="format">Formato da emissão do relatório, exemplo: jpg, pdf.</param>
            <returns>Instância de ReportComponentTaskSystax para continuar a configurar a task.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ReportComponentTaskSyntax.EmitToTemporaryTable">
            <summary>
            Indica se o relatório será emitido para a tabela Z_ARQUIVOSTEMPORARIOS no lugar se de visualizado em tela.
            </summary>
            <returns>Instância de ReportComponentTaskSystax para continuar a configurar a task.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ReportComponentTaskSyntax.SendToMail(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Envia o relatório por e-mail.
            </summary>
            <param name="from">E-mail do remetente.</param>
            <param name="to">E-mail do destinatário.</param>
            <param name="subject">Assunto do e-mail.</param>
            <param name="body">Corpo do e-mail.</param>
            <param name="fileName">Nome do arquivo que representa o relatório que será anexado no e-mail.</param>
            <returns>Instância de ReportComponentTaskSystax para continuar a configurar a task.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ReportComponentTaskSyntax.SendToMail(Benner.Tecnologia.Common.Handle,System.String,System.String,System.String,System.String)">
            <summary>
            Envia o relatório por e-mail.
            </summary>
            <param name="fromSystemUser">Usuário remetente do E-mail.</param>
            <param name="to">E-mail do destinatário.</param>
            <param name="subject">Assunto do e-mail.</param>
            <param name="body">Corpo do e-mail.</param>
            <param name="fileName">Nome do arquivo que representa o relatório que será anexado no e-mail.</param>
            <returns>Instância de ReportComponentTaskSystax para continuar a configurar a task.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ReportComponentTaskSyntax.WithTransitoryData(Benner.Tecnologia.Common.TransitoryData)">
            <summary>
            Adiciona dados transitórios na emissão
            </summary>
            <param name="transitoryData"></param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ReportComponentTaskSyntax.ForceWebMode">
            <summary>
            Força WebMode=true no provider durante a emissão do relatório.
            </summary>
            <returns>Instância de ReportComponentTaskSystax para continuar a configurar a task.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Tasks.ReportComponentTaskSyntax.Start">
            <summary>
            Inicia a tarefa de relatório
            </summary>
            <returns>Objeto BusinessTask&lt;ReportTaskResponse&gt; para controle do processo</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Translator.Idiom">
            <summary>
            Nome da Tabela: Z_IDIOMAS
            </summary>
            <summary>
            Idiom
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Translator.Idiom.FieldNames">
            <summary>
            Possui constantes para retornarem o nome dos campos definidos no Builder para cada propriedade
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Translator.Idiom.Nome">
            <summary>
            Nome (NOME.)
            Opcional = N, Invisível = False, Tamanho = 40
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Translator.IIdiom">
            <summary>
            Interface para a tabela Z_IDIOMAS
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Translator.IIdiom.Nome">
            <summary>
            Nome (NOME.)
            Opcional = N, Invisível = False, Tamanho = 40
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Translator.IIdiomDao">
            <summary>
            Interface para o DAO para a tabela Z_IDIOMAS
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Translator.IdiomDao">
            <summary>
            DAO para a tabela Z_IDIOMAS
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Translator.IdiomTranslation">
            <summary>
            Nome da Tabela: Z_IDIOMATRADUCOES
            </summary>
            <summary>
            IdiomTranslation
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Translator.IdiomTranslation.FieldNames">
            <summary>
            Possui constantes para retornarem o nome dos campos definidos no Builder para cada propriedade
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Translator.IdiomTranslation.Idiom">
            <summary>
            Idioma (IDIOMA.)
            Opcional = N, Invisível = False, Pesquisar = Z_IDIOMAS
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Translator.IdiomTranslation.Original">
            <summary>
            Original (ORIGINAL.)
            Opcional = N, Invisível = False, Tamanho = 250
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Translator.IdiomTranslation.Translated">
            <summary>
            Traduzido (TRADUZIDO.)
            Opcional = N, Invisível = False, Tamanho = 250
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Translator.IIdiomTranslation">
            <summary>
            Interface para a tabela Z_IDIOMATRADUCOES
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Translator.IIdiomTranslation.Original">
            <summary>
            Original (ORIGINAL.)
            Opcional = N, Invisível = False, Tamanho = 250
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Translator.IIdiomTranslation.Translated">
            <summary>
            Traduzido (TRADUZIDO.)
            Opcional = N, Invisível = False, Tamanho = 250
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Translator.IIdiomTranslationDao">
            <summary>
            Interface para o DAO para a tabela Z_IDIOMATRADUCOES
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Translator.IdiomTranslationDao">
            <summary>
            DAO para a tabela Z_IDIOMATRADUCOES
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Translator.JargonTranslation">
            <summary>
            Nome da Tabela: Z_EMPRESATRADUCOES
            </summary>
            <summary>
            JargonTranslation
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Translator.JargonTranslation.FieldNames">
            <summary>
            Possui constantes para retornarem o nome dos campos definidos no Builder para cada propriedade
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Translator.JargonTranslation.Company">
            <summary>
            Empresa (EMPRESA.)
            Opcional = N, Invisível = False, Pesquisar = EMPRESAS
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Translator.JargonTranslation.Original">
            <summary>
            Original (ORIGINAL.)
            Opcional = N, Invisível = False, Tamanho = 250
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Translator.JargonTranslation.Translated">
            <summary>
            Traduzido (TRADUZIDO.)
            Opcional = N, Invisível = False, Tamanho = 250
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Translator.IJargonTranslation">
            <summary>
            Interface para a tabela Z_EMPRESATRADUCOES
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Translator.IJargonTranslation.Original">
            <summary>
            Original (ORIGINAL.)
            Opcional = N, Invisível = False, Tamanho = 250
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Translator.IJargonTranslation.Translated">
            <summary>
            Traduzido (TRADUZIDO.)
            Opcional = N, Invisível = False, Tamanho = 250
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Translator.IJargonTranslationDao">
            <summary>
            Interface para o DAO para a tabela Z_EMPRESATRADUCOES
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Translator.JargonTranslationDao">
            <summary>
            DAO para a tabela Z_EMPRESATRADUCOES
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.ValidationExtensions.BuildValidationExceptionMessage(Microsoft.Practices.EnterpriseLibrary.Validation.ValidationResults,Benner.Tecnologia.Common.EntityDefinition)">
            <summary>
            Monta mensagem de validação da entidade
            </summary>
            <param name="definition">Definilção da entidade</param>
            <param name="validationResults">Resultados de validação</param>
            <returns></returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Validation.EntityValidationResult">
            <summary>
            Representa um dos resultados de uma validação.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.EntityValidationResult.#ctor(System.String)">
            <summary>
            Inicializa este objeto com uma mensagem.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.EntityValidationResult.#ctor(System.String,System.Object,System.String,System.String,Microsoft.Practices.EnterpriseLibrary.Validation.Validator)">
            <summary>
            Inicializa este objeto com uma mensagem e detalhes adicionais.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.EntityValidationResult.#ctor(System.String,System.Object,System.String,System.String,Microsoft.Practices.EnterpriseLibrary.Validation.Validator,System.Collections.Generic.IEnumerable{Microsoft.Practices.EnterpriseLibrary.Validation.ValidationResult})">
            <summary>
            Inicializa este objeto com uma mensagem e detalhes adicionais.
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Validation.Validators.DecimalRangeFieldValidatorAttribute">
            <summary>
            Representa um validador de faixa de valores decimais (valor máximo e mínimo).
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.DecimalRangeFieldValidatorAttribute.#ctor(System.Int64,System.Int64,System.String)">
            <summary>
            Cria uma instância de DecimalRangeFieldValidatorAttribute.
            </summary>
            <param name="lowerBound">Valor mínimo.</param>
            <param name="upperBound">Valor máximo.</param>
            <param name="fieldName">Nome identificador do campo validado.</param>
            <remarks>
            O tipo de valor validado é decimal mas a faixa de valores (máximo e mínimo) 
            precisa ser expressa em inteiros por exigência do .Net Framework (não é possível passar parâmetros decimais para atributos).
            </remarks>
        </member>
        <member name="T:Benner.Tecnologia.Business.Validation.Validators.IFieldValidator">
            <summary>
            Interface implementada por validadores de campos.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Validation.Validators.IFieldValidator.FieldName">
            <summary>
            Nome identificador do campo validado.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.IFieldValidator.GetMessage(System.String)">
            <summary>
            Traduz o texto da propriedade MessageTemplate inserindo o valor de fieldTitle na posição reservada para o título do campo.
            </summary>
            <param name="fieldTitle">Título do campo validado.</param>
            <returns>
            Retorna a tradução do texto da propriedade MessageTemplate, com o valor de fieldTitle já inserido na posição reservada para o título do campo.
            </returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Validation.Validators.IntegerRangeFieldValidatorAttribute">
            <summary>
            Representa um validador de faixa de valores inteiros (valor máximo e mínimo).
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.IntegerRangeFieldValidatorAttribute.#ctor(System.Int64,System.Int64,System.String)">
            <summary>
            Cria uma instância de IntegerRangeFieldValidatorAttribute.
            </summary>
            <param name="lowerBound">Valor mínimo.</param>
            <param name="upperBound">Valor máximo.</param>
            <param name="fieldName">Nome identificador do campo validado.</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.Validation.Validators.RequiredFieldValidator">
            <summary>
            Validador de campos obrigatórios conforme definição no Builder
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Validation.Validators.RequiredFieldValidator.FieldName">
            <summary>
            Nome identificador do campo validado.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.RequiredFieldValidator.GetMessage(System.String)">
            <summary>
            Traduz o texto da propriedade MessageTemplate inserindo o valor de fieldTitle na posição reservada para o título do campo.
            </summary>
            <param name="fieldTitle">Título do campo validado.</param>
            <returns>
            Retorna a tradução do texto da propriedade MessageTemplate, com o valor de fieldTitle já inserido na posição reservada para o título do campo.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.RequiredFieldValidator.#ctor">
            <summary>
            Cria uma instância de RequiredFieldValidator.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.RequiredFieldValidator.#ctor(System.Collections.Generic.List{Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation},Benner.Tecnologia.Common.EntityBase)">
            <summary>
            Cria uma instância de RequiredFieldValidator.
            </summary>
            <param name="manipulatedFieldDefinitions">Definição dos campos para teste (já manipulado, conforme disposição dos campos em tabs)</param>
            <param name="entity">Entidade que será testada.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.RequiredFieldValidator.Validate(Benner.Tecnologia.Common.FieldDefinition,Microsoft.Practices.EnterpriseLibrary.Validation.ValidationResults)">
            <summary>
            Chama a validação de required do campo "fieldValidate"
            </summary>
            <param name="fieldValidate">Definição do campo a ser validado.</param>
            <param name="validationResults">Retorno da validação.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.RequiredFieldValidator.DoValidate(Benner.Tecnologia.Common.FieldDefinition,Microsoft.Practices.EnterpriseLibrary.Validation.ValidationResults)">
            <summary>
            Executa a validação de Required.
            </summary>
            <param name="fieldValidate">Definição do campo a ser validado.</param>
            <param name="validationResults">Retorno da validação.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.RequiredFieldValidator.CheckFieldRequired(Benner.Tecnologia.Common.FieldDefinition)">
            <summary>
            Método que valida se o campo é required conforme definição no Builder e visibilidade em "tabs"
            </summary>
            <param name="fieldToValidate">Definição do campo a ser validado.</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.Validation.Validators.NotNullFieldValidator">
            <summary>
            Validador de campos obrigatórios.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Validation.Validators.NotNullFieldValidator.FieldName">
            <summary>
            Nome identificador do campo validado.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.NotNullFieldValidator.#ctor(System.String)">
            <summary>
            Cria uma instância de NotNullFieldValidator.
            </summary>
            <overloads>
            Cria uma instância de NotNullFieldValidator.
            </overloads>
            <param name="fieldName">Nome identificador do campo a ser validado.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.NotNullFieldValidator.#ctor(System.String,System.String)">
            <summary>
            Cria uma instância de NotNullFieldValidator.
            </summary>
            <param name="fieldName">Nome identificador do campo a ser validado.</param>
            <param name="messageTemplate">Texto com tokens que o validador substitui quando executa uma validação. Este texto geralmente descreve o resultdo da validação.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.NotNullFieldValidator.#ctor(System.Boolean,System.String)">
            <summary>
            Cria uma instância de NotNullFieldValidator.
            </summary>
            <param name="negated">Se verdadeiro, inverte a lógica de validação. O valor padrão é False.</param>
            <param name="fieldName">Nome identificador do campo a ser validado.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.NotNullFieldValidator.#ctor(System.Boolean,System.String,System.String)">
            <summary>
            Cria uma instância de NotNullFieldValidator.
            </summary>
            <param name="negated">Se verdadeiro, inverte a lógica de validação. O valor padrão é False.</param>
            <param name="fieldName">Nome identificador do campo a ser validado.</param>
            <param name="messageTemplate">Texto com tokens que o validador substitui quando executa uma validação. Este texto geralmente descreve o resultdo da validação.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.NotNullFieldValidator.GetMessage(System.String)">
            <summary>
            Traduz o texto da propriedade MessageTemplate inserindo o valor de fieldTitle na posição reservada para o título do campo.
            </summary>
            <param name="fieldTitle">Título do campo validado.</param>
            <returns>
            Retorna a tradução do texto da propriedade MessageTemplate, com o valor de fieldTitle já inserido na posição reservada para o título do campo.
            </returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.NotNullFieldValidator.DoValidate(System.Object,System.Object,System.String,Microsoft.Practices.EnterpriseLibrary.Validation.ValidationResults)">
            <summary>
            Validação
            </summary>
            <param name="objectToValidate">Objeto a validar</param>
            <param name="currentTarget">Instância da classe que possue a propriedade</param>
            <param name="key">Nome da propriedade</param>
            <param name="validationResults">Resultados da validação</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.Validation.Validators.NotNullFieldValidatorAttribute">
            <summary>
            Descreve um <see cref="T:Benner.Tecnologia.Business.Validation.Validators.NotNullFieldValidator"/>.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Validation.Validators.NotNullFieldValidatorAttribute.FieldName">
            <summary>
            Nome identificador do campo validado.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.NotNullFieldValidatorAttribute.#ctor(System.String)">
            <summary>
            Cria uma instância de NotNullFieldValidatorAttribute, que valida campos obrigatórios.
            </summary>
            <param name="fieldName">Nome identificador do campo validado.</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.Validation.Validators.RangeFieldValidator">
            <summary>
            Validador de faixa de valores (valor máximo e mínimo).
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.RangeFieldValidator.#ctor(System.IComparable,System.IComparable,System.String)">
            <summary>
            Cria uma instância de NumericRangeFieldValidator.
            </summary>
            <overloads>
            Cria uma instância de NumericRangeFieldValidator.
            </overloads>
            <param name="lowerBound">Valor mínimo.</param>
            <param name="upperBound">Valor máximo.</param>
            <param name="fieldName">Nome identificador do campo validado.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.RangeFieldValidator.#ctor(System.IComparable,System.IComparable,System.String,System.Boolean)">
            <summary>
            Cria uma instância de NumericRangeFieldValidator.
            </summary>
            <param name="lowerBound">Valor mínimo.</param>
            <param name="upperBound">Valor máximo.</param>
            <param name="fieldName">Nome identificador do campo validado.</param>
            <param name="negated">Se verdadeiro, inverte a lógica de validação. O valor padrão é False.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.RangeFieldValidator.#ctor(System.IComparable,System.IComparable,System.String,System.String)">
            <summary>
            Cria uma instância de NumericRangeFieldValidator.
            </summary>
            <param name="lowerBound">Valor mínimo.</param>
            <param name="upperBound">Valor máximo.</param>
            <param name="fieldName">Nome identificador do campo validado.</param>
            <param name="messageTemplate">Texto com tokens que o validador substitui quando executa uma validação. Este texto geralmente descreve o resultdo da validação.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.RangeFieldValidator.#ctor(System.IComparable,System.IComparable,System.String,System.String,System.Boolean)">
            <summary>
            Cria uma instância de NumericRangeFieldValidator.
            </summary>
            <param name="lowerBound">Valor mínimo.</param>
            <param name="upperBound">Valor máximo.</param>
            <param name="fieldName">Nome identificador do campo validado.</param>
            <param name="messageTemplate">Texto com tokens que o validador substitui quando executa uma validação. Este texto geralmente descreve o resultdo da validação.</param>
            <param name="negated">Se verdadeiro, inverte a lógica de validação. O valor padrão é False.</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.Validation.Validators.RangeFieldValidator`1">
            <summary>
            Validador genérico de faixa de valores (valor máximo e mínimo).
            </summary>
            <typeparam name="T">Tipo do valor a ser validado.</typeparam>
        </member>
        <member name="P:Benner.Tecnologia.Business.Validation.Validators.RangeFieldValidator`1.FieldName">
            <summary>
            Nome identificador do campo validado.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.RangeFieldValidator`1.#ctor(`0,`0,System.String)">
            <summary>
            Cria uma instância de NumericRangeFieldValidator.
            </summary>
            <overloads>
            Cria uma instância de NumericRangeFieldValidator.
            </overloads>
            <param name="lowerBound">Valor mínimo.</param>
            <param name="upperBound">Valor máximo.</param>
            <param name="fieldName">Nome identificador do campo validado.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.RangeFieldValidator`1.#ctor(`0,`0,System.String,System.Boolean)">
            <summary>
            Cria uma instância de NumericRangeFieldValidator.
            </summary>
            <param name="lowerBound">Valor mínimo.</param>
            <param name="upperBound">Valor máximo.</param>
            <param name="fieldName">Nome identificador do campo validado.</param>
            <param name="negated">Se verdadeiro, inverte a lógica de validação. O valor padrão é False.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.RangeFieldValidator`1.#ctor(`0,`0,System.String,System.String)">
            <summary>
            Cria uma instância de NumericRangeFieldValidator.
            </summary>
            <param name="lowerBound">Valor mínimo.</param>
            <param name="upperBound">Valor máximo.</param>
            <param name="fieldName">Nome identificador do campo validado.</param>
            <param name="messageTemplate">Texto com tokens que o validador substitui quando executa uma validação. Este texto geralmente descreve o resultdo da validação.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.RangeFieldValidator`1.#ctor(`0,`0,System.String,System.String,System.Boolean)">
            <summary>
            Cria uma instância de NumericRangeFieldValidator.
            </summary>
            <param name="lowerBound">Valor mínimo.</param>
            <param name="upperBound">Valor máximo.</param>
            <param name="fieldName">Nome identificador do campo validado.</param>
            <param name="messageTemplate">Texto com tokens que o validador substitui quando executa uma validação. Este texto geralmente descreve o resultdo da validação.</param>
            <param name="negated">Se verdadeiro, inverte a lógica de validação. O valor padrão é False.</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.Validation.Validators.RangeFieldValidatorAttribute">
            <summary>
            Classe base para implementação de atributos que representam validadores de faixa de valores (valor máximo e mínimo).
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.RangeFieldValidatorAttribute.#ctor(System.Single,System.Single,System.String)">
            <summary>
            Este construtor não é utilizado pelas classes descendentes mas a classe precisa ter um construtor com tipos CLS-compliant.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.RangeFieldValidatorAttribute.#ctor(System.IComparable,System.IComparable,System.String)">
            <summary>
            Construtor utilizado pelas classes descendentes.
            </summary>
            <param name="lowerBound">Valor mínimo. Informe um tipo numérico (decimal, long) convertido para IComparable.</param>
            <param name="upperBound">Valor máximo. Informe um tipo numérico (decimal, long) convertido para IComparable.</param>
            <param name="fieldName">Nome do campo validado.</param>
        </member>
        <member name="P:Benner.Tecnologia.Business.Validation.Validators.StringLengthFieldValidator.FieldName">
            <summary>
            Nome identificador do campo validado.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.StringLengthFieldValidator.#ctor(System.Int32,System.String)">
            <summary>
            Cria uma instância de StringLengthFieldValidator.
            </summary>
            <overloads>
            Cria uma instância de StringLengthFieldValidator.
            </overloads>
            <param name="upperBound">Tamanho máximo permitido.</param>
            <param name="fieldName">Nome identificador do campo validado.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.StringLengthFieldValidator.#ctor(System.Int32,System.String,System.Boolean)">
            <summary>
            Cria uma instância de StringLengthFieldValidator.
            </summary>
            <param name="upperBound">Tamanho máximo permitido.</param>
            <param name="fieldName">Nome identificador do campo validado.</param>
            <param name="negated">Se verdadeiro, inverte a lógica de validação. O valor padrão é False.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.StringLengthFieldValidator.#ctor(System.Int32,System.String,System.String)">
            <summary>
            Cria uma instância de StringLengthFieldValidator.
            </summary>
            <param name="upperBound">Tamanho máximo permitido.</param>
            <param name="fieldName">Nome identificador do campo validado.</param>
            <param name="messageTemplate">Texto com tokens que o validador substitui quando executa uma validação. Este texto geralmente descreve o resultdo da validação.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.StringLengthFieldValidator.#ctor(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Cria uma instância de StringLengthFieldValidator.
            </summary>
            <param name="upperBound">Tamanho máximo permitido.</param>
            <param name="fieldName">Nome identificador do campo validado.</param>
            <param name="messageTemplate">Texto com tokens que o validador substitui quando executa uma validação. Este texto geralmente descreve o resultdo da validação.</param>
            <param name="negated">Se verdadeiro, inverte a lógica de validação. O valor padrão é False.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.StringLengthFieldValidator.GetMessage(System.String)">
            <summary>
            Traduz o texto da propriedade MessageTemplate inserindo o valor de fieldTitle na posição reservada para o título do campo.
            </summary>
            <param name="fieldTitle">Título do campo validado.</param>
            <returns>
            Retorna a tradução do texto da propriedade MessageTemplate, com o valor de fieldTitle já inserido na posição reservada para o título do campo.
            </returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Validation.Validators.StringLengthFieldValidatorAttribute">
            <summary>
            Descreve um <see cref="T:Benner.Tecnologia.Business.Validation.Validators.StringLengthFieldValidator"/>.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Validation.Validators.StringLengthFieldValidatorAttribute.FieldName">
            <summary>
            Nome identificador do campo validado.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Benner.Tecnologia.Business.Validation.Validators.StringLengthFieldValidatorAttribute.#ctor(System.Int32,System.String)" -->
        <member name="T:Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation">
            <summary>
            Classe auxiliar para validação de campos required.
            É gerada uma lista deste tipo, para facilitar o tratamento.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation.Name">
            <summary> Nome do campo que será validado </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation.Required">
            <summary> Indica se o campo é required, esta propriedade é alterada e testada durante o processo de validação </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation.Visible">
            <summary> Indica se o campo é visible, atualmente não é utilizada visto que LayoutDefinition só tem fields visíveis </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation.IsTabField">
            <summary> Indica se o campo é um tab ligado a dados </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation.IsVirtualField">
            <summary> Indica se o campo é "virtual", ou seja, não existe fisicamente. Ex.: Rotulo, grupo, tab não ligado a dados </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation.FieldInSelectedTab">
            <summary> Indica se o campo esta na tab selecionada </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation.LayoutItem">
            <summary> Associação com a LayoutDefinition para facilitar as buscas </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation.ParentField">
            <summary> Armazena ancestral físico do campo, ou seja, o campo tab ligado a dados, pois os demais são agrupadores lógicos(virtuais) </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation.ImmediateParentField">
            <summary> Armazena ancestral direto do campo independente se é físico ou não </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Validation.Validators.TabFieldCheckValidator">
            <summary>
            Classe auxiliar para validação de campos required.
            Verifica os campos nas tabs e redefine a propriedade required conforme necessário(de acordo com a visibilidade).
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.TabFieldCheckValidator.#ctor(System.Collections.Generic.List{Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation},Benner.Tecnologia.Common.EntityBase)">
            <summary>
            Classe auxiliar para validação de campos required.
            Verifica os campos nas tabs e redefine a propriedade required conforme necessário(de acordo com a tab selecionada).
            </summary>
            <param name="fieldDefinitionListForValidation">Definição de campos que será retornada para a validação</param>
            <param name="entity">Entidade que será realizada a validação dos campos.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.TabFieldCheckValidator.CheckFieldRequired(Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation,System.Collections.Generic.List{System.String}@,System.Boolean)">
            <summary>
            Método que faz o "roteamento" para métodos conforme seus respectivos tipos.
            </summary>
            <param name="fieldForValidation">Campo a ser validado.</param>
            <param name="validatedFields">Lista de campos que já foram validados.</param>
            <param name="justSetRequiredFalse">Flag que indica que sempre será setado required como FALSE devido ao aninhamento de tabs</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.TabFieldCheckValidator.DoCheckTabField(Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation,System.Collections.Generic.List{System.String}@,System.Boolean)">
            <summary>
            Metodo que verifica a obrigatoriedade dos campos conforme definição do Builder e "visibilidade" na(s) TAB(s).
            
            A lógica é a seguinte:
                * Primeiro seta os campos obrigatórios que estão em tabs não visíveis como required false
                * Em seguida seta os campos obrigatórios como required true para a(s) tab(s) visíveis.
            </summary>
            <param name="tabField">Campo tipo TAB(ligado a dados) que será validado.</param>
            <param name="validatedFields">Lista de campos que já foram validados.</param>
            <param name="justSetRequiredFalse">Flag que indica que sempre será setado required como FALSE devido ao aninhamento de tabs</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.TabFieldCheckValidator.DoCheckGroupField(Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation,System.Collections.Generic.List{System.String}@,System.Boolean)">
            <summary>
            Metodo auxiliar para validação de obrigatoriedade de campos.
            Trata campos tipo GRUPO.
            </summary>
            <param name="groupField">Campo tipo grupo que será verificado.</param>
            <param name="validatedFields">Lista de campos que já foram validados.</param>
            <param name="justSetRequiredFalse">Flag que indica que sempre será setado required como FALSE devido ao aninhamento de tabs</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.TabFieldCheckValidator.DoCheckVirtualTabField(Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation,System.Collections.Generic.List{System.String}@,System.Boolean)">
            <summary>
            Metodo auxiliar para validação de obrigatoriedade de campos.
            Trata campos tipo TAB NÃO ligado a dados.
            </summary>
            <param name="virtalTab">Campo tab não ligado a dados que será verificado.</param>
            <param name="validatedFields">Lista de campos que já foram validados.</param>
            <param name="justSetRequiredFalse">Flag que indica que sempre será setado required como FALSE devido ao aninhamento de tabs</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.TabFieldCheckValidator.DoCheckFieldRequired(Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation,System.Collections.Generic.List{System.String}@,System.Boolean)">
            <summary>
            Metodo que verifica a obrigatoriedade do campo conforme definição do Builder e visibilidade em tab/sub-tabs.
            </summary>
            <param name="fieldDefinitionForValidation">Campo que será validado.</param>
            <param name="validatedFields">Lista de campos que já foram validados.</param>
            <param name="justSetRequiredFalse">Flag que indica que sempre será setado required como FALSE devido ao aninhamento de tabs</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.TabFieldCheckValidator.GetFieldDefinitionForValidation(System.String)">
            <summary>
            Pega a tab selecionada.
            </summary>
            <param name="tabField">Campo tab a ser validado.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.TabFieldCheckValidator.GetSelectedTabItem(Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation)">
            <summary>
            Pega a tab selecionada.
            </summary>
            <param name="tabField">Campo tab a ser validado.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.TabFieldCheckValidator.GetNonSelectedTabItems(Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation)">
            <summary>
            Pega a(s) tab(s) não selecionada(s).
            </summary>
            <param name="tabField">Campo tab a ser validado.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.TabFieldCheckValidator.IdentifyFieldsInSelectedTabs">
            <summary>
            Identifica campos na(s) tab(s) ativa(s).
            Os campos que não estão dentro de nenhuma tab tem o FieldInSelectedTab = TRUE, pois, isso facilita a validação posterior.
            Ou seja, todos os campos que estiverem com a propriedade FieldInSelectedTab = TRUE serão obrigatoriamente validados.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Validation.Validators.TabFieldCheckValidator.VerifyFieldInSelectedTab(Benner.Tecnologia.Business.Validation.Validators.FieldDefinitionForValidation,System.String)">
            <summary>
            Verifica se o campo esta na tab ativa/selecionada.
            </summary>
            <param name="tabField">Campo tab a ser validado.</param>
            <param name="fieldName">Nome do campo que será verificado.</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.Cache.BusinessCacheProvider`1">
            <summary>
            Cache de objetos de negócio.
            </summary>
            <typeparam name="T">Tipo do objeto que será armazenado em Cache.</typeparam>
        </member>
        <member name="T:Benner.Tecnologia.Business.Cache.EntityCacheContext">
            <summary>
            Torna um bloco de código parte de um contexto com cache de entidades.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Cache.EntityCacheContext.#ctor">
            <summary>
            Inicializa uma nova instância de <see cref="T:Benner.Tecnologia.Business.Cache.EntityCacheContext"/>.
            </summary>
            <overloads>
            Inicializa uma nova instância de <see cref="T:Benner.Tecnologia.Business.Cache.EntityCacheContext"/>.
            </overloads>
            <remarks>
            Este construtor cria um novo contexto de cache com a opção de cache igual a <see cref="F:Benner.Tecnologia.Common.Cache.EntityCacheContextMode.Default"/>.
            Isto significa que só entidades adicionadas a lista de entidades cacheáveis serão adicionadas em cache.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.Cache.EntityCacheContext.#ctor(Benner.Tecnologia.Common.Cache.EntityCacheContextMode)">
            <summary>
            Inicializa uma nova instância de <see cref="T:Benner.Tecnologia.Business.Cache.EntityCacheContext"/>.
            </summary>
            <param name="entityCacheContextMode">Uma instância do enumerador <see cref="T:Benner.Tecnologia.Common.Cache.EntityCacheContextMode"/> que define a opção de gerenciamento das entidades em cache.</param>
        </member>
        <member name="P:Benner.Tecnologia.Business.Cache.EntityCacheContext.InCachedContext">
            <summary>
            Verifica se já um contexto de cache já foi criado.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Cache.EntityCacheContext.CacheableEntities">
            <summary>
            Retorna a lista das entidades adicionadas para serem cacheadas pelo contexto.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Cache.EntityCacheContext.ClearCache">
            <summary>
            Limpa todas as entidades adicionadas em cache.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Cache.EntityCacheContext.Dispose">
            <summary>
            Finaliza a instância de <see cref="T:Benner.Tecnologia.Business.Cache.EntityCacheContext"/>.
            </summary>
            <remarks>
            Ao ser finalizado o <see cref="T:Benner.Tecnologia.Business.Cache.EntityCacheContext"/> removerá todas as entidades do cache.
            Caso o <see cref="T:Benner.Tecnologia.Business.Cache.EntityCacheContext"/> faça parte de um outro contexto de cache, ao ser finalizado ele não removerá as entidades do cache. O <see cref="T:Benner.Tecnologia.Business.Cache.EntityCacheContext"/> raiz
            será o responsável por remover as entidades do cache.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.Cache.EntityCacheContext.Include(System.String)">
            <summary>
            Inclui uma entidade na lista de entidades que serão cacheadas.
            </summary>
            <param name="entityDefinitionName">Nome da definição de entidade que será adicionada na lista de entidades cacheadas.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Cache.EntityCacheContext.Include(System.Type)">
            <summary>
            Inclui uma entidade na lista de entidades que serão cacheadas.
            </summary>
            <param name="entityType">Tipo da entidade que será adicionada na lista de entidades cacheadas.</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.RawEntityCommand">
            <summary>
            Define uma operação de atualização de entidades em massa.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.RawEntityCommand.#ctor">
            <summary>
            Cria uma instância de <see cref="T:Benner.Tecnologia.Business.RawEntityCommand"/>.
            </summary>
            <overloads>
            Cria uma instância de <see cref="T:Benner.Tecnologia.Business.RawEntityCommand"/>.
            </overloads>
        </member>
        <member name="M:Benner.Tecnologia.Business.RawEntityCommand.#ctor(Benner.Tecnologia.Common.IEntityCommandExecutor,System.String)">
            <summary>
            Cria uma instância de <see cref="T:Benner.Tecnologia.Business.RawEntityCommand"/>.
            </summary>
            <overloads>
            Cria uma instância de <see cref="T:Benner.Tecnologia.Business.RawEntityCommand"/>.
            </overloads>
            <param name="commandExecutor">Executor de comandos</param>
            <param name="commandText">Texto do comando a ser executado.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.RawEntityCommand.#ctor(System.String)">
            <summary>
            Cria uma instância de <see cref="T:Benner.Tecnologia.Business.RawEntityCommand"/>.
            </summary>
            <param name="commandText">Texto do comando a ser executado.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.RawEntityCommand.#ctor(System.String,Benner.Tecnologia.Business.RawEntityCommandType)">
            <summary>
            Cria uma instância de <see cref="T:Benner.Tecnologia.Business.RawEntityCommand"/>.
            </summary>
            <param name="commandText">Texto do comando a ser executado.</param>
            <param name="commandType">Tipo do comando da operação. O valor padrão é Text.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.RawEntityCommand.#ctor(Benner.Tecnologia.Common.IEntityCommandExecutor,System.String,Benner.Tecnologia.Business.RawEntityCommandType)">
            <summary>
            Cria uma instância de <see cref="T:Benner.Tecnologia.Business.RawEntityCommand"/>.
            </summary>
            <param name="commandExecutor">Executor de comandos</param>
            <param name="commandText">Texto do comando a ser executado.</param>
            <param name="commandType">Tipo do comando da operação. O valor padrão é Text.</param>
        </member>
        <member name="P:Benner.Tecnologia.Business.RawEntityCommand.CommandText">
            <summary>
            Comando da operação.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.RawEntityCommand.CommandType">
            <summary>
            Tipo do comando da operação. O valor padrão é Text.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.RawEntityCommand.Parameters">
            <summary>
            Lista de parâmetros de entrada e saída.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.RawEntityCommand.EntitiesAffected">
            <summary>
            Número de entidades afetadas pela operação.
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.RawEntityCommandResult">
            <summary>
            Resultado da execução de uma operação de atualização de entidades em massa.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.RawEntityCommandResult.EntitiesAffected">
            <summary>
            Número de entidades afetadas pela operação.
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.RawEntityCommandType">
            <summary>
            Maneira como um comando de atualização de entidades em massa é interpretado.
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.RawEntityCommandType.Text">
            <summary>
            Texto de um comando SQL.
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.RawEntityCommandType.StoredProcedure">
            <summary>
            Nome de uma stored procedure.
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.ArchitectureServicesRegisterer">
            <summary>
            Registrador de serviços de arquitetura
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ArchitectureServicesRegisterer.Register(Ninject.IKernel)">
            <summary>
            Registro dos serviços de arquitetura do sistema
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessEntityDaosRegisterer">
            <summary>
            Classe para registro das interfaces e implementações de DAO das entidades via Ninject
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessEntityDaosRegisterer.Register(Ninject.IKernel,System.Collections.Generic.IEnumerable{Benner.Tecnologia.Business.BusinessObjectMetadata})">
            <summary>
            Efetua o bind das interfaces e implementações da entidade para o último nível de implementação da mesma.
            </summary>
            <param name="kernel"></param>
            <param name="metadata"></param>
        </member>
        <member name="T:Benner.Tecnologia.Business.EntityFactoryBase">
            <summary>
            Classe base para implementação de factories de entidade.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.EntityFactoryBase.#ctor(Benner.Tecnologia.Common.Layer)">
            <summary>
            Quando implementado na subclasse, cria uma instância do factory de entidades informando em qual camada ele opera.
            </summary>
            <param name="layer">Camada na qual o factory irá operar.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.EntityFactoryBase.Benner#Tecnologia#Common#Services#IEntityFactoryService#CreateBusinessEntityInstance``1(System.String,System.String,System.Boolean)">
            <summary>
            Cria uma instância da classe mais customizada de uma entidade de negócio.
            </summary>
            <typeparam name="T">Tipo que representará a entidade.</typeparam>
            <param name="entityDefinitionName">Nome da definição da entidade para a qual se deseja uma entidade de negócio.</param>
            <param name="systemInstanceName">Nome da instância do sistema.</param>
            <param name="forceAssociatedType">Força a utilização do tipo associado à entidade</param>
            <returns>Retorna uma instância da classe mais customizada; a última herança configurada para o tipo <typeparamref name="T"/>.</returns>
            <remarks>Se não houver customizações configuradas, retorna uma instância de <typeparamref name="T"/>.</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.EntityFactoryBase.ExistsBusinessEntity(System.String,System.String,System.Type)">
            <summary>
            Verifica se existe alguma entidade especialidade para determinada EntityDefinition.
            </summary>
            <param name="entityDefinitionName">Nome da definição da entidade para a qual deseja verificar a existência de uma entidade.</param>
            <param name="systemInstanceName">Nome da instância do sistema.</param>
            <param name="proposedType">Tipo proposto para a definição.</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessLayerEntityFactory">
            <summary>
            Factory de entidades para a camada de negócios.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessLayerEntityFactory.#ctor">
            <summary>
            Constrói um factory de entidades para a camada de negócios (Provider/Runner/BIT)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.PresentationLayerEntityFactory">
            <summary>
            Factory de entidades para a camada de apresentação.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.PresentationLayerEntityFactory.#ctor">
            <summary>
            Constrói um factory de entidades para a camada de apresentação (WES)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.ClientLayerEntityFactory">
            <summary>
            Factory de entidades para a camada de interface no cliente.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ClientLayerEntityFactory.#ctor">
            <summary>
            Constrói um factory de entidades para a camada cliente (Silverlight)
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.PresentationLayerIntegrityValidation">
            <summary>
            Classe resonsável por validar a integridade das entidades na camada de apresentação.
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Interop.DelphiClassAttribute">
            <summary>
            Atributo utilizado para indicar que determinada classe é utilizada pelo Delphi.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Interop.DelphiClassAttribute.CustomName">
            <summary>
            Indica que o tipo a ser gerado no Delphi utilizará o nome alternativo
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Interop.DelphiClassAttribute.#ctor">
            <summary>
            Atributo utilizado para indicar que determinada classe é utilizada no Delphi.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Interop.DelphiClassAttribute.#ctor(System.String)">
            <summary>
            Atributo utilizado para indicar que determinada classe é utilizada no Delphi.
            </summary>
            <param name="customName">Indica que o tipo a ser gerado no Delphi utilizará o nome alternativo</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.Interop.DelphiMethodAttribute">
            <summary>
            Atributo utilizado para indicar que determinado método é utilizado pelo Delphi.
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.MailMessage">
            <summary>
            Classe de envio de emails. Prefira utilizar as abstrações IMailService e IMailMessage
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.MailMessage.InstanceTemporaryFilesPath">
            <summary>
            Lista de arquivos temporários criados durante as operações de anexar arquivos.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.MailMessage.#ctor">
            <summary>
            Construtor que obtem uma nova instância de <see cref="T:Benner.Tecnologia.Business.MailMessage"/>.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.MailMessage.Finalize">
            <summary>
            Finalizador da classe
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.MailMessage.#ctor(Benner.Tecnologia.Common.Handle,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Construtor que obtem uma nova instância de <see cref="T:Benner.Tecnologia.Business.MailMessage"/>.
            Este construtor inicializa a classe com os parâmetros informados.
            </summary>
            <param name="systemUser">Remetente do e-mail que será enviado</param>
            <param name="to">Destinatário(s) do e-mail. Separados por ',' ou ';'</param>
            <param name="subject">Assunto do e-email</param>
            <param name="body">Opcional. Corpo ou mensagem do e-mail que será enviado. Utilizar a propriedade <see cref="P:Benner.Tecnologia.Business.MailMessage.Body"/> para completar o texto da mensagem a ser enviada.</param>
            <param name="bodyIsHtml">Opcional. Se a mensagem deve ser enviada como HTML ou texto puro. Valor padrão é texto puro.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.MailMessage.#ctor(Benner.Tecnologia.Common.Handle,System.String,System.String,System.String,System.Boolean,System.String)">
            <summary>
            Construtor que obtem uma nova instância de <see cref="T:Benner.Tecnologia.Business.MailMessage"/>.
            Este construtor inicializa a classe com os parâmetros informados.
            </summary>
            <param name="systemUser">Remetente do e-mail que será enviado</param>
            <param name="to">Destinatário(s) do e-mail. Separados por ',' ou ';'</param>
            <param name="subject">Assunto do e-email</param>
            <param name="body">Opcional. Corpo ou mensagem do e-mail que será enviado. Utilizar a propriedade <see cref="P:Benner.Tecnologia.Business.MailMessage.Body"/> para completar o texto da mensagem a ser enviada.</param>
            <param name="bodyIsHtml">Opcional. Se a mensagem deve ser enviada como HTML ou texto puro. Valor padrão é texto puro.</param>
            <param name="alternativeBody">Opcional. Corpo ou mensagem alternativo, que sempre será enviado como texto."/> </param>
        </member>
        <member name="P:Benner.Tecnologia.Business.MailMessage.ReplyTo">
            <summary>
            Propriedade para informar o "Reponder para".
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.MailMessage.SendTo">
            <summary>
            Destinatário da mensagem. Se houver mais de um separar com ; (ponto e vírgula).
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.MailMessage.Cc">
            <summary>
            Com cópia para. Se houver mais de um separar com ; (ponto e vírgula).
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.MailMessage.Bcc">
            <summary>
            Cópia oculta. Se houver mais de um separar com ; (ponto e vírgula).
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.MailMessage.Subject">
            <summary>
            Assunto da mensagem.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.MailMessage.Body">
            <summary>
            Corpo da mensagem.
            Se a propriedade IsBodyHtml estiver informada como true, podem existir instruções HTML no corpo da mensagem.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.MailMessage.IsBodyHtml">
            <summary>
            Informe True nesta propriedade se desejar informar um HTML como corpo do e-mail ao invés de informar um texto plano.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.MailMessage.AlternativeBody">
            <summary>
            Corpo alternativo da mensagem em HTML.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.MailMessage.Priority">
            <summary>
            Prioridade do e-mail
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.MailMessage.DeliveryNotificationOptions">
            <summary>
            Define a opção de entrega de notificações por e-mail.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.MailMessage.AddAttachment(System.String)">
            <summary>
            Anexa arquivos à mensagem. 
            Se existir mais de um arquivo desses, deve existir um comando AddAttachment para cada arquivo que se deseja anexar.
            </summary>
            <param name="fileName">
            Nome do arquivo que deseja anexar.
            O arquivo deve ser informado com o caminho completo. Ex.: c:\benner\arquivo.txt
            </param>
        </member>
        <member name="M:Benner.Tecnologia.Business.MailMessage.AddAttachment(System.IO.Stream,System.String)">
            <summary>
            Anexa um novo arquivo à mensagem. O conteúdo do arquivo será o stream.
            Se existir mais de um arquivo desses, deve existir um comando AddAttachment para cada arquivo que se deseja anexar.
            </summary>
            <param name="content">Conteúdo do arquivo</param>
            <param name="fileName">
            Nome do arquivo no anexo.
            </param>
        </member>
        <member name="M:Benner.Tecnologia.Business.MailMessage.AddLinkedResource(System.String)">
            <summary>
            Adiciona uma imagem embarcada para o envio de email. O HTML <see cref="P:Benner.Tecnologia.Business.MailMessage.Body"/> deve conter &lt; img src="cid:nomeImagem" /&gt; para referênciar a imagem no corpo do email.
            </summary>
            <param name="fileName">
            Nome do arquivo que deseja anexar.
            O arquivo deve ser informado com o caminho completo. Ex.: c:\benner\arquivo.txt
            </param>
        </member>
        <member name="M:Benner.Tecnologia.Business.MailMessage.AddLinkedResource(System.IO.Stream,System.String)">
            <summary>
            Adiciona uma imagem embarcada para o envio de email. O HTML <see cref="P:Benner.Tecnologia.Business.MailMessage.Body"/> deve conter &lt; img src="cid:nomeImagem" /&gt; para referênciar a imagem no corpo do email.
            </summary>
            <param name="content">Conteúdo do arquivo</param>
            <param name="resourceName">
            Nome do arquivo
            </param>
        </member>
        <member name="M:Benner.Tecnologia.Business.MailMessage.CopyStreamToNewTemporaryFile(System.IO.Stream,System.String)">
            <summary>
            CRia um novo arquivo a partir de um stream
            </summary>
            <param name="content">Conteúdo do arquivo</param>
            <param name="fileName">Nome do Arquivo</param>
            <returns>Caminho temporário do arquivo criado</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.MailMessage.GetBaseTempPath">
            <summary>
            Retorna um caminho temporário a ser usado por essa instância.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Benner.Tecnologia.Business.MailMessage.RequestReadReceipt">
            <summary>
            Solicita a confirmação de recebimento de leitura do email.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.MailMessage.SystemUser">
            <summary>
             Handle do usuario que será usado a configuração no envio de email e como remetente do email.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.MailMessage.Send">
            <summary>
            Envia a mensagem. 
            Caso o envido do email for imediato, possui um "time out" de 1 minuto, após isso apresentará erro.
            Caso o envio de email for de agendamento, será cadastrado em Z_EMAILS para posterior envio.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.MailMessage.Send(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Envia a mensagem com os parametros informados. O remetente será o usuário atual
            Por padrão o corpo da mensagem é HTML, o parametro opicional isBodyHtml pode alterar isto.
            Se ambos corpos forem informados, ambos serão enviados em partes diferentes, e o parâmetro body será em texto.
            </summary>
            <param name="to">Destinatário(s) do e-mail. Separados por ',' ou ';'</param>
            <param name="subject">Assunto do e-email</param>
            <param name="body">Corpo ou mensagem do e-mail que será enviado.</param>
            <param name="isBodyHtml">Opcional. Se a mensagem deve ser enviada como HTML ou texto puro. Valor padrão é texto puro.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.MailMessage.Send(System.String,System.String,System.String,System.Boolean,System.String)">
            <summary>
            Envia a mensagem com os parametros informados. O remetente será o usuário atual
            Por padrão o corpo da mensagem é HTML, o parametro opicional isBodyHtml pode alterar isto.
            Se ambos corpos forem informados, ambos serão enviados em partes diferentes, e o parâmetro body será em texto.
            </summary>
            <param name="to">Destinatário(s) do e-mail. Separados por ',' ou ';'</param>
            <param name="subject">Assunto do e-email</param>
            <param name="body">Corpo ou mensagem do e-mail que será enviado.</param>
            <param name="alternativeBody">Corpo ou mensagem alternativa do e-mail que será enviado. Opcional, e sempre será enviado como texto.</param>
            <param name="isBodyHtml">Opcional. Se a mensagem deve ser enviada como HTML ou texto puro. Valor padrão é texto puro.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.MailMessage.Send(Benner.Tecnologia.Common.Handle,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Envia a mensagem com os parametros informados. 
            Por padrão o corpo da mensagem é HTML, o parametro opicional isBodyHtml pode alterar isto.
            Se ambos corpos forem informados, ambos serão enviados em partes diferentes, e o parâmetro body será em texto.
            </summary>
            <param name="systemUser">Usuário remetente do e-mail que será enviado</param>
            <param name="to">Destinatário(s) do e-mail. Separados por ',' ou ';'</param>
            <param name="subject">Assunto do e-email</param>
            <param name="body">Corpo ou mensagem do e-mail que será enviado.</param>
            <param name="isBodyHtml">Opcional. Se a mensagem deve ser enviada como HTML ou texto puro. Valor padrão é texto puro.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.MailMessage.Send(Benner.Tecnologia.Common.Handle,System.String,System.String,System.String,System.Boolean,System.String)">
            <summary>
            Envia a mensagem com os parametros informados. 
            Por padrão o corpo da mensagem é HTML, o parametro opicional isBodyHtml pode alterar isto.
            Se ambos corpos forem informados, ambos serão enviados em partes diferentes, e o parâmetro body será em texto.
            </summary>
            <param name="systemUser">Usuário remetente do e-mail que será enviado</param>
            <param name="to">Destinatário(s) do e-mail. Separados por ',' ou ';'</param>
            <param name="subject">Assunto do e-email</param>
            <param name="body">Corpo ou mensagem do e-mail que será enviado.</param>
            <param name="alternativeBody">Corpo alternativo da mensagem. Normalmente texto puro para clientes que não visualizam HTML.</param>
            <param name="isBodyHtml">Opcional. Se a mensagem deve ser enviada como HTML ou texto puro. Valor padrão é texto puro.</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.DeliveryNotificationOptions">
            <summary>
            Opções de entrega de notificações de email.
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.DeliveryNotificationOptions.NoReceipt">
            <summary>
            Nenhuma notificação será enviada. O servidor de mail irá utilizar a sua configuração para determinar se ele deve gerar uma notificação de entrega.
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.DeliveryNotificationOptions.OnDeliverySuccess">
            <summary>
            Notificar se a entrega for bem-sucedida.
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.DeliveryNotificationOptions.OnDeliveryFailure">
            <summary>
            Notificar se a entrega não for bem-sucedida.
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.DeliveryNotificationOptions.OnDeliveryDelay">
            <summary>
            Notificar se atrasar a entrega
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.DeliveryNotificationOptions.OnReadMessage">
            <summary>
            Nunca notifica.
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.MailMessagePriority">
            <summary>
            Enum para definir a prioridade de e-mail
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.MailMessagePriority.Highest">
            <summary>
            Muito alta
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.MailMessagePriority.High">
            <summary>
            Alta
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.MailMessagePriority.Normal">
            <summary>
            Normal
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.MailMessagePriority.Low">
            <summary>
            Baixa
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.MailMessagePriority.Lowest">
            <summary>
            Muito baixa
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.ProcessLog">
            <summary>
            Torna um bloco de código parte de um processo monitorado.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ProcessLog.MainProcess">
            <summary>
            Retorna o processo pai caso ele exista, em cenários de processos aninhados.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ProcessLog.ScheduledProcess">
            <summary>
            Retorna o agendamento que deu origem ao processamento.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ProcessLog.Message">
            <summary>
            Mensagem informativa do status do processo.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ProcessLog.Aborting">
            <summary>
            Verifica se o cancelamento do processo foi solicitado.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ProcessLog.AbortUser">
            <summary>
            Retorna o nome do Usuário que solicitou o cancelamento do processo.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ProcessLog.Handle">
            <summary>
            Handle do processo. Pode retornar nulo se ainda não foi executado o Start.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ProcessLog.#ctor(Benner.Tecnologia.Common.Tasks.IProcessLogService)">
            <summary>
            Construtor que recebe o serviço. Utilizado para testes.
            </summary>
            <param name="processLogService">Serviço do ProcessLog</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.ProcessLog.#ctor">
            <summary>
            Inicializa uma nova instância de <see cref="T:Benner.Tecnologia.Business.ProcessLog"/>
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ProcessLog.Start(System.String,System.Int32,System.Int32)">
            <summary>
            Inicia um novo processo monitorado. Pode ser chamado mais de uma vez para atualizar informações passadas.
            </summary>
            <param name="processLogName">Nome do processo que será mostrado no monitor de processos.</param>
            <param name="startValue">Valor inicial para controle do progresso do processo.</param>
            <param name="endValue">Valor final para controle do progresso do processo.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.ProcessLog.Update(System.Int32,System.Int32)">
            <summary>
            Atualiza um processo monitorado sem informar o nome, apenas o valor final e inicial. Só pode ser utilizado se o processo já foi iniciado (método Start) ou foi disparado pelo BTL ou BServer.
            </summary>
            <param name="startValue">Valor inicial para controle do progresso do processo</param>
            <param name="endValue">Valor final para controle do progresso do processo</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.ProcessLog.Abort(System.String)">
            <summary>
            Aborta um processo monitorado.
            </summary>
            <param name="message">Mensagem descritiva com o motivo pelo qual o processo foi abortado.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.ProcessLog.IncreaseProgress">
            <summary>
            Aumenta automaticamente o progresso do processo. Esta operação só é efetivada a cada 3 segundos. 
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ProcessLog.IncreaseProgress(System.String)">
            <summary>
            Aumenta automaticamente o progresso do processo. Esta operação só é efetivada a cada 3 segundos. 
            </summary>
            <param name="message">Mensagem informativa do status do processo</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.ProcessLog.IncreaseProgress(System.Int32)">
            <summary>
            Aumenta o progresso do processo de acordo com <paramref name="increaseBy"/>. Esta operação só é efetivada a cada 3 segundos.
            </summary>
            <param name="increaseBy">O número de posições a incrementar</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.ProcessLog.IncreaseProgress(System.Int32,System.String)">
            <summary>
            Aumenta o progresso do processo de acordo com <paramref name="increaseBy"/>. Esta operação só é efetivada a cada 3 segundos.
            </summary>
            <param name="increaseBy">O número de posições a incrementar</param>
            <param name="message">Mensagem informativa do status do processo</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.ProcessLog.Complete">
            <summary>
            Finaliza com sucesso um processo caso o método Complete ou CompleteWithError tenha sido chamado pela implementação
            da interface IProcessLogService.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ProcessLog.CompleteWithError(System.String)">
            <summary>
            Finaliza com erro um processo.
            </summary>
            <param name="message">Mensagem descritiva com o motivo pelo qual o processo foi finalizado com erro.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.ProcessLog.Dispose(System.Boolean)">
            <summary>
            Finaliza o contexto do ProcessLog
            </summary>
            <param name="disposing">Se é uma chamada explícita do Dispose</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.ProcessLog.Finalize">
            <summary>
            Garante a finalização correta do contexto do ProcessLog
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ProcessLog.Dispose">
            <summary>
            Finaliza o contexto do ProcessLog
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Query">
            <summary>
            Define e manipula uma query complexa (QuerySources) que retorna entidades base (EntityBase). Consultas feitas com esta classe nunca executam regra de negócio.
            </summary>
            <remarks>
            Define e manipula uma query complexa (QuerySources) que retorna entidades base (EntityBase), caso o retorno desejado
            seja uma entidade especializada é necessário informar o tipo da entidade no parâmetro &lt;T&gt;
            
            <seealso cref="T:Benner.Tecnologia.Business.Query`1"/>
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.Query.#ctor">
            <summary>
            Construtor padrão
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Query.#ctor(System.String)">
            <summary>
            Construtor já inicializando o texto da query
            </summary>
            <param name="commandText">Query SQL</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Query.#ctor(System.String,Benner.Tecnologia.Common.Parameter[])">
            <summary>
            Construtor já inicializando o texto da query e seus parâmetros
            </summary>
            <param name="commandText">Query SQL</param>
            <param name="parameters">Parâmetros da consulta SQL</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.Query`1">
            <summary>
            Define e manipula uma query complexa (QuerySources). Consultas feitas com esta classe nunca executam regra de negócio.
            </summary>
            <remarks>
            Esta classe foi criada no BEF 13.0 para auxiliar no gerenciamento e manipulação da execução de queries complexas
            
            Através da Query&lt;T&gt; é possível obter como retorno de consultas coleções de entidades especializadas que são 
            definidas no parâmetro de tipo: &lt;T&gt;
            </remarks>
            <seealso cref="T:Benner.Tecnologia.Business.Query"/>
            <typeparam name="T">Tipo da entidade que será manipulada pela query</typeparam>
        </member>
        <member name="P:Benner.Tecnologia.Business.Query`1.CommandText">
            <summary>
            Texto do comando SQL
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Query`1.Parameters">
            <summary>
            Parâmetros do comando SQL
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Query`1.#ctor">
            <summary>
            Construtor padrão
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Query`1.#ctor(Benner.Tecnologia.Common.EntityDefinition)">
            <summary>
            Construtor já inicializando a definição de entidade
            </summary>
            <param name="entityDefinition">Definição da entidade que será utilizada</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Query`1.#ctor(Benner.Tecnologia.Common.EntityDefinition,Benner.Tecnologia.Common.Parameter[])">
            <summary>
            Construtor já inicializando a definição de entidade e seus parâmetros
            </summary>
            <param name="entityDefinition">Definição da entidade que será utilizada</param>
            <param name="parameters">Parâmetros da consulta SQL</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Query`1.#ctor(System.String)">
            <summary>
            Construtor já inicializando o texto da query
            </summary>
            <param name="commandText">Query SQL</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Query`1.#ctor(System.String,Benner.Tecnologia.Common.Parameter[])">
            <summary>
            Construtor já inicializando o texto da query e seus parâmetros
            </summary>
            <param name="commandText">Query SQL</param>
            <param name="parameters">Parâmetros da consulta SQL</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.Query`1.Execute">
            <summary>
            Executa a consulta definida na definição de entidade carregando todas as entidades em memória
            </summary>
            <returns>Retorna uma lista Entities&lt;T&gt; com todas as entidades em memória</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Query`1.Fetch">
            <summary>
            Executa a consulta retornando as entidades sob demanda 
            </summary>
            <returns>IEnumerable&lt;T&gt; para percorrer as entidades</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Query`1.Append(System.String)">
            <summary>
            Adiciona SQL ao final do CommandText da query
            </summary>
            <param name="commandText">SQL que será adicionado ao final do CommandText atual</param>
            <returns>A própria Query</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Query`1.AppendLine(System.String)">
            <summary>
            Adiciona SQL ao final do CommandText da query com uma quebra de linha
            </summary>
            <param name="commandText">SQL que será adicionado ao final do CommandText atual</param>
            <returns>A própria Query</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Query`1.AddParameter(Benner.Tecnologia.Common.Parameter)">
            <summary>
            Adiciona um parâmetro à query
            </summary>
            <param name="parameter">Instância de parâmeter</param>
            <returns>A própria Query</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.IBusinessReportService">
            <summary>
            Complementa na camada de negócios a interface do serviço de emissão de relatórios.
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.ReportPrinter">
            <summary>
            Emite relatórios.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ReportPrinter.#ctor(Benner.Tecnologia.Common.Handle)">
            <summary>
            Obtém uma instância de <see cref="T:Benner.Tecnologia.Business.ReportPrinter"/>.
            </summary>
            <param name="reportHandle">Identificador do relatório a ser emitido.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.ReportPrinter.#ctor(System.String)">
            <summary>
            Obtém uma instância de <see cref="T:Benner.Tecnologia.Business.ReportPrinter"/>.
            </summary>
            <param name="reportCode">Código do relatório a ser emitido.</param>
        </member>
        <member name="P:Benner.Tecnologia.Business.ReportPrinter.SessionVars">
            <summary>
            Coleção de parâmetros utilizados na macro de relatório através de SessionVar
            </summary>
            <remarks>
            Estes parâmetros são atribuidos à SessionVar no momento de disparo do relatório.
            </remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.ReportPrinter.ReportHandle">
            <summary>
            Retorna o <see cref="T:Benner.Tecnologia.Common.Handle"/> que identifica o relatório emitido. 
            Este valor deve ser passado como parâmetro ao construtor da classe.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ReportPrinter.SqlWhere">
            <summary>
            Condições que devem ser concatenadas à cláusula WHERE da query do relatório.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ReportPrinter.CanFilter">
            <summary>
            Define se será permitido executar um filtro para o relatório antes da emissão. O valor padrão é true.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ReportPrinter.CanSetupPrint">
            <summary>
            Define se deve ser mostrada a tela de configuração da impressora. O valor padrão é true.
            </summary>
            <remarks>
             Se false, o relatório será enviado para a impressora definida na propriedade DefaultPrinterName ou para a impressora padrão do Windows.
            </remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.ReportPrinter.FilterByCurrentCompany">
            <summary>
            Define se os dados do relatório devem ser filtrados pela empresa corrente. O valor padrão é true.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ReportPrinter.DefaultPrinterName">
            <summary>
            Permite sugerir a impressora na qual o relatório deve ser impresso.
            </summary>
            <remarks>
            É possível informar apenas uma parte do nome da impressora. Por exemplo: "HP" em vez de "HP LaserJet". 
            Se não for encontrada uma impressora com nome correspondente, o relatório será impresso na impressora padrão do usuário.
            </remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.ReportPrinter.RaiseExceptionOnError">
            <summary>
            Define se devem ser mantidas as exceções, de macro ou do próprio gerador de relatórios, levantadas durante a emissão do relatório. O valor padrão é false.
            </summary>
            <remarks>
            Sete este parâmetro para true caso queira tratar os erros do relatório no método chamador.
            </remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.ReportPrinter.TransitoryData">
            <summary>
            Define somente o TransitoryData usado para adicionar TransitoryVars
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ReportPrinter.TransitoryVars">
            <summary>
            Expõe o TransitoryVars.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ReportPrinter.Print">
            <summary>
            Envia o relatório para a impressora.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ReportPrinter.Preview">
            <summary>
            Envia o relatório para a tela do usuário.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ReportPrinter.ExportToFile(System.String)">
            <summary>
            Envia o relatório para arquivo.
            </summary>
            <param name="fileName">
            Nome do arquivo do relatório exportado. 
            A extensão informada no nome do arquivo determina o formato do arquivo gerado.
            </param>
        </member>
        <member name="M:Benner.Tecnologia.Business.ReportPrinter.SendMail(System.String,System.String,System.String,System.String)">
            <summary>
            Envia o relatório por e-mail. A extensão do nome de arquivo informado no parâmetro FileName define o formato do relatório enviado por e-mail.
            </summary>
            <param name="mailRecipients">Lista de endereços de e-mails destinatários, separados por vírgula.</param>
            <param name="mailSubject">Assunto do e-mail.</param>
            <param name="mailBody">Corpo do e-mail.</param>
            <param name="fileName">Nome de arquivo do relatório gerado. A extensão do nome do arquivo determina o formato do relatório exportado.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.ReportPrinter.SendMail(Benner.Tecnologia.Common.Handle,System.String,System.String,System.String,System.String)">
            <summary>
            Envia o relatório por e-mail. A extensão do nome de arquivo informado no parâmetro FileName define o formato do relatório enviado por e-mail.
            </summary>
            <param name="mailRecipients">Lista de endereços de e-mails destinatários, separados por vírgula.</param>
            <param name="mailSubject">Assunto do e-mail.</param>
            <param name="mailBody">Corpo do e-mail.</param>
            <param name="fileName">Nome de arquivo do relatório gerado. A extensão do nome do arquivo determina o formato do relatório exportado.</param>
            <param name="fromSystemUser">Handle do usuário que será usado como remetente e autenticação no envio do email</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.ReportPrinter.GetTransitoryData">
            <summary>
            Cria um TransitoryData com as SessionVars
            </summary>
            <returns>Instância de TransitoryData</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.AdministrationServiceConfigurationNotFound">
            <summary>
              Looks up a localized string similar to A seção administrationServiceConfiguration do arquivo de configuração não foi encontrada..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.BennerConfigurationNotFound">
            <summary>
              Looks up a localized string similar to A seção bennerConfiguration do arquivo de configuração não foi encontrada..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.BusinessExceptionDefaultMessage">
            <summary>
              Looks up a localized string similar to As configurações ou os dados entrados pelo usuário são inconsistentes..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.CannotSort">
            <summary>
              Looks up a localized string similar to Não é possível ordenar {0} por {1}..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.CreateEntityServiceError">
            <summary>
              Looks up a localized string similar to Não foi possível criar um objeto do serviço de dados..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.DeserializationContentRequired">
            <summary>
              Looks up a localized string similar to O conteúdo a ser deserializado é obrigatório..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.DictionaryKeyNotFound">
            <summary>
              Looks up a localized string similar to A chave &quot;{0}&quot; não estava presente no dicionário..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.EntityAssociationNeedsTargetEntity">
            <summary>
              Looks up a localized string similar to Uma instância de EntityAssociation necessita uma instância de TargetEntity..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.EntityDefinitionDeserializationError">
            <summary>
              Looks up a localized string similar to Não foi possível deserializar a definição da entidade..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.EntityDefinitionNotFound">
            <summary>
              Looks up a localized string similar to Não foi encontrada a definição de entidade de nome &quot;{0}&quot;..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.EntityFieldNotFound">
            <summary>
              Looks up a localized string similar to Campo &quot;{0}&quot; não encontrado na lista de campos da entidade..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.EntityNotFound">
            <summary>
              Looks up a localized string similar to Não foi encontrada uma entidade que atenda aos critérios especificados..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.EntityNotFoundNameSourceWhere">
            <summary>
              Looks up a localized string similar to Registro não encontrado em &quot;{0}&quot; com o critério &quot;{1}&quot;..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.EntityNotInitialized">
            <summary>
              Looks up a localized string similar to A entidade não foi inicializada..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.EntityPersistenceError">
            <summary>
              Looks up a localized string similar to Problema durante operação de persistência de entidade..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.EntitySaveException">
            <summary>
              Looks up a localized string similar to Erro ao salvar a entidade..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.EntityServiceConfigurationNotFound">
            <summary>
              Looks up a localized string similar to A seção entityServiceConfiguration do arquivo de configuração não foi encontrada..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.EntityServiceNameNotFound">
            <summary>
              Looks up a localized string similar to O nome do EntityService não foi localizado na seção entityServiceConfiguration da configuração do aplicativo..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.EntityViewFieldIncorrectFieldName">
            <summary>
              Looks up a localized string similar to O nome do campo que está sendo atribuído deve ser igual ao nome do campo da camada anterior..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.EntityViewSaveException">
            <summary>
              Looks up a localized string similar to Erro ao salvar a visão de entidade..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.EntityWasDeleted">
            <summary>
              Looks up a localized string similar to A entidade foi excluída..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.FromUIError">
            <summary>
              Looks up a localized string similar to Erro ao tentar converter o valor &apos;{0}&apos; para o campo {1}: {2}.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.FromUIErrorExpectedFormat">
            <summary>
              Looks up a localized string similar to Erro ao tentar converter o valor &apos;{0}&apos; para o campo {1}. O formato esperado era &apos;{2}&apos;. {3}.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.HandleExpected">
            <summary>
              Looks up a localized string similar to Um Handle era esperado..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.ImportActionErrorMessage">
            <summary>
              Looks up a localized string similar to Erro ao inserir/alterar {0}: {1}.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.InvalidHandle">
            <summary>
              Looks up a localized string similar to Handle deve ser um valor inteiro não negativo..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.InvalidImportCastMessage">
            <summary>
              Looks up a localized string similar to Parâmetro &apos;portableDictionary&apos; deve ser do tipo &apos;SerializableDictionary&lt;String, {1}&gt;&apos;.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.InvalidLanguageIdentifier">
            <summary>
              Looks up a localized string similar to Identificador de linguagem inválido..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.InvalidStateForDeletion">
            <summary>
              Looks up a localized string similar to Estado da entidade inválido para exclusão..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.InvalidStateForEdition">
            <summary>
              Looks up a localized string similar to Estado da entidade inválido para edição..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.InvalidStateForRefreshing">
            <summary>
              Looks up a localized string similar to Estado da entidade inválido para atualização..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.KeyNotFoundInFieldsCollection">
            <summary>
              Looks up a localized string similar to A entidade &quot;{0}&quot; possui definição para o campo &quot;{1}&quot; mas este campo não foi encontrado na coleção &quot;Fields&quot;..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.LdapDomainNotFound">
            <summary>
              Looks up a localized string similar to O nome do domínio não foi localizado na seção securityConfiguration da configuração do aplicativo..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.LdapPathNotFound">
            <summary>
              Looks up a localized string similar to O caminho ldap não foi localizado na seção securityConfiguration da configuração do aplicativo..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.MaxLenghtFieldValidationMessage">
            <summary>
              Looks up a localized string similar to O tamanho máximo do campo &quot;{2}&quot; é {5} caracteres..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.MixedLanguagesInScriptSet">
            <summary>
              Looks up a localized string similar to A linguagem {0} está sendo utilizada no mesmo conjunto de scripts que a linguagem {1}. Uma única linguagem deve ser utilizada em cada conjunto de scripts. Entidade:&apos;{2}&apos;; Visão:&apos;{3}&apos;; Camada:&apos;{4}&apos;..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.NoConnectionString">
            <summary>
              Looks up a localized string similar to Connection string não encontrada..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.NoEntityService">
            <summary>
              Looks up a localized string similar to Não há EntityService configurado correspondente ao tipo informado..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.NoScriptSet">
            <summary>
              Looks up a localized string similar to Não foi carregada uma coleção de scripts para execução..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.NotImplemented">
            <summary>
              Looks up a localized string similar to Operação não implementada..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.NotInEditMode">
            <summary>
              Looks up a localized string similar to A entidade não está em modo de edição..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.NotNullFieldValidationMessage">
            <summary>
              Looks up a localized string similar to O campo &quot;{2}&quot; é obrigatório..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.NotSupportedEntitySource">
            <summary>
              Looks up a localized string similar to A origem de dados utilizada não é suportada nesta operação..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.NullEntityDefinition">
            <summary>
              Looks up a localized string similar to A definição de entidade deve ser preenchida..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.NullEntitySource">
            <summary>
              Looks up a localized string similar to A origem da entidade deve ser preenchida..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.ProviderEntityServiceEndPointRequired">
            <summary>
              Looks up a localized string similar to providerEntityServiceEndPoint é de preenchimento obrigatório..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.RangeValidationMessage">
            <summary>
              Looks up a localized string similar to O valor do campo &quot;{2}&quot; precisa estar entre {3} e {5}..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.RoleNotFoundInCache">
            <summary>
              Looks up a localized string similar to Papel &apos;{0}&apos; não encontrado no cache de papéis..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.SamlConfiguration_ConfigSectioLoadError">
            <summary>
              Looks up a localized string similar to Ocorreu um erro ao carregar o seção de configuração WcfSaml..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.SamlConfiguration_ConfigSectionNotFound">
            <summary>
              Looks up a localized string similar to A seção WcfSaml do arquivo de configuração não foi encontrada..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.SamlTokenConfiguration_TrustIssue">
            <summary>
              Looks up a localized string similar to http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Issue.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.ScriptCallPreparationError">
            <summary>
              Looks up a localized string similar to Erro preparando a chamada de um script..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.ScriptEngineRequired">
            <summary>
              Looks up a localized string similar to Deve ser especificado um objeto de mecanismo de script..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.ScriptExecutionError">
            <summary>
              Looks up a localized string similar to Erro na execução de um script..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.ScriptFunctionRequired">
            <summary>
              Looks up a localized string similar to Deve ser informado o nome da função de script a ser executada..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.ScriptParametersRequired">
            <summary>
              Looks up a localized string similar to Deve ser especificado um objeto de parâmetros de script..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.ScriptScopeRequired">
            <summary>
              Looks up a localized string similar to Deve ser especificado um objeto de escopo de script..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.ScriptServiceError">
            <summary>
              Looks up a localized string similar to Ocorreu um erro durante a utilização do mecanismo de scripts..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.ScriptSetExecutionError">
            <summary>
              Looks up a localized string similar to Ocorreu um erro ao tentar executar um ou mais scripts..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.SelectMethodNotFound">
            <summary>
              Looks up a localized string similar to Não foi encontrado um método Select com parâmetros {0} em {1}.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.SystemInstanceNameRequired">
            <summary>
              Looks up a localized string similar to O nome da instância de sistema deve ser informado..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.TableSourceString">
            <summary>
              Looks up a localized string similar to sistema {0}, tabela {1}.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.TaskNotFoundInCache">
            <summary>
              Looks up a localized string similar to Tarefa {0} não encontrada no cache de tarefas..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.TooManyRows">
            <summary>
              Looks up a localized string similar to A quantidade de registros encontrada não é suportada..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.TransactionContextAlreadyCompleted">
            <summary>
              Looks up a localized string similar to O TransactionContext atual já foi concluído..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.TransactionContextNotDisposed">
            <summary>
              Looks up a localized string similar to A transação foi abortada porque uma instância de TransactionContext não foi finalizada por seu método Dispose. Utilize TransactionContext apenas em blocos &quot;using&quot;..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.UnexpectedEntityState">
            <summary>
              Looks up a localized string similar to A entidade está em um estado que não era esperado..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.ViewDefinitionDeserializeEmptyContentMessage">
            <summary>
              Looks up a localized string similar to O conteúdo a ser deserializado não foi informado ou está vazio..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.ViewDefinitionDeserializeErrorMessage">
            <summary>
              Looks up a localized string similar to Erro na deserialização de uma definição de componente..
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Resources.ViewDefinitionDeserializeNullMessage">
            <summary>
              Looks up a localized string similar to Não foi possível deserializar a definição de componente..
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessException">
            <summary>
            Exceção lançada pelos objetos de negócio quando as configurações ou os dados entrados pelo usuário são inconsistentes.
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessObjectConfigurationToBusinessObjectMetadataConverter">
            <summary>
            Classe responsável por converter uma lista de entidades do tipo BusinessObjectConfiguration em uma lista de 
            BusinessObjectMetadata que é utilizado no cache do factory de entidades.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessObjectConfigurationToBusinessObjectMetadataConverter.#ctor(System.Collections.Generic.IEnumerable{Benner.Tecnologia.Business.BusinessObjectConfiguration})">
            <summary>
            Construtor que recebe a lista de BusinessObjectConfiguration que será convertida.
            </summary>
            <param name="entities">Coleção de BusinessObjectConfiguration que será convertida para uma coleção de de BusinessObjectMetadata.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.BusinessObjectConfigurationToBusinessObjectMetadataConverter.Convert">
            <summary>
            Converte a coleção de BusinessObjectConfiguration em uma coleção de BusinessObjectMetadata.
            </summary>
            <returns>Coleção de BusinessObjectMetadata.</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessObjectMetadata">
            <summary>
            Classe com os metadados de Z_OBJETOSNEGOCIO
            É utilizada no Factory de entidades
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.BusinessObjectConfiguration">
            <summary>
            Representa uma entidade de Z_OBJETOSNEGOCIO.
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.FactoryDictionary">
            <summary>
            Mantém uma lista de objetos de negócio que especializam entidades e uma lista de tipos que customizam objetos de negócio.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.FactoryDictionary.#ctor">
            <remarks>
            SMSs:
            - 501991: W_ENTIDADES tem uma entidade especializada fixa "EntityDefinitionRecord".
            - 501991: W_ENTIDADEVISOES tem uma entidade especializada fixa "EntityViewRecord".
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.FactoryDictionary.AddDefaultFactoryDictionary">
            <summary>
            Adiciona os tipos padrões da ferramenta. Necessário chamar após criar o FactoryDictionary para evitar stack overflow 
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.FactoryDictionary.ResolvedDictionary">
            <summary>
            Lista de tipos resolvidos pelo Factory.
            Para cada tipo de objeto de negócio ou interface de negócio na chave terá o objeto mais customizado no dicionario.
            Lista (Tipo do objeto de negócio, tipo que customiza o objeto de negócio).
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.FactoryDictionary.Specialization">
            <summary>
            Lista (Nome de definição de entidade, tipo que especializa a entidade).
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.FactoryDictionary.Association">
            <summary>
            Lista (Nome de definição de entidade, tipo que especializa a entidade) desconsiderando o flag "Executar entidade especializada".
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.Factory">
            <summary>
            Provê métodos para instância de objetos de negócio considerando suas customizações.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Factory.Layer">
            <summary>
            Determina em qual camada do BEF a operação está executando.
            </summary>
            <remarks>
            <para>
            Se uma entidade foi especializada, o assembly contendo a classe que a especializa 
            precisa estar presente na camada de negócio ou deve ser lançada uma exceção. 
            Já nas camadas de apresentação e interface, a presença do assembly é uma opção do desenvolvedor 
            caso ele pretenda pré-executar alguma regra de negócio nestas camadas (alguma validação, por exemplo).
            </para><para>
            Como toda regra de negócio necessária à integridade do negócio precisa obrigatoriamente ser executada 
            também na camada de negócio, é apenas nesta camada que o assembly é exigido pelo Factory. Nas demais camadas 
            algumas regras da entidade de negócio podem estar presentes como facilitador ou para efeito de melhor performance.
            </para><para>
            A exigência do assembly, então, é determinada pelo valor desta proprieade.
            </para>
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.Factory.CheckSystemFactoryCache(System.String)">
            <summary>
            Verifica se o cache está inicializado.
            </summary>
            <remarks>Se o cache não estiver inicializado, faz a inicialização.</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.Factory.GetCustomizedType(System.String,System.Type)">
            <summary>
            Procura o tipo que customiza um objeto de negócio.
            </summary>
            <param name="systemInstanceName">Nome da instância do sistema.</param>
            <param name="type">Tipo para o qual será procurada a customização.</param>
            <returns>Retorna o tipo da classe mais customizada (o último nível de customização) para o objeto de negócio cujo tipo foi informado em <paramref name="type"/>.</returns>
            <remarks>
            Um objeto de negócio pode ter diversos níveis de customização.
            Este método inclui no cache todas as customizações encontradas, e cada uma delas aponta para a customização do último nível. 
            Se nenhuma customização for encontrada, retorna o próprio parâmetro <paramref name="type"/>.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.Factory.GetSpecializedType(System.String,System.String,System.Type)">
            <summary>
            Procura o tipo que especializa uma entidade.
            </summary>
            <param name="systemInstanceName">Nome da instância do sistema.</param>
            <param name="entityDefinitionName">Nome da definição da entidade.</param>
            <param name="defaultType">Se não houver especialização configurada, será considerado este defaultType como sendo o tipo que especializa a entidade.</param>
            <returns>Retorna o tipo que especializa a entidade. Se não houver especialização configurada, retorna <paramref name="defaultType"/>.</returns>
            <remarks>
            Este método inclui no cache: ou o tipo configurado para especialização da entidade, ou o valor do parâmetro defaultType caso não exista especialização configurada.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.Factory.GetAssociatedType(System.String,System.String)">
            <summary>
            Obtém, da configuração, o tipo que especializa a entidade adicionando-o no cache sem considerar o Flag "Executar entidade especializada".
            </summary>
            <param name="systemInstanceName">Nome da instância do sistema</param>
            <param name="entityDefinitionName">Nome da definição da entidade</param>
            <returns>Retorna  tipo que especializa a entidade adicionando-o no cache sem considerar o Flag "Executar entidade especializada". Se não houver especialização associada retorna o tipo EntityBase.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Factory.AddToCustomizationList(System.Collections.Generic.Dictionary{System.Type,System.Type},System.Type)">
            <summary>
            Adiciona ao cache as customizações de um objeto de negócio.
            </summary>
            <param name="list">Lista que constitui o cache de customizações.</param>
            <param name="key">Tipo a partir do qual serão procuradas as customizações.</param>
            <remarks>
            A lista informada no parâmetro list será preenchida da seguinte maneira: todas as customizações encontradas apontarão para a customização de nível mais alto.
            Se não for encontrada nenhuma customização para o tipo passado no parâmetro key, ele será adicionado na lista apontando para si mesmo.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.Factory.GetAssociatedTypeFromMetadata(System.String)">
            <summary>
            Obtém, da configuração, o tipo que especializa a entidade.
            </summary>
            <param name="entityDefinitionName">Nome da definição da entidade.</param>
            <returns>Retorna o tipo que especializa a entidade (não sua customização, mas apenas o primeiro nível).</returns>
            <remarks>
            Se não houver tipo configurado, retorna o tipo EntityBase.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.Factory.IsSpecializedEntity(System.String,System.String)">
            <summary>
            Verifica se uma entidade foi especializada por um objeto de negócio.
            </summary>
            <param name="systemInstanceName">Nome da intância do sistema.</param>
            <param name="entityDefinitionName">Nome da definição de entidade.</param>
            <returns>Retorna verdadeiro se a configuração determinar que a entidade foi especializada.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Factory.IsExceptionEntity(System.String)">
            <summary>
            Verifica se a entidade é uma exceção para o Factory.
            </summary>
            <param name="entityDefinitionName">Nome da definição da entidade.</param>
            <returns>Retorna verdadeiro se a entidade pertencer a uma lista de entidades não customizáveis.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Factory.SetBusinessLayer">
            <summary>
            Configura o Factory de entidades do BEF para camada Business
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Factory.SetPresentationLayer">
            <summary>
            Configura o Factory de entidades do BEF para camada Presentation
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Factory.SetClientLayer">
            <summary>
            Configura o Factory de entidades do BEF para camada Client/Silverlight
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Factory.CreateEntityInstance(System.Type)">
            <summary>
            Cria uma instância de entidade conforme o tipo especificado
            </summary>
            <param name="entityType">Tipo da entidade</param>
            <returns>Instância da entidade</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.Factory.CreateBusinessEntityInstance``1(System.String,System.String)">
            <summary>
            Cria uma instância da classe mais customizada de uma entidade de negócio.
            </summary>
            <typeparam name="T">Tipo que representará a entidade de negócio.</typeparam>
            <param name="entityDefinitionName">Nome da definição da entidade para a qual se deseja uma entidade de negócio.</param>
            <param name="systemInstanceName">Nome da instância do sistema.</param>
            <returns>Retorna uma instância da classe mais customizada; a última herança configurada para o tipo <typeparamref name="T"/>.</returns>
            <remarks>Se não houver customizações configuradas, retorna uma instância de <typeparamref name="T"/>.</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.Factory.CreateBusinessEntityInstance``1(System.String,System.String,System.Boolean)">
            <summary>
            Cria uma instância da classe mais customizada de uma entidade de negócio.
            </summary>
            <typeparam name="T">Tipo que representará a entidade de negócio.</typeparam>
            <param name="entityDefinitionName">Nome da definição da entidade para a qual se deseja uma entidade de negócio.</param>
            <param name="systemInstanceName">Nome da instância do sistema.</param>
            <param name="forceAssociatedType">Força a utilização do tipo associado à entidade</param>
            <returns>Retorna uma instância da classe mais customizada; a última herança configurada para o tipo <typeparamref name="T"/>.</returns>
            <remarks>Se não houver customizações configuradas, retorna uma instância de <typeparamref name="T"/>.</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.Factory.GetBusinessEntityType(System.String,System.String,System.Type)">
            <summary>
            Obtém o tipo que especializa uma entidade, considerando suas customizações.
            </summary>
            <param name="entityDefinitionName">Nome da definição da entidade para a qual se procura o tipo.</param>
            <param name="systemInstanceName">Nome da instância do sistema.</param>
            <param name="proposedType">
            Tipo proposto para representar a entidade. 
            O tipo informado precisa ser uma destas opções: 
            uma herança de BusinessEntity, 
            uma herança de EntityBase Generic,
            ou o próprio tipo EntityBase.
            </param>
            <returns>
            Retorna o tipo do último nível de customização da entidade especializada.
            </returns>
            <remarks>
            Se nenhuma configuração de especialização ou customização for encontrada, retorna o tipo informado em <paramref name="proposedType"/>. 
            O resultado da pesquisa é adicionado ao cache.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.Factory.GetBusinessEntityType(System.String,System.String,System.Boolean,System.Type)">
            <summary>
            Obtém o tipo que especializa uma entidade, considerando suas customizações.
            </summary>
            <param name="entityDefinitionName">Nome da definição da entidade para a qual se procura o tipo.</param>
            <param name="systemInstanceName">Nome da instância do sistema.</param>
            <param name="forceAssociatedType">Obtém o tipo mais especializado associado no Builder, ignorando o flag de "Executar entidade especializada".</param>
            <param name="proposedType">
            Tipo proposto para representar a entidade. 
            O tipo informado precisa ser uma destas opções: 
            uma herança de BusinessEntity, 
            uma herança de EntityBase Generic,
            ou o próprio tipo EntityBase.
            </param>
            <returns>
            Retorna o tipo do último nível de customização da entidade especializada.
            </returns>
            <remarks>
            Se nenhuma configuração de especialização ou customização for encontrada, retorna o tipo informado em <paramref name="proposedType"/>. 
            O resultado da pesquisa é adicionado ao cache.
            </remarks>
        </member>
        <member name="T:Benner.Tecnologia.Business.Schedule.ISchedule">
            <summary>
            Define um BusinessComponent como agendamento
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.Schedule.ISchedule.ScheduleRun(Benner.Tecnologia.Business.Schedule.ScheduleArgs)">
            <summary>
            Ponto de entrada do agendamento
            </summary>
            <param name="args">Parâmetros para o agendamento</param>
        </member>
        <member name="T:Benner.Tecnologia.Business.Schedule.ScheduleParamsIndexer">
            <summary>
            Acessador dos parâmetros do agendamento
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Schedule.ScheduleParamsIndexer.Item(System.String)">
            <summary>
            Leitura dos parâmetros do agendamento
            </summary>
            <param name="nome">Nome do parâmetro (Case-insensitive_</param>
            <returns>Valor do parâmetro</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.Schedule.ScheduleArgs">
            <summary>
            Argumentos do agendamento
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Schedule.ScheduleArgs.ScheduleParams">
            <summary>
            Parâmetros do agendamento
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.Schedule.ScheduleArgs.OutputMessage">
            <summary>
            Mensagem de sucesso do agendamento
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.ISqlResources">
            <summary>
            Recursos do banco de dados
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ISqlResources.SupportOnlyOldJoin">
            <summary>
            Informa se o banco apenas suporta OldJoins. 
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ISqlResources.OldLeftJoinSymbol">
            <summary>
            Informa o simbolo para o Left join no formato antigo. Exemplo:  *=   (+)=
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ISqlResources.Upper">
            <summary>
            Informa qual a função do banco que faz Upper em strings
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ISqlResources.SupportHandleIsNull">
            <summary>
            Informa se este banco de dados permite a expressão HANDLE IS NULL, ou se deve utilizar HANDLE = -538
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ISqlResources.SupportNoLock">
            <summary>
            Informa se o banco suporta comandos NOLOCK.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ISqlResources.SupportReadCommited">
            <summary>
            Informa se o banco suporta a leitura de registros comitados.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ISqlResources.TableNoLockTag">
            <summary>
            Informa a expressão usada para NOLOCK após o nome da tabela.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ISqlResources.StatementNoLockTag">
            <summary>
            Informa a expressão usada para NOLOCK após o comando sql.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ISqlResources.TableReadCommitedTag">
            <summary>
            Informa a expressão usada para leitura de registros comitados após o nome da tabela.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ISqlResources.StatementReadCommitedTag">
            <summary>
            Informa a expressão usada para leitura de registros comitados após o comando sql.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ISqlResources.SupportAsToken">
            <summary>
            Informa se o comando sql pode ter o token AS para definir o alias da tabela.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ISqlResources.SupportNamedParameters">
            <summary>
            Informa se os parâmetros dos comandos são por nome ou por sequência. 
            Se são por nome comandos com parâmetros com mesmo nome serão criados apenas 1 vez em BennerCommand.Parameters
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.Div(System.String,System.Int64)">
            <summary>
            Retorna a expressão que deve ser usada no comando sql para fazer a divisão.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="divisor">Valor do divisor. Maior que zero.</param>
            <returns>Retorna a expressão que deve ser usada no comando sql para fazer a divisão.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.Left(System.String,System.Int32)">
            <summary>
            Retorna a expressão para obter o inicio de uma string.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="length">Número de caracteres a retornar.</param>
            <returns>Expressão para obter n caracteres de um campo string.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.Year(System.String)">
            <summary>
            Retorna a expressão para obter o ano do campo data.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <returns>O ano da data gravada no campo.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.Month(System.String)">
            <summary>
            Retorna a expressão para obter o mês do campo data.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <returns>O mês da data gravada no campo.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.Day(System.String)">
            <summary>
            Retorna a expressão para obter o dia do mês do campo data.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <returns>O dia do mês da data gravada no campo.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.Hour(System.String)">
            <summary>
            Retorna a expressão para obter a hora do campo data.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <returns>A hora da data gravada no campo.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.Minute(System.String)">
            <summary>
            Retorna a expressão para obter o minuto do campo data.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <returns>O minuto da data gravada no campo.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.Second(System.String)">
            <summary>
            Retorna a expressão para obter o segundo do campo data.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <returns>O segundo da data gravada no campo.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.CurrentYear">
            <summary>
            Retorna a expressão para obter o ano da data corrente.
            </summary>
            <returns>O ano da data corrente</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.CurrentMonth">
            <summary>
            Retorna a expressão para obter o mês da data corrente.
            </summary>
            <returns>O mês da data corrente.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.CurrentDay">
            <summary>
            Retorna a expressão para obter o dia da data corrente.
            </summary>
            <returns>O dia da data corrente.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.AddHours(System.String,System.Int32)">
            <summary>
            Adiciona horas em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="hours">Quantidade de horas a adicionar</param>
            <returns>A data do campo adicionado o número de horas informado no parâmetro hours.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.AddMinutes(System.String,System.Int32)">
            <summary>
            Adiciona minutos em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="minutes">Quantidade de minutos a adicionar</param>
            <returns>A data do campo adicionado o número de horas informado no parâmetro minutes.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.AddSeconds(System.String,System.Int32)">
            <summary>
            Adiciona segundos em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="seconds">Quantidade de segundos a adicionar.</param>
            <returns>A data do campo adicionado o número de segundos informado no parâmetro.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.AddDays(System.String,System.Int32)">
            <summary>
            Adiciona dias em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="days">Quantidade de dias a adicionar</param>
            <returns>A data do campo adicionado o número de dias informado no parâmetro days.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.AddMonths(System.String,System.Int32)">
            <summary>
            Adiciona meses em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="months">Quantidade de mêses a adicionar</param>
            <returns>A data do campo adicionado o número de meses informado no parâmetro months.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.AddYears(System.String,System.Int32)">
            <summary>
            Adiciona anos em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="years">Quantidade de anos a adicionar.</param>
            <returns>A data do campo adicionado o número de anos informado no parâmetro years.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.AddHours(System.String,System.String)">
            <summary>
            Adiciona horas em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="hours">Quantidade de horas a adicionar</param>
            <returns>A data do campo adicionado o número de horas informado no parâmetro hours.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.AddMinutes(System.String,System.String)">
            <summary>
            Adiciona minutos em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="minutes">Quantidade de minutos a adicionar</param>
            <returns>A data do campo adicionado o número de horas informado no parâmetro minutes.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.AddSeconds(System.String,System.String)">
            <summary>
            Adiciona segundos em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="seconds">Quantidade de segundos a adicionar.</param>
            <returns>A data do campo adicionado o número de segundos informado no parâmetro.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.AddDays(System.String,System.String)">
            <summary>
            Adiciona dias em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="days">Quantidade de dias a adicionar</param>
            <returns>A data do campo adicionado o número de dias informado no parâmetro days.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.AddMonths(System.String,System.String)">
            <summary>
            Adiciona meses em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="months">Quantidade de mêses a adicionar</param>
            <returns>A data do campo adicionado o número de meses informado no parâmetro months.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.AddYears(System.String,System.String)">
            <summary>
            Adiciona anos em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="years">Quantidade de anos a adicionar.</param>
            <returns>A data do campo adicionado o número de anos informado no parâmetro years.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.TruncateTime(System.String)">
            <summary>
            Função utilizada para retornar o campo sem a hora.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <returns>A data sem a hora.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.Substring(System.String,System.Int32,System.Int32)">
            <summary>
            Função utilizada para retornar parte de um campo string.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="index">Posição inicial. A primeira posição é 1.</param>
            <param name="length">Número de caracteres que devem ser retornados.</param>
            <returns>Retorna length caracteres a partir da posição index do campo fieldName</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.Substring(System.String,System.String,System.String)">
            <summary>
            Função utilizada para retornar parte de um campo string.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="indexExpression">Expressão SQL para posição inicial. A primeira posição é 1.</param>
            <param name="lengthExpression">Expressão SQL para o número de caracteres que devem ser retornados.</param>
            <returns>Retorna length caracteres a partir da posição index do campo fieldName</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.StringConcat">
            <summary>
            Retorna a expressão utilizada para concatenar campos string.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.Concat(System.String,System.String)">
            <summary>
            Função utilizada para retornar duas string concatenadas
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.DateDiff(System.String,System.String)">
            <summary>
            Calcula a diferença entre dois campos
            </summary>
            <param name="fieldName1">Nome do primeiro campo.</param>
            <param name="fieldName2">Nome do segundo campo.</param>
            <returns>A diferença entre as duas datas.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.Length(System.String)">
            <summary>
            Calcula o tamanho em bytes do conteúdo do campo.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <returns>O tamanho em bytes do conteúdo do campo.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.DayOfWeek(System.String)">
            <summary>
            Calcula o dia da semana da data.
            </summary>
            <param name="fieldName">O nome do campo.</param>
            <returns>O dia da semana.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.ExtractTime(System.String,System.Boolean)">
            <summary>
            Retorna a hora de um campo data.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="withSeconds">True para retornar os segundos, false para retornar horas e minutos apenas.</param>
            <returns>A hora do campo.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.IsNull(System.String,System.String)">
            <summary>
            Monta expressão para verificar valores nulos.
            </summary>
            <param name="expression">Expressão</param>
            <param name="value">Valor de retorno caso a expressão retorne <c>null</c>.</param>
            <returns>A expressão para o comando SQL.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.Alias(System.String,System.String)">
            <summary>
            Adiciona um alias para o campo informado
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="aliasName">Nome do alias</param>
            <returns>String com o campo identificado com o alias informado.</returns>        
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.DateConvert(System.DateTime)">
            <summary>
            Função converte uma data para o formato do banco da dados.
            </summary>
            <param name="date">Data</param>
            <returns>String com a função de converção do banco.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.DateConvert(System.DateTime,System.Boolean)">
            <summary>
            Função converte uma data para o formato do banco da dados.
            </summary>
            <remarks>
             Função converte uma data para o formato do banco da dados.
            </remarks>
            <param name="date">Data</param>
            <param name="withTime">Se é para retornar a hora na conversão do banco.</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.ExecFunction(System.String,System.String)">
            <summary>
            Sintaxe de execução de função para o banco de dados atual
            </summary>
            <param name="functionName">Nome da função</param>
            <param name="parameters">string com os parâmetros da função</param>
            <returns>String com a forma de executar uma função</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.IntegerSum(System.String)">
            <summary>
            SUM para a execução da função SUM para inteiros.
            Para evitar overflow em certos bancos.
            </summary>
            <returns>Retorna string SQL para SUM</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.IntegerAverage(System.String)">
            <summary>
            AVG para a execução da função AVG para inteiros.
            Para evitar overflow em certos bancos.
            </summary>
            <returns>Retorna string SQL para AVG</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.DatabaseLink(System.String,System.String)">
            <summary>
            Sintaxe para consultas em outros bancos. Oracle=Database Link. MSSQL=Linked Servers
            </summary>
            <param name="tableName">Nome da tabela para a consulta.</param>
            <param name="databaseLinkName">Nome do Database Link em Oracle ou do Linked Server em MSSQL</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.Now">
            <summary>
            Obter a expressão de obtenção da data e hora atual.
            </summary>
            <returns>Expressão para obter a data e hora atual.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.Today">
            <summary>
            Obter a expressão de obtenção da data atual.
            </summary>
            <returns>Expressão para obter a data atual.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.TextToVarchar(System.String)">
            <summary>
            Convert campo tipo Texto (CLOB - em Oracle, TEXT em SQL Server) em campo string (varchar). 
            Truncando valores maiores que 4000 caracteres. 
            </summary>
            <param name="fieldName">Nome do campo</param>
            <returns>Função para conversão de valores</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.NextHandle(System.String)">
            <summary>
            Obter a expressão para obter o próximo Handle da tabela via uma Sequence
            </summary>
            <param name="tableAlias">Apelido da tabela</param>
            <returns>Função para obter novo handle</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.CastAsString(System.String)">
            <summary>
            Obtém a função cast para string do banco
            </summary>
            <param name="fieldName">Nome do campo</param>
            <returns>A expressão da função cast</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.CastAsNumeric(System.String,System.Int32,System.Int32)">
            <summary>
            Obtém a função cast para numérico do banco
            </summary>
            <param name="fieldName">Nome do campo</param>
            <param name="precision">Total de dígitos</param>
            <param name="scale">Quantos dos dígitos são decimais</param>
            <returns>A expressão da função cast</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.CastAsInteger(System.String)">
            <summary>
            Obtém a função cast para inteiro do banco.
            </summary>
            <param name="fieldName">Nome do campo</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.BitOn(System.String,System.Int32)">
            <summary>
            Gera a expressão de bitwise and que retorna verdadeiro se os bits estão ligados.
            </summary>
            <param name="fieldName">Nome do campo</param>
            <param name="bit">Bits que se deseja verificar</param>
            <returns>Sql com o bitwise and baseado no campo e bit.</returns>
            <remarks>Exemplo em MS Server: ITENSDEVEICULO &amp; 5 = 5 
            Exemplo em Oracle: BITAND(CAMPOTIPOBIT, 7) = 7</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.BitOff(System.String,System.Int32)">
            <summary>
            Gera a expressão de bitwise and que retorna verdadeiro se os bits estão desligados.
            </summary>
            <param name="fieldName">Nome do campo</param>
            <param name="bit">Bits que se deseja verificar</param>
            <returns>Sql com o bitwise or baseado no campo e bit.</returns>
            <remarks>Exemplo em MS Server: ITENSDEVEICULO &amp; 5 = 0 
            Exemplo em Oracle: BITAND(CAMPOTIPOBIT, 7) = 0</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.ISqlResources.SqlDateTimeDiff(Benner.Tecnologia.Common.DateTimeDiffType,System.String,System.String)">
            <summary>
            Calcula a diferença entre dois campos data e hora
            </summary>
            <param name="index">Retorno da diferença em segundos, mminutos, horas ou dias.</param>
            <param name="fieldStart">Nome do primeiro campo.</param>
            <param name="fieldEnd">Nome do segundo campo.</param>
            <returns>A diferença entre as duas datas e horas.</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.SqlResources">
            <summary>
            Recursos do banco de dados atual
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SqlResources.SupportOnlyOldJoin">
            <summary>
            Informa se o banco apenas suporta OldJoins. 
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SqlResources.OldLeftJoinSymbol">
            <summary>
            Informa o simbolo para o Left join no formato antigo. Exemplo:  *=   (+)=
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SqlResources.Upper">
            <summary>
            Informa qual a função do banco que faz Upper em strings
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SqlResources.SupportHandleIsNull">
            <summary>
            Informa se este banco de dados permite a expressão HANDLE IS NULL, ou se deve utilizar HANDLE = -538
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SqlResources.SupportNoLock">
            <summary>
            Informa se o banco suporta comandos NOLOCK.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SqlResources.SupportReadCommited">
            <summary>
            Informa se o banco suporta a leitura de registros comitados.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SqlResources.TableNoLockTag">
            <summary>
            Informa a expressão usada para NOLOCK após o nome da tabela.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SqlResources.StatementNoLockTag">
            <summary>
            Informa a expressão usada para NOLOCK após o comando sql.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SqlResources.TableReadCommitedTag">
            <summary>
            Informa a expressão usada para leitura de registros comitados após o nome da tabela.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SqlResources.StatementReadCommitedTag">
            <summary>
            Informa a expressão usada para leitura de registros comitados após o comando sql.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SqlResources.SupportAsToken">
            <summary>
            Informa se o comando sql pode ter o token AS para definir o alias da tabela.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.SqlResources.SupportNamedParameters">
            <summary>
            Informa se os parâmetros dos comandos são por nome ou por sequência. 
            Se são por nome comandos com parâmetros com mesmo nome serão criados apenas 1 vez em BennerCommand.Parameters
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.TextToVarchar(System.String)">
            <summary>
            Convert campo tipo Texto (CLOB - em Oracle, TEXT em SQL Server) em campo string (varchar). 
            Truncando valores maiores que 4000 caracteres. 
            </summary>
            <param name="fieldName">Nome do campo</param>
            <returns>Função para conversão de valores</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.AddHours(System.String,System.Int32)">
            <summary>
            Adiciona horas em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="hours">Quantidade de horas a adicionar</param>
            <returns>A data do campo adicionado o número de horas informado no parâmetro hours.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.AddMinutes(System.String,System.Int32)">
            <summary>
            Adiciona minutos em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="minutes">Quantidade de minutos a adicionar</param>
            <returns>A data do campo adicionado o número de horas informado no parâmetro minutes.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.AddSeconds(System.String,System.Int32)">
            <summary>
            Adiciona segundos em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="seconds">Quantidade de segundos a adicionar.</param>
            <returns>A data do campo adicionado o número de segundos informado no parâmetro.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.AddDays(System.String,System.Int32)">
            <summary>
            Adiciona dias em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="days">Quantidade de dias a adicionar</param>
            <returns>A data do campo adicionado o número de dias informado no parâmetro days.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.AddMonths(System.String,System.Int32)">
            <summary>
            Adiciona meses em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="months">Quantidade de mêses a adicionar</param>
            <returns>A data do campo adicionado o número de meses informado no parâmetro months.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.AddYears(System.String,System.Int32)">
            <summary>
            Adiciona anos em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="years">Quantidade de anos a adicionar.</param>
            <returns>A data do campo adicionado o número de anos informado no parâmetro years.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.AddHours(System.String,System.String)">
            <summary>
            Adiciona horas em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="hours">Quantidade de horas a adicionar</param>
            <returns>A data do campo adicionado o número de horas informado no parâmetro hours.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.AddMinutes(System.String,System.String)">
            <summary>
            Adiciona minutos em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="minutes">Quantidade de minutos a adicionar</param>
            <returns>A data do campo adicionado o número de horas informado no parâmetro minutes.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.AddSeconds(System.String,System.String)">
            <summary>
            Adiciona segundos em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="seconds">Quantidade de segundos a adicionar.</param>
            <returns>A data do campo adicionado o número de segundos informado no parâmetro.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.AddDays(System.String,System.String)">
            <summary>
            Adiciona dias em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="days">Quantidade de dias a adicionar</param>
            <returns>A data do campo adicionado o número de dias informado no parâmetro days.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.AddMonths(System.String,System.String)">
            <summary>
            Adiciona meses em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="months">Quantidade de mêses a adicionar</param>
            <returns>A data do campo adicionado o número de meses informado no parâmetro months.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.AddYears(System.String,System.String)">
            <summary>
            Adiciona anos em um campo data
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="years">Quantidade de anos a adicionar.</param>
            <returns>A data do campo adicionado o número de anos informado no parâmetro years.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.Alias(System.String,System.String)">
            <summary>
            Adiciona um alias para o campo informado
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="aliasName">Nome do alias</param>
            <returns>String com o campo identificado com o alias informado.</returns>        
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.StringConcat">
            <summary>
            Retorna a expressão utilizada para concatenar campos string.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.Concat(System.String,System.String)">
            <summary>
            Função utilizada para retornar duas string concatenadas
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.NextHandle(System.String)">
            <summary>
            Obter o Próximo Handle da tabela.
            </summary>
            <param name="tableAlias">Apelido da tabela</param>
            <returns>Função para obter novo handle</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.Substring(System.String,System.Int32,System.Int32)">
            <summary>
            Função utilizada para retornar parte de um campo string.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="index">Posição inicial. A primeira posição é 1.</param>
            <param name="length">Número de caracteres que devem ser retornados.</param>
            <returns>Retorna length caracteres a partir da posição index do campo fieldName</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.Substring(System.String,System.String,System.String)">
            <summary>
            Função utilizada para retornar parte de um campo string.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="indexExpression">Expressão SQL para posição inicial. A primeira posição é 1.</param>
            <param name="lengthExpression">Expressão SQL para número de caracteres que devem ser retornados.</param>
            <returns>Retorna length caracteres a partir da posição index do campo fieldName</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.CastAsString(System.String)">
            <summary>
            Obtém a função cast para string do banco
            </summary>
            <param name="fieldName">Nome do campo</param>
            <returns>A expressão da função cast</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.CastAsNumeric(System.String,System.Int32,System.Int32)">
            <summary>
            Obtém a função cast para numérico do banco
            </summary>
            <param name="fieldName">Nome do campo</param>
            <param name="precision">Total de dígitos</param>
            <param name="scale">Quantos dos dígitos são decimais</param>
            <returns>A expressão da função cast</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.CastAsInteger(System.String)">
            <summary>
            Obtém a função cast para inteiro do banco
            </summary>
            <param name="fieldName">Nome do campo</param>
            <returns>A expressão da função cast</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.DateConvert(System.DateTime)">
            <summary>
            Função converte uma data para o formato do banco da dados.
            </summary>
            <param name="date">Data</param>
            <returns>String com a função de converção do banco.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.DateConvert(System.DateTime,System.Boolean)">
            <summary>
            Função converte uma data para o formato do banco da dados.
            </summary>
            <remarks>
             Função converte uma data para o formato do banco da dados.
            </remarks>
            <param name="date">Data</param>
            <param name="withTime">Se é para retornar a hora na conversão do banco.</param>
            <returns></returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.DateDiff(System.String,System.String)">
            <summary>
            Calcula a diferença entre dois campos
            </summary>
            <param name="fieldName1">Nome do primeiro campo.</param>
            <param name="fieldName2">Nome do segundo campo.</param>
            <returns>A diferença entre as duas datas.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.Day(System.String)">
            <summary>
            Retorna a expressão para obter o dia do mês do campo data.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <returns>O dia do mês da data gravada no campo.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.Hour(System.String)">
            <summary>
            Retorna a expressão para obter a hora do campo data.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <returns>A hora data gravada no campo.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.Minute(System.String)">
            <summary>
            Retorna a expressão para obter o minuto do campo data.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <returns>O Minuto data gravada no campo.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.Second(System.String)">
            <summary>
            Retorna a expressão para obter o segundo do campo data.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <returns>O segondo data gravada no campo.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.DayOfWeek(System.String)">
            <summary>
            Calcula o dia da semana da data.
            </summary>
            <param name="fieldName">O nome do campo.</param>
            <returns>O dia da semana.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.Div(System.String,System.Int64)">
            <summary>
            Retorna a expressão que deve ser usada no comando sql para fazer a divisão.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="divisor">Valor do divisor. Maior que zero.</param>
            <returns>Retorna a expressão que deve ser usada no comando sql para fazer a divisão.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.ExtractTime(System.String,System.Boolean)">
            <summary>
            Retorna a hora de um campo data.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="withSeconds">True para retornar os segundos, false para retornar horas e minutos apenas.</param>
            <returns>A hora do campo.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.IsNull(System.String,System.String)">
            <summary>
            Monta expressão para verificar valores nulos.
            </summary>
            <param name="expression">Expressão</param>
            <param name="value">Valor de retorno caso a expressão retorne <c>null</c>.</param>
            <returns>A expressão para o comando SQL.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.Left(System.String,System.Int32)">
            <summary>
            Retorna a expressão para obter o inicio de uma string.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <param name="length">Número de caracteres a retornar.</param>
            <returns>Expressão para obter n caracteres de um campo string.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.Length(System.String)">
            <summary>
            Calcula o tamanho em bytes do conteúdo do campo.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <returns>O tamanho em bytes do conteúdo do campo.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.Month(System.String)">
            <summary>
            Retorna a expressão para obter o mês do campo data.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <returns>O mês da data gravada no campo.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.TruncateTime(System.String)">
            <summary>
            Função utilizada para retornar o campo sem a hora.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <returns>A data sem a hora.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.Year(System.String)">
            <summary>
            Retorna a expressão para obter o ano do campo data.
            </summary>
            <param name="fieldName">Nome do campo.</param>
            <returns>O ano da data gravada no campo.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.Now">
            <summary>
            Obter a expressão de obtenção da data e hora atual.
            </summary>
            <returns>Expressão para obter a data e hora atual.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.Today">
            <summary>
            Obter a expressão de obtenção da data atual.
            </summary>
            <returns>Expressão para obter a data atual.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.ExecFunction(System.String,System.String)">
            <summary>
            Sintaxe de execução de função para o banco de dados atual
            </summary>
            <param name="functionName">Nome da função</param>
            <param name="parameters">string com os parâmetros da função</param>
            <returns>String com a forma de executar uma função</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.IntegerSum(System.String)">
            <summary>
            SUM para a execução da função SUM para inteiros.
            Para evitar overflow em certos bancos.
            </summary>
            <returns>Retorna string SQL para SUM</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.IntegerAverage(System.String)">
            <summary>
            AVG para a execução da função AVG para inteiros.
            Para evitar overflow em certos bancos.
            </summary>
            <returns>Retorna string SQL para AVG</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.CurrentYear">
            <summary>
            Retorna a expressão para obter o ano da data corrente.
            </summary>
            <returns>O ano da data corrente.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.CurrentMonth">
            <summary>
            Retorna a expressão para obter o mês da data corrente.
            </summary>
            <returns>O mês da data corrente.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.CurrentDay">
            <summary>
            Retorna a expressão para obter o dia da data corrente.
            </summary>
            <returns>O dia da data corrente.</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.BitOn(System.String,System.Int32)">
            <summary>
            Gera a expressão de bitwise and que retorna verdadeiro se os bits estão ligados.
            </summary>
            <param name="fieldName">Nome do campo</param>
            <param name="bit">Bits que se deseja verificar</param>
            <returns>Sql com o bitwise and baseado no campo e bit.</returns>
            <remarks>Exemplo em MS Server: ITENSDEVEICULO &amp; 5 = 5 
            Exemplo em Oracle: BITAND(CAMPOTIPOBIT, 7) = 7</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.BitOff(System.String,System.Int32)">
            <summary>
            Gera a expressão de bitwise and que retorna verdadeiro se os bits estão desligados.
            </summary>
            <param name="fieldName">Nome do campo</param>
            <param name="bit">Bits que se deseja verificar</param>
            <returns>Sql com o bitwise or baseado no campo e bit.</returns>
            <remarks>Exemplo em MS Server: ITENSDEVEICULO &amp; 5 = 0 
            Exemplo em Oracle: BITAND(CAMPOTIPOBIT, 7) = 0</remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.SqlResources.SqlDateTimeDiff(Benner.Tecnologia.Common.DateTimeDiffType,System.String,System.String)">
            <summary>
            Calcula a diferença entre dois campos data e hora
            </summary>
            <param name="index">Retorno da diferença em segundos, mminutos ou horas.</param>
            <param name="fieldStart">Nome do primeiro campo.</param>
            <param name="fieldEnd">Nome do segundo campo.</param>
            <returns>A diferença entre as duas datas e horas.</returns>
        </member>
        <member name="T:Benner.Tecnologia.Business.ITransactionContext">
            <summary>
            Define um contexto transacional.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ITransactionContext.Name">
            <summary>
            Nome do contexto transacional.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ITransactionContext.Completed">
            <summary>
            Indica se todas as operações dentro do contexto foram completadas com sucesso.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ITransactionContext.Complete">
            <summary>
            Indica que todas as operações dentro do contexto foram completadas com sucesso.
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.ITransactionContextFactory">
            <summary>
            Factory para obter contexto transacional
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ITransactionContextFactory.Begin">
            <summary>
            Inicia um contexto de transação retornando uma instância de ITransactionCotext
            </summary>
            <returns>Implementação de ITransactionCotext</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ITransactionContextFactory.Begin(Benner.Tecnologia.Business.TransactionContextOption)">
            <summary>
            Inicia um contexto de transação retornando uma instância de ITransactionCotext
            </summary>
            <param name="transactionContextOption">Opções avançadas do contexto transacional.</param>
            <returns>Implementação de ITransactionCotext</returns>
        </member>
        <member name="P:Benner.Tecnologia.Business.ITransactionContextFactory.InTransactionalContext">
            <summary>
            Indica se há um contexto transacional. Contextos transacionais podem ter ou não ter transações ativas no banco.
            </summary>
            <remarks>
            Geralmente, se o contexto é transacional, existe uma transação aberta e todas as operações do contexto 
            são executadas dentro desta transação. 
            Porém o contexto pode não possuir transação (<see cref="F:Benner.Tecnologia.Business.TransactionContextOption.Suppress"/>) ou a transação até existe mais foi cancelada.
            Para saber se há transação no banco utilize <see cref="P:Benner.Tecnologia.Business.TransactionContext.InTransaction"/>.
            Para saber se a transação foi cancelada utilize <see cref="P:Benner.Tecnologia.Business.TransactionContext.Canceled"/>.
            </remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.ITransactionContextFactory.InTransaction">
            <summary>
            Indica se existe transação no banco de dados.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ITransactionContextFactory.Canceled">
            <summary>
            Indica se a transação foi cancelada (Algum contexto aninhado não chamou o Complete).
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.ITransactionContextService">
            <summary>
            Define o serviço de transações.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ITransactionContextService.InTransactionalContext">
            <summary>
            Se há contexto transacional. Returna true mesmo em contextos transacionais com TransactionContextOption.Supressed.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ITransactionContextService.InTransaction">
            <summary>
            Se há transação ativa no banco de dados
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ITransactionContextService.Canceled">
            <summary>
            Indica se a transação foi cancelada (Algum contexto aninhado não chamou o Complete)
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ITransactionContextService.EnterTransactionalContext(Benner.Tecnologia.Business.ITransactionContext,Benner.Tecnologia.Business.TransactionContextOption)">
            <summary>
            Entra em um contexto transacional.
            </summary>
            <param name="transactionContext">Objeto que representa o contexto.</param>
            <param name="transactionContextOption">Descreve os requerimentos do contexto transacional: nova transação, transação existente, ou nenhuma transação.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.ITransactionContextService.Leave(Benner.Tecnologia.Business.ITransactionContext)">
            <summary>
            Abandona o contexto <paramref name="transactionContext"/>.
            </summary>
            <param name="transactionContext">Objeto que representa o contexto.</param>
            <remarks>
            Se o "Complete" foi invocado e este é um contexto raiz, as operações são efetivadas. 
            Se o "Complete" foi invocado e este é um contexto aninhado a um outro contexto transacional, as operações serão efetivadas ao término do contexto raiz.
            Se o "Complete" não foi invocado, causa o rollback da transação. 
            Se este é um contexto raiz e o "Complete" de algum dos seus contextos aninhados não foi invocado, lança uma exceção do tipo TransactionAbortedException.
            </remarks>
        </member>
        <member name="T:Benner.Tecnologia.Business.TransactionContextFactory">
            <summary>
            Implementação de factory para obtenção de contexto transacional.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.TransactionContextFactory.Begin">
            <summary>
            Inicia um contexto de transação.
            </summary>
            <returns>Novo objeto TransactionContext</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.TransactionContextFactory.Begin(Benner.Tecnologia.Business.TransactionContextOption)">
            <summary>
            Inicia um contexto de transação.
            </summary>
            <param name="transactionContextOption">Opções avançadas do contexto transacional.</param>
            <returns>Novo objeto TransactionContext</returns>
        </member>
        <member name="P:Benner.Tecnologia.Business.TransactionContextFactory.InTransactionalContext">
            <summary>
            Indica se há um contexto transacional. Contextos transacionais podem ter ou não ter transações ativas no banco.
            </summary>
            <remarks>
            Geralmente, se o contexto é transacional, existe uma transação aberta e todas as operações do contexto 
            são executadas dentro desta transação. 
            Porém o contexto pode não possuir transação (<see cref="F:Benner.Tecnologia.Business.TransactionContextOption.Suppress"/>) ou a transação até existe mais foi cancelada.
            Para saber se há transação no banco utilize <see cref="P:Benner.Tecnologia.Business.TransactionContext.InTransaction"/>.
            Para saber se a transação foi cancelada utilize <see cref="P:Benner.Tecnologia.Business.TransactionContext.Canceled"/>.
            </remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.TransactionContextFactory.InTransaction">
            <summary>
            Indica se existe transação no banco de dados.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.TransactionContextFactory.Canceled">
            <summary>
            Indica se a transação foi cancelada (Algum contexto aninhado não chamou o Complete).
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.TransactionContext">
            <summary>
            Torna um bloco de código parte de um contexto transacional.
            </summary>
            <remarks>
            <para>
            Uma instância de TransactionContext determina que um contexto é transacional, ou seja: as operações seguintes à instância 
            da classe acontecerão dentro de uma transação. Quando uma instância de TransactionContext é criada, o gerenciador de transações 
            determina qual transação o contexto irá participar. A decisão é baseada em dois fatores: se já existe uma transação ambiente 
            e pelo valor do parâmetro <see cref="T:Benner.Tecnologia.Business.TransactionContextOption"/> passado no construtor da classe.
            </para><para>
            Se nenhuma exceção ocorrer dentro do contexto transacional (isto é, entre a inicialização do objeto TransactionContext 
            e a chamada do seu método <see cref="M:Benner.Tecnologia.Business.TransactionContext.Dispose"/>), então a transação da qual o contexto participa é 
            autorizada a prosseguir. Se ocorrer uma exceção dentro do contexto ou se o método <see cref="M:Benner.Tecnologia.Business.TransactionContext.Complete"/> 
            não for invocado, então é executado o rollback da transação no dispose do objeto.
            </para><para>
            Quando a rotina conclui com sucesso todas as operações que devem integrar a transação, você deve invocar o método 
            <see cref="M:Benner.Tecnologia.Business.TransactionContext.Complete"/> uma vez para informar ao gerenciador de transações que é permitido executar o commit 
            da transação. Não executar este método causará o cancelamento da transação (será executado seu rollback no dispose do objeto).
            </para><para>
            Veja o artigo <a href="Wiki?Transações de banco de dados em .Net">Transações de banco de dados em .Net</a> para mais informações.
            </para>
            </remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.TransactionContext.InTransactionalContext">
            <summary>
            Indica se há um contexto transacional. Contextos transacionais podem ter ou não ter transações ativas no banco.
            </summary>
            <remarks>
            Geralmente, se o contexto é transacional, existe uma transação aberta e todas as operações do contexto 
            são executadas dentro desta transação. 
            Porém o contexto pode não possuir transação (<see cref="F:Benner.Tecnologia.Business.TransactionContextOption.Suppress"/>) ou a transação até existe mais foi cancelada.
            Para saber se há transação no banco utilize <see cref="P:Benner.Tecnologia.Business.TransactionContext.InTransaction"/>.
            Para saber se a transação foi cancelada utilize <see cref="P:Benner.Tecnologia.Business.TransactionContext.Canceled"/>.
            </remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.TransactionContext.InTransaction">
            <summary>
            Indica se existe transação no banco de dados.
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.TransactionContext.Canceled">
            <summary>
            Indica se a transação foi cancelada (Algum contexto aninhado não chamou o Complete).
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.TransactionContext.#ctor">
            <summary>
            Inicializa uma nova instância de <see cref="T:Benner.Tecnologia.Business.TransactionContext"/>.
            </summary>
            <overloads>
            Inicializa uma nova instância de <see cref="T:Benner.Tecnologia.Business.TransactionContext"/>.
            </overloads>
            <remarks>
            Este construtor cria um novo contexto transacional com a opção 
            de transação de contexto igual a <see cref="F:Benner.Tecnologia.Business.TransactionContextOption.Required"/>. 
            Isto significa que uma transação é requerida pelo novo contexto. 
            Se já existir uma transação ambiente, esta será utilizada. 
            Senão, uma nova transação será iniciada.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.TransactionContext.#ctor(Benner.Tecnologia.Business.TransactionContextOption)">
            <summary>
            Inicializa uma nova instância de <see cref="T:Benner.Tecnologia.Business.TransactionContext"/> com a opção de transação especificada.
            </summary>
            <param name="transactionContextOption">
            Uma instância do enumerador <see cref="T:Benner.Tecnologia.Business.TransactionContextOption"/> que descreve a opção de transação para o contexto.
            </param>
        </member>
        <member name="M:Benner.Tecnologia.Business.TransactionContext.#ctor(System.String)">
            <summary>
            Inicializa uma nova instância de <see cref="T:Benner.Tecnologia.Business.TransactionContext"/>.
            </summary>
            <param name="name">Nome do contexto transacional.</param>
            <remarks>
            <para>
            Este construtor cria um novo contexto transacional com a opção 
            de transação de contexto igual a <see cref="F:Benner.Tecnologia.Business.TransactionContextOption.Required"/>. 
            Isto significa que uma transação é requerida pelo novo contexto. 
            Se já existir uma transação ambiente, esta será utilizada. 
            Senão, uma nova transação será iniciada.
            </para><para>
            O nome informado no parâmetro <paramref name="name"/> figura nos logs gerados pela ferramenta e pode auxiliar no diagnótico de problemas. 
            </para>
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.TransactionContext.#ctor(Benner.Tecnologia.Business.TransactionContextOption,System.String)">
            <summary>
            Inicializa uma nova instância de <see cref="T:Benner.Tecnologia.Business.TransactionContext"/> com a opção de transação e o nome especificados.
            </summary>
            <param name="transactionContextOption">
            Uma instância do enumerador <see cref="T:Benner.Tecnologia.Business.TransactionContextOption"/> que descreve a opção de transação para o contexto.
            </param>
            <param name="name">Nome do contexto transacional.</param>
            <remarks>
            O nome informado no parâmetro <paramref name="name"/> figura nos logs gerados pela ferramenta e pode auxiliar no diagnótico de problemas. 
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.TransactionContext.Finalize">
            <summary>
            Finaliza a instância de <see cref="T:Benner.Tecnologia.Business.TransactionContext"/>.
            </summary>
            <remarks>
            Se não for invocado o Dispose do objeto, sua finalização pelo garbage collector 
            lançará uma exceção do tipo <see cref="T:System.Transactions.TransactionAbortedException"/> com uma mensagem semelhante a esta: 
            "A transação foi abortada porque uma instância de TransactionContext não foi finalizada por seu método Dispose. Utilize TransactionContext apenas em blocos "using".".
            </remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.TransactionContext.Name">
            <summary>
            Nome do contexto transacional.
            </summary>
            <remarks>
            Este nome figura nos logs gerados pela ferramenta e pode auxiliar no diagnótico de problemas. 
            Quando não informado, o nome é gerado automaticamente.
            </remarks>
        </member>
        <member name="P:Benner.Tecnologia.Business.TransactionContext.Completed">
            <summary>
            Indica se as operações realizadas dentro do contexto foram concluídas com sucesso.
            </summary>
            <remarks>
            Esta propriedade retornará True se o método "Complete" foi invocado.
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.TransactionContext.Complete">
            <summary>
            Indica que todas as operações realizadas dentro do contexto foram concluídas com sucesso.
            </summary>
            <remarks>
            Quando todas as operações dentro do contexto são completadas com sucesso, você deve invocar este método uma vez para informar 
            ao gerenciador de transações que os dados são consistentes e que a transação pode ser efetivada.
            <para>
            Uma segunda chamada a este método lançará uma exceção do tipo <see cref="T:System.InvalidOperationException"/> 
            com uma mensagem semelhante a esta: "O TransactionContext atual já foi concluído".
            </para>
            No caso de não ocorrer nenhuma exceção durante a execução das operações dentro do contexto, 
            o local onde é programada a chamada a este método é irrelevante, já que o gerenciador de transações 
            só vai checar esta informação no final do bloco using onde a <see cref="T:Benner.Tecnologia.Business.TransactionContext"/> foi instanciada. 
            Observe, entretanto, que se você colocar este comando no começo do bloco using, você estará de antemão informando 
            ao gerenciador de transações do sucesso de todas as operações, de modo que se ocorrer uma exceção na metade do bloco, 
            a primeira metade será efetivada e a segunda metade não chegará a ser executada por conta da exceção. 
            Portanto, a chamada este método deve ser sempre o último comando do bloco using.
            <para>
            Não invocar este método causa o cancelamento da transação. Entretanto, note que chamar este método não garante 
            que a transação será efetivada. Este é meramente um meio de informar ao gerenciador de transações 
            do status das operações dentro contexto (se falharam ou se foram completadas com sucesso). 
            </para><para>
            O commit real da transação ocorre no final do bloco using se a <see cref="T:Benner.Tecnologia.Business.TransactionContext"/> instanciada neste 
            bloco criou a transação. Se para este contexto foi utilizada uma transação já existente, o commit ocorre 
            ao final do contexto raiz (o que de fato criou a transação) - desde que todos os contextos aninhados tenham 
            invocado seu método Complete.
            </para>
            </remarks>
        </member>
        <member name="M:Benner.Tecnologia.Business.TransactionContext.Dispose">
            <summary>
            Finaliza o contexto transacional.
            </summary>
            <remarks>
            A chamada a este método registra o final do contexto transacional. 
            Se o objeto <see cref="T:Benner.Tecnologia.Business.TransactionContext"/> criou a transação e seu método <see cref="M:Benner.Tecnologia.Business.TransactionContext.Complete"/> foi invocado 
            dentro do bloco using, o objeto <see cref="T:Benner.Tecnologia.Business.TransactionContext"/> efetiva a transação (executa o commit) 
            quando este método é invocado.
            <para>
            O uso do comando using para instanciar <see cref="T:Benner.Tecnologia.Business.TransactionContext"/> garante que este método seja invocado 
            no final do bloco mesmo que alguma exceção seja lançada. Caso este seja um contexto raiz e algum contexto aninhado 
            não tenha invocado seu método Complete, será lançada uma exceção <see cref="T:System.Transactions.TransactionAbortedException"/> com uma mensagem 
            semelhante a esta: "A transação foi anulada" - mas apenas no caso de o Complete do próprio contexto raiz ter sido invocado.
            </para><para>
            Sempre que o método <see cref="M:Benner.Tecnologia.Business.TransactionContext.Complete"/> não é invocado em qualquer contexto (raiz ou aninhado) a transação é cancelada (rollback) no final do bloco using do contexto raiz 
            (onde é executado automaticamente o método <see cref="M:Benner.Tecnologia.Business.TransactionContext.Dispose"/>).
            A efetivação da transação (commit) também é executada ao final do contexto raiz mas somente se todos os contextos, 
            o raiz e os aninhados, terem invocado seu método <see cref="M:Benner.Tecnologia.Business.TransactionContext.Complete"/>.
            </para>
            </remarks>
        </member>
        <member name="T:Benner.Tecnologia.Business.TransactionContextOption">
            <summary>
            Provê opções adicionais para a criação de um contexto de transação.
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.TransactionContextOption.Required">
            <summary>
            Uma transação é requerida no cotexto. 
            Se já existir uma transação, ela é utilizada; senão, será criada uma nova transação. Este é o comportamento padrão.
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.TransactionContextOption.RequiresNew">
            <summary>
            Sempre será criada uma nova transação para o contexto, independente de contextos pais.
            </summary>
        </member>
        <member name="F:Benner.Tecnologia.Business.TransactionContextOption.Suppress">
            <summary>
            A transação existente, se houver, será suprimida no contexto. 
            Todas as operações realizadas dentro do contexto ocorrerão fora de transação.
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.DbValueProcessor">
            <summary>
            Processamento de valores vão para o banco de dados.
            Essa classe basicamente faz algumas conversões conforme o tipo, conteúdo do valor do campo e sua definição.
            São conversões que não estão implementadas nas FieldDefinitions.
            O ideal seria colocar no FieldDefinitions o método WriteDbValue. Mas isso é um pouco complexo, pois a assinatura do método varia conforme o tipo.
            
            Importante: QUALQUER IMPLEMENTAÇÃO AQUI DEVE TER TESTES UNITARIOS EM DbValueProcessorTest na Business.Tests
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.DbValueProcessor.WriteDbValue(Benner.Tecnologia.Common.FieldDefinition,System.Object,System.Func{System.Boolean},System.Action{System.String},System.Action{System.Object},System.Action{System.String,System.Object},System.Action{System.Object})">
            <summary>
            Faz processamento do valor que será gravado no banco, conforme definição do campo
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.DocumentsValidation">
            <summary>
            Classe com métodos para validar CPF, CNPJ e PIS
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.DocumentsValidation.ValidateCPF(System.String)">
            <summary>
            Verifica se um determinado CPF é válido.
            </summary>
            <param name="cpf">CPF que será validado</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.DocumentsValidation.ValidateCNPJ(System.String)">
            <summary>
            Verifica se um determinado CNPJ é válido.
            </summary>
            <param name="cnpj">CNPJ que será validado.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.DocumentsValidation.ValidatePIS(System.String)">
            <summary>
            Verifica se um determinado PIS é válido.
            </summary>
            <param name="pis">PIS que será validado.</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.DocumentsValidation.IsValidCPF(System.String)">
            <summary>
            Verifica se um determinado CPF é válido.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.DocumentsValidation.IsValidCNPJ(System.String)">
            <summary>
            Verifica se um determinado CNPJ é válido.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.DocumentsValidation.IsValidPIS(System.String)">
            <summary>
            Verifica se um determinado PIS é válido.
            </summary>
        </member>
        <member name="T:Benner.Tecnologia.Business.ExpressionBuilder`1">
            <summary>
            Esta classe tem como função criar Expressões Lambda dinamicamente.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Benner.Tecnologia.Business.ExpressionBuilder`1.Expression">
            <summary>
            Expressão criada dinamicamente
            </summary>
        </member>
        <member name="P:Benner.Tecnologia.Business.ExpressionBuilder`1.HasExpression">
            <summary>
            Indica se já existe expressão.
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ExpressionBuilder`1.Create">
            <summary>
            Cria uma instância do ExpressionBuilder sem expressão definida
            </summary>
            <returns>Retorna a instância do ExpressionBuilder</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ExpressionBuilder`1.Create(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Cria uma instância do ExpressionBuilder com uma expressão expressão pré-definida
            </summary>
            <returns>Retorna a instância do ExpressionBuilder</returns>
        </member>
        <member name="M:Benner.Tecnologia.Business.ExpressionBuilder`1.And(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Cria uma nova instancia da expressão adicionando a expressão armazenada, o operador <![CDATA[&&]]> e a nova expressão adicionada.
            Caso não exista nenhuma expressão ainda, o operador é desconsiderado.
            </summary>
            <param name="expression">Expressão para ser adicionada</param>
        </member>
        <member name="M:Benner.Tecnologia.Business.ExpressionBuilder`1.EnsureHasFalseExpression">
            <summary>
            Caso não exista expressão preenchida, cria uma expressão que retorna falso
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ExpressionBuilder`1.EnsureHasTrueExpression">
            <summary>
            Caso não exista expressão preenchida, cria uma expressão que retorna verdadeiro
            </summary>
        </member>
        <member name="M:Benner.Tecnologia.Business.ExpressionBuilder`1.Or(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Cria uma nova instancia da expressão adicionando a expressão armazenada, o operador <![CDATA[||]]> e a nova expressão adicionada.
            Caso não exista nenhuma expressão ainda, o operador é desconsiderado.
            </summary>
            <param name="expression">Expressão para ser adicionada</param>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionExtensions.IsFalse``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},``0)">
            <summary>
            Compila a expressão com o objeto passado como parâmetro e retorna o resultado da expressão
            </summary>
            <typeparam name="T">Tipo do Objeto a ser validado</typeparam>
            <param name="expression">Expressão a validar</param>
            <param name="obj">O objeto a ser validado.</param>
            <returns>O resultado da execução da expressão.</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionExtensions.IsTrue``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},``0)">
            <summary>
            Compila a expressão com o objeto passado como parâmetro e retorna o resultado da expressão
            </summary>
            <typeparam name="T">Tipo do Objeto a ser validado</typeparam>
            <param name="expression">Expressão a validar</param>
            <param name="obj">O objeto a ser validado.</param>
            <returns>O resultado da execução da expressão.</returns>
        </member>
    </members>
</doc>
